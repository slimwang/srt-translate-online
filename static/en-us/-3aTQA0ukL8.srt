1
00:00:00,000 --> 00:00:04,000
Let's talk about how we might implement the shortest<u>dist</u>node function.

2
00:00:04,000 --> 00:00:08,000
We give it all the distances we've calculated so far for all the nodes that we could do that for

3
00:00:08,000 --> 00:00:11,000
and so that's just a big pile here.

4
00:00:11,000 --> 00:00:13,000
There is a bunch of nodes and for each node, we have some value

5
00:00:13,000 --> 00:00:17,000
and a lot of these values are temporarily assigned and they may actually change later,

6
00:00:17,000 --> 00:00:22,000
but what we want to know is which of these we'd like to pull out the smallest value

7
00:00:22,000 --> 00:00:25,000
and then we'd actually like to lead it from this set

8
00:00:25,000 --> 00:00:28,000
so we don't have to worry about getting the same value over and over and over again

9
00:00:28,000 --> 00:00:30,000
The next time we want to go in here we want to get the next smallest.

10
00:00:30,000 --> 00:00:33,000
How many different values might be in this blob?

11
00:00:33,000 --> 00:00:37,000
Well, there can be at most one for each node then probably less.

12
00:00:37,000 --> 00:00:39,000
There is probably lots of nodes that haven't been added in yet,

13
00:00:39,000 --> 00:00:42,000
but at worst, it's going to be Î¸(n).

14
00:00:42,000 --> 00:00:45,000
The nodes that are in the graph may have distances associated with them.

15
00:00:45,000 --> 00:00:49,000
To get the smallest distance in here, the nature thing to do is to loop through the list.

16
00:00:49,000 --> 00:00:52,000
Take all the distances that we actually have at the moment

17
00:00:52,000 --> 00:00:55,000
just loop through them and pull out the minimum, easy Î¸(n)

18
00:00:55,000 --> 00:00:57,000
and in fact, that's what I implemented here.

19
00:00:57,000 --> 00:01:00,000
The shortest<u>dist</u>node, you give it a mapping distances

20
00:01:00,000 --> 00:01:04,000
and it starts off with the best node undefined and best value something big

21
00:01:04,000 --> 00:01:10,000
from probably really want something bigger than this and for all the nodes that we have distances for

22
00:01:10,000 --> 00:01:14,000
If the distance for that node is better than the best we've seen so far, reassign

23
00:01:14,000 --> 00:01:16,000
and when you're done, just return the best node.

24
00:01:16,000 --> 00:01:20,000
This is really quite straightforward and what is the running time that this leads to?

25
00:01:20,000 --> 00:01:24,000
These are some tricky run times than the ones I've suggested in the past.

26
00:01:24,000 --> 00:01:28,000
We've got n nodes and m edges, and we want to know,

27
00:01:28,000 --> 00:01:34,000
if we implement the dijkstra algorithm with looping through the list to find the smallest value.

28
00:01:34,000 --> 00:01:36,000
What is the running time that we get? Just make the selection.
