1
00:00:00,500 --> 00:00:04,130
We have come across the notion of similarity earlier in this course.

2
00:00:04,130 --> 00:00:07,720
When we were discussing learning [INAUDIBLE] cases, that particular point,

3
00:00:07,720 --> 00:00:11,740
we came across the matter of finding the nearest neighbor. At that point we

4
00:00:11,740 --> 00:00:15,410
found the nearest neighbor simply by looking at the [INAUDIBLE] distance between

5
00:00:15,410 --> 00:00:20,060
the new situation, and the familiar situations. We came across the notion of

6
00:00:20,060 --> 00:00:23,960
similarity when we were discussing case reasoning as well at that point,

7
00:00:23,960 --> 00:00:27,810
we came across at least two different methods of organizing the case library.

8
00:00:27,810 --> 00:00:32,030
And that, in one method, we could simply organize all the cases in array

9
00:00:32,030 --> 00:00:36,400
here's an array of several cases in the domain of navigation and urban area,

10
00:00:36,400 --> 00:00:41,700
each case here is represented, by the x and y location of the destination.

11
00:00:41,700 --> 00:00:45,720
A different and smarter method, also organizes cases that are discriminatory,

12
00:00:47,580 --> 00:00:52,660
the leaf nodes of this discrimination tree represented the cases. The root node

13
00:00:52,660 --> 00:00:56,700
and the interior nodes in the discrimination tree represented discrimination, or

14
00:00:56,700 --> 00:00:59,480
decisions about the values of specific features for

15
00:00:59,480 --> 00:01:03,980
example, east of 5th Street or not east of 5th street,

16
00:01:03,980 --> 00:01:07,690
both of these [INAUDIBLE] schemes are based on measures of similarity.

17
00:01:07,690 --> 00:01:11,920
In the first scheme the similarity is based on the similarity between the tags,

18
00:01:11,920 --> 00:01:14,320
If a new problem were to come along it would be more or

19
00:01:14,320 --> 00:01:17,030
less similarly one of these cases depending on whether or

20
00:01:17,030 --> 00:01:21,840
not its tags match the tags of a particular case here. In the second scheme of

21
00:01:21,840 --> 00:01:26,420
this [INAUDIBLE] tree, similarity is based on, traversing this particular tree,

22
00:01:26,420 --> 00:01:30,070
If a new problem came along, we would use the features of that new problem to

23
00:01:30,070 --> 00:01:35,900
traverse this tree and find the case whose features best match your new problem.

24
00:01:35,900 --> 00:01:39,770
Note that the new problem, and the source cases in all of these examples so

25
00:01:39,770 --> 00:01:43,770
far have been in the same domain. Here for example, both the new problem and

26
00:01:43,770 --> 00:01:49,050
the source case are in the same domain of navigating in an urban area,

27
00:01:49,050 --> 00:01:52,560
in the previous example, the new problem and the source case were the domain of

28
00:01:52,560 --> 00:01:56,480
colored blocks in the blocks world. What happens if the new problem and

29
00:01:56,480 --> 00:02:00,690
the SOS case are not in the same domain? So consider the example of, a woman

30
00:02:00,690 --> 00:02:05,980
walking up the ladder and walking up the wall. The two dimension are the same,

31
00:02:05,980 --> 00:02:09,870
we're talking about woman in one case and in other case, a ladder in one case,

32
00:02:09,870 --> 00:02:15,090
a wall in other case yeah, there's some similarity. Situations like this,

33
00:02:15,090 --> 00:02:18,620
where the new problem and the source case are from different domains,

34
00:02:18,620 --> 00:02:22,380
lead to cross-domain analogies. So the question now becomes,

35
00:02:22,380 --> 00:02:26,720
how can we find leaf similarity between the new problem, the target problem, and

36
00:02:26,720 --> 00:02:29,260
the source case, if they happen to be in different domains?
