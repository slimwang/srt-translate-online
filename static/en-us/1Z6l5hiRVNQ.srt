1
00:00:00,740 --> 00:00:04,160
The second category of issues is coordination.

2
00:00:04,160 --> 00:00:08,200
Remember that we have heterogeneous distributed application,

3
00:00:08,200 --> 00:00:10,720
multiple things going on at the same time.

4
00:00:10,720 --> 00:00:15,730
And these multiple things have to synchronize across certain actions.

5
00:00:15,730 --> 00:00:17,909
Okay, and how is that going to be provided?

6
00:00:17,909 --> 00:00:21,911
The two main categories of a synchronization are synchronous applications,

7
00:00:21,911 --> 00:00:26,610
synch, synchronous communications and asynchronous communications.

8
00:00:26,610 --> 00:00:32,009
Synchronous means that when one piece of the application initiates that

9
00:00:32,009 --> 00:00:36,600
particular message or interaction that it

10
00:00:36,600 --> 00:00:42,480
waits until it gets a reply back, a response back, before continuing.

11
00:00:42,480 --> 00:00:45,710
Often synchronous types of interactions are clocked.

12
00:00:45,710 --> 00:00:48,970
That means that there's some heartbeat or

13
00:00:48,970 --> 00:00:52,090
some other measure of when it can do certain things.

14
00:00:52,090 --> 00:00:56,670
On the other hand asynchronous communication means the client can continue to

15
00:00:56,670 --> 00:01:00,720
execute after it sent the message and it's notified

16
00:01:00,720 --> 00:01:05,930
when the response comes back and it can take appropriate steps at that point.

17
00:01:05,930 --> 00:01:09,640
Obviously asynchronous is more general, but writing code for

18
00:01:09,640 --> 00:01:13,290
dealing with a, asynchronous coordination is a little trickier,

19
00:01:13,290 --> 00:01:14,690
it makes it a little harder to understand.

20
00:01:14,690 --> 00:01:15,910
So once again there's a trade off.

21
00:01:17,090 --> 00:01:21,340
Another question with respect to coordination is, who's in charge here?

22
00:01:21,340 --> 00:01:23,470
Okay, is it the client or the server?

23
00:01:23,470 --> 00:01:27,990
You've no doubt seen situations where the server is capable of pushing things

24
00:01:27,990 --> 00:01:32,710
out to the client such as web pages which you want to update with current events

25
00:01:32,710 --> 00:01:38,300
or it could be that the client requests information as it pulls from the server.

26
00:01:38,300 --> 00:01:42,190
Deciding how you're going to deal with that is a key design question in any

27
00:01:42,190 --> 00:01:43,080
distributed application.

28
00:01:44,340 --> 00:01:47,910
It's always the case with such applications that robustness is important.

29
00:01:47,910 --> 00:01:51,680
What this means is that the system can deal with situations where one or

30
00:01:51,680 --> 00:01:52,950
more of its components goes down.

31
00:01:54,250 --> 00:01:57,360
Think that you send out a message and you don't get any response back.

32
00:01:57,360 --> 00:02:01,010
And the reason that you don't get any response back is that the the piece of

33
00:02:01,010 --> 00:02:03,620
the application you were dealing with goes down.

34
00:02:03,620 --> 00:02:07,560
How does your part of the application deal with that?

35
00:02:07,560 --> 00:02:12,490
Think for example, if you were user facing you don't want to just wait there and

36
00:02:12,490 --> 00:02:13,500
leave the user in limbo.

37
00:02:13,500 --> 00:02:18,497
You want to provide perhaps some time map on

38
00:02:18,497 --> 00:02:24,030
a message acknowledgment and be able to let the user know what went on.

39
00:02:24,030 --> 00:02:26,520
Similar to robustness is availability.

40
00:02:26,520 --> 00:02:31,244
How does the system appear to the user as far as being available?

41
00:02:31,244 --> 00:02:34,480
Is it 24/7, type application?

42
00:02:34,480 --> 00:02:37,160
Does it have set maintenance times?

43
00:02:37,160 --> 00:02:39,850
How does it deal with load situations?

44
00:02:39,850 --> 00:02:43,330
That is, does it get so slow that the user gets frustrated?

45
00:02:43,330 --> 00:02:45,040
All those kinds of questions.

46
00:02:45,040 --> 00:02:47,110
Persistence we've already mentioned.

47
00:02:47,110 --> 00:02:50,250
In general this means how a server stayed maintained.

48
00:02:50,250 --> 00:02:52,034
One obvious approach is with a data base.

49
00:02:52,034 --> 00:02:56,299
It might be a file system, but nevertheless the choice has to be made.

50
00:02:56,299 --> 00:03:00,262
And if you've got multiple clients talking to the system,

51
00:03:00,262 --> 00:03:03,230
how is that concurrency handled?

52
00:03:03,230 --> 00:03:07,110
Okay, how does the server part of the application deal with all

53
00:03:07,110 --> 00:03:08,720
these multiple users?

54
00:03:08,720 --> 00:03:10,830
Related to that is the transaction and

55
00:03:10,830 --> 00:03:14,140
integrity constraints which we've talked about on the previous issue.
