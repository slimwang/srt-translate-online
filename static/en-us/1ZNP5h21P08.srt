1
00:00:00,620 --> 00:00:04,540
There are a variety of different approaches to implementing generalization in

2
00:00:04,540 --> 00:00:06,040
object oriented languages.

3
00:00:06,040 --> 00:00:10,500
One that we just alluded to, is inheritance that follows specific rules.

4
00:00:10,500 --> 00:00:16,880
Second, you could just simply use a single class that has some kind of flag

5
00:00:16,880 --> 00:00:21,740
that indicates whether a particular instance is of a certain type, and you might

6
00:00:21,740 --> 00:00:25,410
have multiple types and the fly could have multiple different, different values.

7
00:00:25,410 --> 00:00:30,170
If you did that you would then be hiding the child data that particular type

8
00:00:31,440 --> 00:00:35,270
inside that that that class as indicated by the flag.

9
00:00:36,270 --> 00:00:41,060
In Java you could use interfaces or enums which are two mechanisms that

10
00:00:41,060 --> 00:00:45,160
allow you that enforce the rules that I've that I've laid out,

11
00:00:45,160 --> 00:00:48,980
you can use the state pattern when we get to design patterns you'll see.

12
00:00:48,980 --> 00:00:54,360
That there might be situations where you want

13
00:00:54,360 --> 00:00:58,640
to have some flexibility that's not provided by using strict sub-classing.

14
00:00:58,640 --> 00:01:02,470
For example imagine that you're implementing a, application having to

15
00:01:02,470 --> 00:01:06,690
do with a library and the library might have different categories of books.

16
00:01:06,690 --> 00:01:09,210
It might have one-week books, two-weeks books,

17
00:01:09,210 --> 00:01:12,620
four-week books, and it would, might be natural to say well,

18
00:01:12,620 --> 00:01:15,870
I'll have three subclasses of the, of the class book.

19
00:01:15,870 --> 00:01:19,090
But what happens when a one-week book becomes a two-week book?

20
00:01:20,100 --> 00:01:23,370
And auditory language is you can't change the class of something.

21
00:01:23,370 --> 00:01:29,030
Once you've established as as being of a class, it's, it's there for ever.

22
00:01:29,030 --> 00:01:32,840
So the state patterns allow, allows you to have a way to have

23
00:01:33,900 --> 00:01:36,840
dynamically be able to adjust the class of an object.

24
00:01:36,840 --> 00:01:42,160
And then for languages like C++ that have multiple inheritance, this gives you

25
00:01:42,160 --> 00:01:48,050
the, the ability to specify the properties that you wish to inherit in more

26
00:01:48,050 --> 00:01:52,760
than one class and be able to inherit from those classes just what you need.
