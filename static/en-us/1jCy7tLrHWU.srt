1
00:00:00,000 --> 00:00:04,000
If you took CS 101, you saw the idea of memoization.

2
00:00:04,000 --> 00:00:08,000
If you haven't seen it, the idea is that sometimes particularly with

3
00:00:08,000 --> 00:00:12,000
the recursive function, you will be making the same function calls over and over again.

4
00:00:12,000 --> 00:00:16,000
If the result of a function call is always the same and the computation took a long time,

5
00:00:16,000 --> 00:00:22,000
it's better to store the results of each value of N with its result in a cache,

6
00:00:22,000 --> 00:00:27,000
a table data structure, and then look it up each time rather than try to recompute it.

7
00:00:27,000 --> 00:00:32,000
We can make this function be cached very simply with a couple extra lines of code.

8
00:00:32,000 --> 00:00:38,000
We ask if the argument is already in the cache, then we just go ahead and return it.

9
00:00:38,000 --> 00:00:41,000
Otherwise, we compute it, store it, and then return it.

10
00:00:41,000 --> 00:00:45,000
So this part with the dot, dot, dot, is the body of the function.

11
00:00:45,000 --> 00:00:50,000
All the rest is just the boiler plate that you have to do to implement this idea of a cache.

12
00:00:50,000 --> 00:00:54,000
We've done this once, and that's fine, but I'm worrying about the principle of

13
00:00:54,000 --> 00:00:55,000
Don't Repeat Yourself.

14
00:00:55,000 --> 00:01:00,000
There's probably going to be lots of functions in which I want to store intermediate results

15
00:01:00,000 --> 00:01:04,000
in a cache, and I don't want to have to repeat this code all of the time.

16
00:01:04,000 --> 00:01:08,000
So this is a great idea for a decorator.

17
00:01:08,000 --> 00:01:13,000
We can define a decorator called memo, which will go ahead and do this cache

18
00:01:13,000 --> 00:01:16,000
management, and we can apply it to any function.

19
00:01:16,000 --> 00:01:21,000
The great thing about this pattern of using memoization is that it will speed up

20
00:01:21,000 --> 00:01:26,000
any function f that you pass to it because doing a table look-up is going to be faster

21
00:01:26,000 --> 00:01:32,000
than a computation as long as the computation is nontrivial, is more than just a look-up.

22
00:01:32,000 --> 00:01:36,000
Now the hockey player, Wayne Gretzsky, once said that you miss 100% of the shots

23
00:01:36,000 --> 00:01:37,000
you don't take.

24
00:01:37,000 --> 00:01:39,000
This is kind of the converse.

25
00:01:39,000 --> 00:01:44,000
This is saying you speed up 100% of the computations that you don't make.

26
00:01:44,000 --> 00:01:45,000
So here's the memo decorator.

27
00:01:45,000 --> 00:01:49,000
The guts of it is the same as what I sketched out previously.

28
00:01:49,000 --> 00:01:54,000
If we haven't computed the result already, we compute the result by applying

29
00:01:54,000 --> 00:01:57,000
the function f to the arguments.

30
00:01:57,000 --> 00:02:01,000
It gives us the result. We cache that result away, then we return it for this time.

31
00:02:01,000 --> 00:02:03,000
It's ready for next time.

32
00:02:03,000 --> 00:02:08,000
Next time we come through, we try to look up the arguments in the cache

33
00:02:08,000 --> 00:02:09,000
to see if they're there.

34
00:02:09,000 --> 00:02:11,000
If they are, we return the result.

35
00:02:11,000 --> 00:02:17,000
And now I've decided to structure this one as a try-except statement

36
00:02:17,000 --> 00:02:19,000
rather than an if-then statement.

37
00:02:19,000 --> 00:02:21,000
In Python, you always have 2 choices.

38
00:02:21,000 --> 00:02:26,000
You can first ask for permission to say are the args in the cache,

39
00:02:26,000 --> 00:02:32,000
and if so, return cache or args, or you can use the try-except pattern to ask for

40
00:02:32,000 --> 00:02:37,000
forgiveness afterwards to say, I'm first going to try to say, if the args are in the cache,

41
00:02:37,000 --> 00:02:38,000
go ahead and return it.

42
00:02:38,000 --> 00:02:43,000
If I get a keyError, then I have to fill in the cache by doing the computation

43
00:02:43,000 --> 00:02:45,000
and then returning the result.

44
00:02:45,000 --> 00:02:49,000
The reason I use the try structure here rather than the if structure

45
00:02:49,000 --> 00:02:52,000
is because I knew I was going to need it anyways for this third case.

46
00:02:52,000 --> 00:02:57,000
Either the args are in the cache, or they aren't, but then there's this third case

47
00:02:57,000 --> 00:03:00,000
which says that the args are not even hashable.

48
00:03:00,000 --> 00:03:01,000
What does that mean?

49
00:03:01,000 --> 00:03:04,000
Start out with a dictionary d being empty,

50
00:03:04,000 --> 00:03:10,000
and then I'm going to have a variable x, and let's say x is a number.

51
00:03:10,000 --> 00:03:17,000
If I now ask, is x in d? That's going to tell me false. It's not in the dictionary yet.

52
00:03:17,000 --> 00:03:24,000
But now, let's say I have another variable, which is y, which is the list 1, 2, 3,

53
00:03:24,000 --> 00:03:28,000
and now if I ask is y in d?

54
00:03:28,000 --> 00:03:31,000
You'd think that would tell me false,

55
00:03:31,000 --> 00:03:32,000
but in fact, it doesn't.

56
00:03:32,000 --> 00:03:35,000
Instead, it gives me an error, and what it's going to tell me

57
00:03:35,000 --> 00:03:40,000
is type error: unhashable type: list. What does that mean?

58
00:03:40,000 --> 00:03:44,000
That means we were trying to look up y in the dictionary,

59
00:03:44,000 --> 00:03:47,000
and a dictionary is a hash table--implemented as a hash table.

60
00:03:47,000 --> 00:03:52,000
In order to do that, we have to compute the hash code for y and then look in that slot

61
00:03:52,000 --> 00:03:53,000
in the dictionary.

62
00:03:53,000 --> 00:03:56,000
But this error is telling us that there is no hash code for a list.

63
00:03:56,000 --> 00:03:58,000
Why do you think that is?

64
00:03:58,000 --> 00:04:03,000
Are lists unhashable because lists can be arbitrarily long,

65
00:04:03,000 --> 00:04:08,000
or because lists can hold any type of data as the elements, not just integers,

66
00:04:08,000 --> 00:04:11,000
or because lists are mutable.

67
00:04:11,000 --> 00:04:16,000
Now I recognize this might be a hard problem if you're not up on hash tables.

68
00:04:16,000 --> 00:04:18,000
This might not be a question you can answer.

69
00:04:18,000 --> 99:59:59,999
But give it a shot and give me your one best response.
