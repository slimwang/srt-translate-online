1
00:00:00,000 --> 00:00:02,000
Well, let's go through one way to do it together.

2
00:00:02,000 --> 00:00:05,000
I find it helpful to draw the finite state machine first.

3
00:00:05,000 --> 00:00:07,000
So here's my start state. We'll call it 1.

4
00:00:07,000 --> 00:00:12,000
And because "q * " accepts the empty string, it also has to be an accepting state,

5
00:00:12,000 --> 00:00:17,000
but I can see any number of q's that I like and still accept,

6
00:00:17,000 --> 00:00:22,000
so it looks like we've got 1 state, 1 edge, and our state is also an accepting state.

7
00:00:22,000 --> 00:00:26,000
So just to show that this program really works, we're going to run it in the interpreter.

8
00:00:26,000 --> 00:00:30,000
Over here, I have defined edges, just as we suggested.

9
00:00:30,000 --> 00:00:32,000
In state 1 on a 'q', you loop back to state 1.

10
00:00:32,000 --> 00:00:36,000
State 1 is our start state, and it's also our accepting state.

11
00:00:36,000 --> 00:00:41,000
Let's try out our simulation on a bunch of q's, the empty string, and a bunch of q's

12
00:00:41,000 --> 00:00:42,000
with an evil interloper.

13
00:00:42,000 --> 00:00:47,000
We've got this 'A' hiding here. This should be true. True. False.

14
00:00:47,000 --> 00:00:48,000
Oh, and it is.

15
00:00:48,000 --> 99:59:59,999
So our finite state machine simulator matches our intuition exactly.
