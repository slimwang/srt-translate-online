1
00:00:00,250 --> 00:00:03,600
So their answer is both of the last two. Both of

2
00:00:03,600 --> 00:00:06,350
these will need to go through the loop here, the number of

3
00:00:06,350 --> 00:00:09,360
elements in index times. In the case where it's a word that's

4
00:00:09,360 --> 00:00:12,990
not in a index, the test will always be false, and will

5
00:00:12,990 --> 00:00:15,350
get to the end of the loop and return none. In

6
00:00:15,350 --> 00:00:18,642
the case where the last word is added, we'll still go through

7
00:00:18,642 --> 00:00:21,810
the loop, the number of elements times, but the very last time

8
00:00:21,810 --> 00:00:25,470
we'll find a match, and return that element. One of the assumptions

9
00:00:25,470 --> 00:00:27,300
in all of this analysis is that the time it

10
00:00:27,300 --> 00:00:29,950
takes to go through the loop doesn't depend on the actual

11
00:00:29,950 --> 00:00:32,960
keyword that's passed in. And that's assuming that this equal

12
00:00:32,960 --> 00:00:38,000
comparison takes the same amount of time depending on what the

13
00:00:38,000 --> 00:00:40,830
entry and the keyword is. That it doesn't matter what

14
00:00:40,830 --> 00:00:43,190
the keyword is the time to do this comparison is the

15
00:00:43,190 --> 00:00:46,370
same. And it turns out that for strings and Python that's

16
00:00:46,370 --> 00:00:50,110
the case. That we can do these string comparisons very quickly,

17
00:00:50,110 --> 00:00:53,420
because strings are immutable. That means that we don't need to look

18
00:00:53,420 --> 00:00:56,180
at all the characters in the string to compare two strings. That

19
00:00:56,180 --> 00:00:59,370
double equal for strings can be done in such a way that

20
00:00:59,370 --> 00:01:01,660
it doesn't need to look at the whole string. It knows that the

21
00:01:01,660 --> 00:01:03,850
strings were created as different strings.

22
00:01:03,850 --> 00:01:05,349
That means they're different strings. Or

23
00:01:05,349 --> 00:01:08,760
if they were created as the same string, they're the same string. So

24
00:01:08,760 --> 00:01:11,750
that's the reason why we say that all of the other operations

25
00:01:11,750 --> 00:01:15,330
in the loop have constant time. That they don't depend on the size

26
00:01:15,330 --> 00:01:18,840
of inputs at all. These are all very fast operations. What

27
00:01:18,840 --> 00:01:21,770
matters in terms of understanding the time is the number of times

28
00:01:21,770 --> 00:01:24,860
we go through that index. If you take the follow on course,

29
00:01:24,860 --> 00:01:28,290
which I hope you will, we'll understand how to analyze algorithms in

30
00:01:28,290 --> 00:01:31,120
a more formal way. For now our goal is to develop

31
00:01:31,120 --> 00:01:34,640
an intuition, and for that intuition the important thing to understand is

32
00:01:34,640 --> 00:01:37,310
the running time depends on the number of times we go through

33
00:01:37,310 --> 00:01:40,520
this loop. Everything that we do inside the loop is constant time.

34
00:01:40,520 --> 00:01:42,890
It's not affected by the size of the elements.
