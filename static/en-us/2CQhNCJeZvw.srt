1
00:00:00,490 --> 00:00:07,520
Having given you the abstractions and PTS, and the simplicity of the programming

2
00:00:07,520 --> 00:00:13,600
model. I will now introduce you to the heavy lifting that needs to happen

3
00:00:13,600 --> 00:00:15,950
under the covers in order to support

4
00:00:15,950 --> 00:00:18,980
this simple programming model from the point

5
00:00:18,980 --> 00:00:21,970
of view of the domain expert developing

6
00:00:21,970 --> 00:00:26,820
a situation awareness application. All the computations

7
00:00:26,820 --> 00:00:30,310
in the application can be considered as

8
00:00:30,310 --> 00:00:33,400
either producers or consumers of data. Producers

9
00:00:33,400 --> 00:00:36,210
of data, are putting things into the

10
00:00:36,210 --> 00:00:39,660
system and consumers of data are getting stuff

11
00:00:39,660 --> 00:00:45,910
from the system. And under the covers there are worker threads in the run-time

12
00:00:45,910 --> 00:00:49,400
system of PTS that react to these

13
00:00:49,400 --> 00:00:52,890
get calls coming from the producers and consumers.

14
00:00:52,890 --> 00:00:58,580
For instance, whenever, a producer puts an item, that results in

15
00:00:58,580 --> 00:01:04,180
new item triggers. That are going to be generated by the worker threads to the

16
00:01:04,180 --> 00:01:07,630
rest of the implementation. Implementation of

17
00:01:07,630 --> 00:01:10,740
the channel architecture is a three

18
00:01:10,740 --> 00:01:19,290
layer architecture. The top layer is the live channel layer of the architecture.

19
00:01:19,290 --> 00:01:22,700
And this is the layer that reacts to

20
00:01:22,700 --> 00:01:25,960
the new item triggers coming from these worker

21
00:01:25,960 --> 00:01:31,450
threads, working on behalf of a put call that is coming from a producer. So the

22
00:01:31,450 --> 00:01:35,280
channel abstractions result in these new item triggers

23
00:01:35,280 --> 00:01:38,220
to be sent to the live channel layer.

24
00:01:38,220 --> 00:01:41,040
Of the channel architecture. And the live channel

25
00:01:41,040 --> 00:01:44,960
layer, is the one that is holding a snapshot

26
00:01:44,960 --> 00:01:47,930
of items that have been generated on

27
00:01:47,930 --> 00:01:51,800
a particular channel. Starting from the oldest item

28
00:01:51,800 --> 00:01:56,120
in the channel to the newest item that just came in because of this new item

29
00:01:56,120 --> 00:02:03,140
trigger At the time of creation of a channel, the creator of a channel could

30
00:02:03,140 --> 00:02:07,270
specify what the semantics of the data that

31
00:02:07,270 --> 00:02:11,100
are kept in this channel are. In particular,

32
00:02:11,100 --> 00:02:16,510
a creator of a channel could say that, what I want the channel to contain are

33
00:02:16,510 --> 00:02:21,570
live data corresponding to a certain snapshot of

34
00:02:21,570 --> 00:02:24,820
real time. From oldest to new. For instance,

35
00:02:24,820 --> 00:02:31,220
I could say keep only the last 30 seconds of data in the channel. Rest of

36
00:02:31,220 --> 00:02:36,230
it, you can throw it away. So there is a garbage collection trigger that is part

37
00:02:36,230 --> 00:02:38,400
of the run time system, that is looking

38
00:02:38,400 --> 00:02:42,320
at information that is in the channel, that says.

39
00:02:42,320 --> 00:02:45,720
What items in the channel have become old

40
00:02:45,720 --> 00:02:48,110
and therefore can be thrown away. Those are the

41
00:02:48,110 --> 00:02:51,540
Gc triggers. And the Gc triggers will move

42
00:02:51,540 --> 00:02:54,440
data that have become ancient, so far as this

43
00:02:54,440 --> 00:02:56,930
channel is concerned, and move it into this

44
00:02:56,930 --> 00:03:01,320
garbage list. Meaning that these items are no longer

45
00:03:01,320 --> 00:03:03,100
relevant from the point of view of this

46
00:03:03,100 --> 00:03:07,100
application. And therefore they can be garbage collected.

47
00:03:07,100 --> 00:03:10,170
So they're put into this garbage list. And

48
00:03:10,170 --> 00:03:14,000
there is another garbage collection thread that is responsible

49
00:03:14,000 --> 00:03:17,080
for periodically cleaning up all the garbage that

50
00:03:17,080 --> 00:03:19,700
has been created and throwing away stuff that

51
00:03:19,700 --> 00:03:23,160
is no longer relevant. For this computation. So

52
00:03:23,160 --> 00:03:26,120
this is all the channel book keeping that's happening,

53
00:03:26,120 --> 00:03:31,820
under the covers in support of an application that is using the PTS library.

54
00:03:31,820 --> 00:03:39,380
But there's a lot more to it than just dealing with live data and data that

55
00:03:39,380 --> 00:03:43,646
is no longer relevant that has to be garbage collected or thrown away. As I

56
00:03:43,646 --> 00:03:47,480
mentioned one of the features of the

57
00:03:47,480 --> 00:03:51,430
PTS architecture is the fact that an application

58
00:03:51,430 --> 00:03:56,410
can choose to keep data for as long as they wants, and that is the

59
00:03:56,410 --> 00:04:01,140
persistence property supported by PTS run time system.

60
00:04:01,140 --> 00:04:04,810
So once again properties of the channel An

61
00:04:04,810 --> 00:04:09,090
application programmer could specify that, I don't

62
00:04:09,090 --> 00:04:12,540
want to throw away stuff that becomes old

63
00:04:12,540 --> 00:04:17,089
to keep in the channel, but I want to archive them, I want to persist them.

64
00:04:17,089 --> 00:04:19,230
And if those properties have been associated

65
00:04:19,230 --> 00:04:23,280
with the channel, then when items go past

66
00:04:23,280 --> 00:04:25,440
the window that has to be stored in

67
00:04:25,440 --> 00:04:28,060
the Live Channel Layer. The Live Channel Layer

68
00:04:28,060 --> 00:04:31,090
results in generating what are called persistent

69
00:04:31,090 --> 00:04:34,950
triggers to indicate that some items have become

70
00:04:34,950 --> 00:04:37,250
old in this channel, and they have to

71
00:04:37,250 --> 00:04:42,610
be persisted. The second main functional layer in

72
00:04:42,610 --> 00:04:45,490
the channel architecture is the Persistence layer.

73
00:04:45,490 --> 00:04:48,230
The Interaction layer is just a go between

74
00:04:48,230 --> 00:04:50,650
the Live Channel layer and the Persistence

75
00:04:50,650 --> 00:04:53,350
layer of the channel architecture. And what the

76
00:04:53,350 --> 00:04:57,850
Persistence layer does is, based on the

77
00:04:57,850 --> 00:05:00,260
persistence triggers that it gets from the live

78
00:05:00,260 --> 00:05:04,450
channel layer. It is going to take items from

79
00:05:04,450 --> 00:05:08,270
the channel and decide how to persist them.

80
00:05:08,270 --> 00:05:13,890
Now, here again, the application can have a say in how items need to

81
00:05:13,890 --> 00:05:17,040
be persisted. And they do that by

82
00:05:17,040 --> 00:05:21,300
having a Pickling Handler. That is, the application

83
00:05:21,300 --> 00:05:27,580
can specify Here is a function that I want you to use every time you decide

84
00:05:27,580 --> 00:05:33,940
to persist some item from the channel. For example, an application may specify

85
00:05:33,940 --> 00:05:40,200
that don't store all the images as is on archive or storage,

86
00:05:40,200 --> 00:05:45,360
but Condense them in such and so fashion. And that is a function that it can

87
00:05:45,360 --> 00:05:48,420
supply. And the runtime system, when it

88
00:05:48,420 --> 00:05:52,525
works on persistence, will automatically apply the

89
00:05:52,525 --> 00:05:57,030
application-specified function on the items that need

90
00:05:57,030 --> 00:05:59,860
to be persisted to create a digest.

91
00:05:59,860 --> 00:06:04,560
Which will then be persistent. Items that need to be persistent necessarily have

92
00:06:04,560 --> 00:06:08,470
to go to non-volatile storage devices, and

93
00:06:08,470 --> 00:06:12,250
here again, the PTS architecture supports several

94
00:06:12,250 --> 00:06:16,330
different configured Backends to store items that

95
00:06:16,330 --> 00:06:18,623
need to be persistent. And the Backend

96
00:06:18,623 --> 00:06:20,398
layer is the third layer in the

97
00:06:20,398 --> 00:06:25,205
channel architecture. And PTS supports several different

98
00:06:25,205 --> 00:06:29,080
Backends to support the persistence activities and

99
00:06:29,080 --> 00:06:31,130
it is an application choice as to

100
00:06:31,130 --> 00:06:36,860
which back end layer it wants to use for its specific application. The Backend

101
00:06:36,860 --> 00:06:43,130
layers supported by PTS include mySQL, it can use Unix file system as a

102
00:06:43,130 --> 00:06:50,440
persistence layer, or it can use a file system from IBM called GPFS. So mySQL,

103
00:06:50,440 --> 00:06:56,520
Unix file system, and GPFS are the three different Backends that are available.

104
00:06:56,520 --> 00:07:02,130
For the persistence layer to store channel data that needs to be archived for

105
00:07:02,130 --> 00:07:08,130
later retrieval. The nice property is that all of the persistence activities

106
00:07:08,130 --> 00:07:15,780
happen unbeknownst to the user. All that the user has done is in the creation of

107
00:07:15,780 --> 00:07:19,850
a channel. Specified certain properties to associate

108
00:07:19,850 --> 00:07:23,300
with that channel. For example, the property that

109
00:07:23,300 --> 00:07:29,590
may have been associated with a channel is that any items beyond the last 30

110
00:07:29,590 --> 00:07:32,410
seconds persistent on the storage, and when

111
00:07:32,410 --> 00:07:35,450
you persist them on the storage, apply this

112
00:07:35,450 --> 00:07:38,640
function. Those are the things being specified

113
00:07:38,640 --> 00:07:41,670
by the user creation time of the channel,

114
00:07:41,670 --> 00:07:47,070
once that is done the heavy lifting that needs to be done during down time,

115
00:07:47,070 --> 00:07:49,950
is all handled under the covers, by

116
00:07:49,950 --> 00:07:53,280
the run time system. Of the channel architecture

117
00:07:53,280 --> 00:07:57,020
that takes items from the channel, pickles

118
00:07:57,020 --> 00:08:00,310
them using the function that has been specified,

119
00:08:00,310 --> 00:08:03,920
and uses one of the configured Backends to

120
00:08:03,920 --> 00:08:07,950
push those pickled items onto the persistent storage.

121
00:08:07,950 --> 00:08:15,210
On the other side, when. An application wants to get an item. That item range

122
00:08:15,210 --> 00:08:21,120
may span from something that is there in the live channel part of the three

123
00:08:21,120 --> 00:08:27,700
layer architecture, or it could be on the archival storage. Now it is up to the

124
00:08:27,700 --> 00:08:33,150
run time system to retrieve all the items between the lower bond. And the upper

125
00:08:33,150 --> 00:08:39,909
bound specified by get primitive. So get primitive that spans both live and

126
00:08:39,909 --> 00:08:43,558
archived items results in get triggers being

127
00:08:43,558 --> 00:08:45,930
passed from the light channel through the

128
00:08:45,930 --> 00:08:51,680
interaction layer to the Backend so that corresponding to the get interval that

129
00:08:51,680 --> 00:08:58,330
is specified. The Backend layer can pull the data from the archive storage and

130
00:08:58,330 --> 00:09:00,650
pass it up so that it finally gets

131
00:09:00,650 --> 00:09:03,800
to the application. What I wanted to illustrate through

132
00:09:03,800 --> 00:09:06,800
this picture is there is a lot of heavy

133
00:09:06,800 --> 00:09:10,120
lifting that needs to happen in order to support

134
00:09:10,120 --> 00:09:12,770
a simple programming model. The programming model is very

135
00:09:12,770 --> 00:09:17,480
simple But, in order to support the simplicity, all

136
00:09:17,480 --> 00:09:19,980
of the heavy lifting has to be absorbed under

137
00:09:19,980 --> 00:09:23,760
the covers in the run time system of the

138
00:09:23,760 --> 00:09:25,410
PTS programing model.
