1
00:00:00,210 --> 00:00:04,190
So Layer Blocks sounds like
a powerful technology.

2
00:00:04,190 --> 00:00:08,870
Can you reflect any on
what change it's meant to

3
00:00:08,870 --> 00:00:13,460
people as they're confronted with
developing a new application?

4
00:00:13,460 --> 00:00:16,660
Do they think about the architecting
of it now any differently

5
00:00:16,660 --> 00:00:18,120
than they did in the past?

6
00:00:18,120 --> 00:00:21,700
>> Certainly, when we build new
instances of the forecaster.

7
00:00:23,110 --> 00:00:27,088
It changes dramatically how we
think about configuring that,

8
00:00:27,088 --> 00:00:31,817
because now there's a lot more structure
in place based on the existence of

9
00:00:31,817 --> 00:00:36,695
Layer Blocks itself and these assembly
specifications to allow us to plan for

10
00:00:36,695 --> 00:00:39,341
a new configuration of this capability.

11
00:00:39,341 --> 00:00:42,720
And to divvy up the parts
when executing it.

12
00:00:42,720 --> 00:00:47,906
In terms of new capabilities,
I think it's been a mixed bag in

13
00:00:47,906 --> 00:00:52,894
the sense of I think that people
often find it very difficult

14
00:00:52,894 --> 00:00:57,910
to come up with the right abstractions,
initially.

15
00:00:57,910 --> 00:01:00,240
So, even with Layer Blocks and

16
00:01:00,240 --> 00:01:04,769
with this approach kind of in the bag of
tools, we often don't immediately think,

17
00:01:04,769 --> 00:01:08,960
when we have a new problem to solve,
that it's going to be a product line.

18
00:01:08,960 --> 00:01:12,630
Or that's this is
the right way to solve it.

19
00:01:12,630 --> 00:01:14,390
And I don't know what to do about that.

20
00:01:14,390 --> 00:01:17,940
Perhaps if we got better at,

21
00:01:17,940 --> 00:01:21,810
kind of, a priori feature analysis,
it would be more obvious.

22
00:01:21,810 --> 00:01:29,180
Or perhaps maybe,
you have to build one or two products

23
00:01:29,180 --> 00:01:32,870
in a product line to recognize that you
have a product line there to begin with.

24
00:01:32,870 --> 00:01:35,900
I'm not really sure, I think it's
still kind of an open question.

25
00:01:35,900 --> 00:01:38,570
But that's been our experience to date.

26
00:01:38,570 --> 00:01:40,250
>> The other thing I'd
like to ask you is, for

27
00:01:40,250 --> 00:01:45,920
the benefit of the students who might
want to become software architects.

28
00:01:45,920 --> 00:01:49,658
Do you have any reflection on
the relationship between, kind of,

29
00:01:49,658 --> 00:01:53,199
the academic knowledge that you
learn about software design,

30
00:01:53,199 --> 00:01:54,736
software architecture and

31
00:01:54,736 --> 00:01:59,167
what you have to confront in the real
world with doing software architecture?

32
00:01:59,167 --> 00:02:01,688
>> So,
let me think of a few things that.

33
00:02:01,688 --> 00:02:03,069
It's all over the map.

34
00:02:03,069 --> 00:02:08,479
I've found that, in the last seven
years, I've used just about every

35
00:02:08,479 --> 00:02:13,441
thing that I've learned in
a software engineering course that,

36
00:02:13,441 --> 00:02:19,520
at the time, seemed very abstract and
perhaps I thought I'd never use this.

37
00:02:19,520 --> 00:02:20,028
I do.

38
00:02:20,028 --> 00:02:23,837
But let me try to be concrete about
things I've found that are definitely

39
00:02:23,837 --> 00:02:24,721
useful skills.

40
00:02:24,721 --> 00:02:28,910
So, maybe the biggest one for
me is, well two.

41
00:02:28,910 --> 00:02:33,907
One is data modeling,
be it data modelling using ER,

42
00:02:33,907 --> 00:02:36,803
or ORM, or UML, or whatever.

43
00:02:36,803 --> 00:02:41,740
Getting really good at
modeling at a conceptual level

44
00:02:41,740 --> 00:02:44,930
the structure of data in a system.

45
00:02:44,930 --> 00:02:46,860
If you're going to build any kind
of system like the ones I'm just

46
00:02:46,860 --> 00:02:48,840
mentioning, that is
a really critical skill.

47
00:02:48,840 --> 00:02:52,370
And even though it's taught pretty
well in database courses and

48
00:02:52,370 --> 00:02:54,170
a lot of people take database courses,

49
00:02:54,170 --> 00:02:58,680
you'd be amazed at just how rare
it is to be really good at that.

50
00:02:58,680 --> 00:03:01,700
So, getting facility and
data modeling and

51
00:03:01,700 --> 00:03:06,970
not applying it just to database design,
but to any kind of information design

52
00:03:06,970 --> 00:03:11,440
problem at all, I've found it extremely
useful and to really pay dividends.

53
00:03:11,440 --> 00:03:16,173
I've also found it really useful to
get really comfortable with many

54
00:03:16,173 --> 00:03:19,275
different models of
software composition,

55
00:03:19,275 --> 00:03:24,181
because you just never know when one
might be useful and they often are.

56
00:03:24,181 --> 00:03:29,098
So, when I was a student
at Georgia Tech,

57
00:03:29,098 --> 00:03:33,591
I spent a lot of time
learning how to use

58
00:03:33,591 --> 00:03:38,730
process algebras and CSP, FSP, LOTOS.

59
00:03:38,730 --> 00:03:41,450
There's a whole family of
these action languages

60
00:03:41,450 --> 00:03:44,090
that were very interesting to me.

61
00:03:44,090 --> 00:03:47,370
And we covered them in classes,
and we learned how to use them.

62
00:03:47,370 --> 00:03:52,900
And they have very nice compositional
capabilities that were very elegant and

63
00:03:52,900 --> 00:03:55,870
very clean and were very well-studied.

64
00:03:55,870 --> 00:03:59,810
But it wasn't really clear
how to use them in something.

65
00:03:59,810 --> 00:04:02,992
There was not a compiler that you would
write programs in this language to use

66
00:04:02,992 --> 00:04:04,495
to build a big piece of your system.

67
00:04:04,495 --> 00:04:06,921
But over time,
I've found that they come back a lot.

68
00:04:06,921 --> 00:04:11,377
In fact, we've started using them
in LogicBlox as the basis for

69
00:04:11,377 --> 00:04:16,248
building a batch automation framework
where you've got this problem

70
00:04:16,248 --> 00:04:18,079
of designing work flows.

71
00:04:18,079 --> 00:04:20,608
And you have to compose them, and
you need to compose them using

72
00:04:20,608 --> 00:04:22,670
a small number of very
clearly defined operators.

73
00:04:22,670 --> 00:04:24,780
And doing it cleanly and
being able to reason about it.

74
00:04:24,780 --> 00:04:26,250
So, things like that
have been very useful.

75
00:04:26,250 --> 00:04:30,750
Petri nets, which I studied many, many
years ago, and also seemed like a nice,

76
00:04:30,750 --> 00:04:37,120
elegant way to think about concurrency,
and data flows, and work flows.

77
00:04:38,270 --> 00:04:41,920
Again, it's not immediately obvious
how to just take that and use it, but

78
00:04:41,920 --> 00:04:44,820
you'll find that they'll inspire
designs that you'll see in the future.

79
00:04:44,820 --> 00:04:48,960
And they'll be just the right thing when
you run into some architectural problem.

80
00:04:48,960 --> 00:04:52,240
What are some others?

81
00:04:52,240 --> 00:04:56,830
Any kind of algebraic approach to
thinking about software composition,

82
00:04:56,830 --> 00:04:58,390
I think that, maybe,
is the underlying theme.

83
00:04:58,390 --> 00:05:03,222
If you can understand nice, clean,
elegant models of software composition.

84
00:05:03,222 --> 00:05:04,920
What are their properties?

85
00:05:04,920 --> 00:05:05,820
When are they useful?

86
00:05:07,320 --> 00:05:09,660
How can you use them to
inspire the designs?

87
00:05:09,660 --> 00:05:14,110
You'll find that a lot of infrastructure
work that you do tends to be better by

88
00:05:14,110 --> 00:05:18,423
having been inspired by these ideas that
have been worked out by a lot of very

89
00:05:18,423 --> 00:05:22,753
smart people over many years, rather
than try to come up with it yourself.

90
00:05:22,753 --> 00:05:26,875
And, I guess, maybe the last thing
I'd say is a segue from that, and

91
00:05:26,875 --> 00:05:30,784
that is this is not something that
we tend to to very well generally

92
00:05:30,784 --> 00:05:32,710
as software developers.

93
00:05:32,710 --> 00:05:37,080
But knowing a body of related work,
and when you start a new problem,

94
00:05:37,080 --> 00:05:39,940
try to relate your problem to
a problem that has already been seen,

95
00:05:39,940 --> 00:05:41,730
because chances are someone
has solved it or

96
00:05:41,730 --> 00:05:44,150
solved some variant of it that
you can heavily borrow from.

97
00:05:45,390 --> 00:05:48,620
I think that's huge, and I think that
that's maybe the biggest piece of

98
00:05:48,620 --> 00:05:50,660
advice I would give to
a budding software architect.

99
00:05:51,770 --> 00:05:55,620
>> So what I'm hearing is the world
is filled with all kinds of complex

100
00:05:55,620 --> 00:05:59,475
problems and the more weapons you
can bring to bear to solving them,

101
00:05:59,475 --> 00:06:02,021
the more likely you are to be able
get a handle on that complexity.

102
00:06:02,021 --> 00:06:02,955
>> Indeed, Indeed.

103
00:06:02,955 --> 00:06:08,874
>> Well, Kurt, this has been a wonderful
story you have to tell about this,

104
00:06:08,874 --> 00:06:13,743
and I'm glad that you were able
to apply some of your academic

105
00:06:13,743 --> 00:06:15,956
background to solving it.

106
00:06:15,956 --> 00:06:21,053
And I just want to thank you very much
for conveying that story to the class.

107
00:06:21,053 --> 00:06:23,370
>> You're very welcome, and thank you
for the opportunity to tell the story.
