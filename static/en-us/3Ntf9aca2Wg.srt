1
00:00:00,330 --> 00:00:04,710
The third case is where the faulting page is

2
00:00:04,710 --> 00:00:08,220
not available in the cluster memories at all. In

3
00:00:08,220 --> 00:00:11,500
other words, the only copy exists on the disk.

4
00:00:11,500 --> 00:00:14,180
So in this case, what has to happen is, when

5
00:00:14,180 --> 00:00:19,260
we have the page fault on node P for this x, we have to go to the disk to

6
00:00:19,260 --> 00:00:21,760
fetch it. And we're going to fetch it, which

7
00:00:21,760 --> 00:00:25,592
means that the working set on node P is growing,

8
00:00:25,592 --> 00:00:28,680
similar to the first case. And so the local part is

9
00:00:28,680 --> 00:00:31,120
going to go up by one. In order to make room for

10
00:00:31,120 --> 00:00:34,670
that, I have to necessarily shrink the global part as in

11
00:00:34,670 --> 00:00:37,710
the first case. So, I am going to shrink that global part by

12
00:00:37,710 --> 00:00:40,538
1. By the way, I can pick any page from the

13
00:00:40,538 --> 00:00:43,868
global part, and both in the first case, as well as in

14
00:00:43,868 --> 00:00:47,272
this case, we can pick any page from the global part and

15
00:00:47,272 --> 00:00:50,826
send it out to a peer memory. And that's what we're doing

16
00:00:50,826 --> 00:00:55,340
here, so we are saying, here is a page that I have to get rid of. Who do I send

17
00:00:55,340 --> 00:00:57,663
it to? Well, I am going to send it to the

18
00:00:57,663 --> 00:01:01,343
guy that happens to have the globally oldest page in the

19
00:01:01,343 --> 00:01:05,140
entire cluster. So let's say there is some host R

20
00:01:05,140 --> 00:01:08,830
that has the globally oldest page in the entire cluster, and

21
00:01:08,830 --> 00:01:12,050
that globally oldest page in the host R could be

22
00:01:12,050 --> 00:01:16,200
on the local part or the global part of this host.

23
00:01:16,200 --> 00:01:18,210
So what we're going to do is, we're going to tell that

24
00:01:18,210 --> 00:01:21,740
guy, hey, I'm going to give you a page to hold,

25
00:01:21,740 --> 00:01:24,200
because this used to be in my global part, I

26
00:01:24,200 --> 00:01:27,770
don't have room anymore, because my local is increasing by one

27
00:01:27,770 --> 00:01:31,040
because of this page fault, and adding x to my

28
00:01:31,040 --> 00:01:34,170
working set now. So please hold on to this page that

29
00:01:34,170 --> 00:01:37,290
I'm going to give you, in your global cache. Now

30
00:01:37,290 --> 00:01:41,260
this guy has a split like this. So if it has

31
00:01:41,260 --> 00:01:44,010
to make room for this new page that is

32
00:01:44,010 --> 00:01:46,690
coming in from its peer, clearly it has to get

33
00:01:46,690 --> 00:01:48,520
rid of something. Where it will get rid of? Well,

34
00:01:48,520 --> 00:01:50,190
it has to throw it on the disk. Now, the

35
00:01:50,190 --> 00:01:55,590
interesting part is, if the oldest page on host R happens

36
00:01:55,590 --> 00:02:01,340
to be in the global cache of R, what can we say about that page z?

37
00:02:01,340 --> 00:02:06,360
Well, it has to be cleaned, because global part is nothing but a

38
00:02:06,360 --> 00:02:10,050
paging device. And therefore if it is here, it must

39
00:02:10,050 --> 00:02:13,020
be cleaned, and therefore, I can discard it without worrying

40
00:02:13,020 --> 00:02:16,690
about it. Just simply dump it. Drop it on the

41
00:02:16,690 --> 00:02:19,060
floor [LAUGH]. That's what I'm going to do. On the other

42
00:02:19,060 --> 00:02:22,100
hand, if it is on the local part, it could

43
00:02:22,100 --> 00:02:25,960
be dirty. That is, if the oldest page happens to

44
00:02:25,960 --> 00:02:28,800
be on host R, and it also happens to be

45
00:02:28,800 --> 00:02:32,090
in the local part of host R, it is conceivable

46
00:02:32,090 --> 00:02:35,440
that this page has been modified, in which case,

47
00:02:35,440 --> 00:02:37,960
that modified copy has to be written out to

48
00:02:37,960 --> 00:02:41,310
the disk. So in other words, when we pick

49
00:02:41,310 --> 00:02:46,870
host R to send this replacement page from my host,

50
00:02:46,870 --> 00:02:50,755
this guy, what he's going to do is, he's going to say, I have to get rid of

51
00:02:50,755 --> 00:02:53,000
a page in order to make room for this

52
00:02:53,000 --> 00:02:56,750
incoming global page, because i have the globally oldest page.

53
00:02:57,890 --> 00:03:00,480
And if I have the globally oldest page, then let

54
00:03:00,480 --> 00:03:03,035
me get rid of it by throwing it out onto the

55
00:03:03,035 --> 00:03:05,460
disk if it happens to be dirty. If it happens to

56
00:03:05,460 --> 00:03:08,130
be clean, simply drop it on the floor, because I know

57
00:03:08,130 --> 00:03:10,720
that all the pages are contained on the disk. That's the

58
00:03:10,720 --> 00:03:15,450
fundamental assumption we started with, that all the pages of the

59
00:03:15,450 --> 00:03:19,460
currently active processes are on the disk. It is just that

60
00:03:19,460 --> 00:03:23,220
the global cache of every node is acting as a surrogate

61
00:03:23,220 --> 00:03:25,790
for the disk, because it can be faster to

62
00:03:25,790 --> 00:03:28,860
access from the peer memory than from the disk. So

63
00:03:28,860 --> 00:03:31,690
similar to the first case, in this case also,

64
00:03:31,690 --> 00:03:35,430
the local portion of the physical memory allocation on host

65
00:03:35,430 --> 00:03:37,540
P is going to go up by one, and the

66
00:03:37,540 --> 00:03:40,350
global portion is going to go down by one. What

67
00:03:40,350 --> 00:03:45,010
about host R, well it really depends. If the oldest

68
00:03:45,010 --> 00:03:48,420
page on host R happens to be in the global

69
00:03:48,420 --> 00:03:51,730
cache, then there is no change, because I am

70
00:03:51,730 --> 00:03:55,550
reading the old page z for another page that is

71
00:03:55,550 --> 00:03:58,400
coming in from host P, that is y that

72
00:03:58,400 --> 00:04:01,130
is coming in. In that case there is no change

73
00:04:01,130 --> 00:04:03,920
in the allocation between local and global on host

74
00:04:03,920 --> 00:04:07,516
R. But on the other hand, if the globally oldest

75
00:04:07,516 --> 00:04:10,222
page happens to be from the local part of

76
00:04:10,222 --> 00:04:13,994
host R, what that means is that even though originally

77
00:04:13,994 --> 00:04:19,160
we thought z to be part of the working set of host R, clearly, the processes

78
00:04:19,160 --> 00:04:21,784
that were using it are either no longer

79
00:04:21,784 --> 00:04:26,294
active, or they're completed, or whatever, and therefore,

80
00:04:26,294 --> 00:04:30,420
we're throwing out this page. The local part

81
00:04:30,420 --> 00:04:33,230
is shrinking. If the local part on host

82
00:04:33,230 --> 00:04:35,800
R is shrinking, what that means is, I

83
00:04:35,800 --> 00:04:39,130
can use more of the memory that's available

84
00:04:39,130 --> 00:04:41,960
in host R for community service. That's the

85
00:04:41,960 --> 00:04:44,500
important message I should get out. That's the

86
00:04:44,500 --> 00:04:46,230
important message I want you to get out

87
00:04:46,230 --> 00:04:49,060
of looking at this particular page fault scenario.
