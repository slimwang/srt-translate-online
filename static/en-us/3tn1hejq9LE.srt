1
00:00:00,000 --> 00:00:03,000
So next kind of coverage I want to talk about is boundary value coverage.

2
00:00:03,000 --> 00:00:06,000
Boundary value coverage unlike some of the other coverage measures to be looked out

3
00:00:06,000 --> 00:00:08,000
doesn't have any specially take technical definition.

4
00:00:08,000 --> 00:00:10,000
Could be use it to me in different things. We're going to look at in a broad sense.

5
00:00:10,000 --> 00:00:14,000
Wihat boundary value coverage basically says is when a program depends on some numerical range

6
00:00:14,000 --> 00:00:18,000
and when the program has different behaviors based on numbers within that range

7
00:00:18,000 --> 00:00:20,000
then we should test numbers close to the boundary.

8
00:00:20,000 --> 00:00:23,000
So let's take the example where we're writing a program to determine

9
00:00:23,000 --> 00:00:26,000
whether somebody who lives in the USA is permitted to drink alcohol.

10
00:00:26,000 --> 00:00:32,000
So we want is the 21 years of age or more is fine for them to drink alcohol

11
00:00:32,000 --> 00:00:39,000
and if they are less than 21 that is to say 20 or less then it is not legal for them to drink alcohol.

12
00:00:39,000 --> 00:00:42,000
We just want to get the boundary value coverage on this program, we want to include the ages of

13
00:00:42,000 --> 00:00:48,000
20 and 21 in our test input and possibly also to 19 and 22 simply close enough to the boundary values

14
00:00:48,000 --> 00:00:50,000
that there maybe interesting behaviors looking good as well.

15
00:00:50,000 --> 00:00:53,000
The insight here is that one of the most prominent kinds of errors that we made while

16
00:00:53,000 --> 00:00:55,000
creating software is off by one error.

17
00:00:55,000 --> 00:00:57,000
Off by one error can almost always be triggered by a value with

18
00:00:57,000 --> 00:01:00,000
the boundary and so that's what we're trying to do here.

19
00:01:00,000 --> 00:01:04,000
What I've done here is frame the boundary value coverage as a function of only one variable

20
00:01:04,000 --> 00:01:09,000
and also I've framed it in terms of the program specification not in terms of the implementation.

21
00:01:09,000 --> 00:01:12,000
So let's look at those two issue and term. So let's consider a program with two inputs.

22
00:01:12,000 --> 00:01:15,000
It's assume for the sake of arguments that these inputs are treated independently

23
00:01:15,000 --> 00:01:17,000
by the software that we are running.

24
00:01:17,000 --> 00:01:20,000
So the first input is going to be the age of your car and where insurance company here

25
00:01:20,000 --> 00:01:25,000
and we're going to decline to insure cars more than 20 years old.

26
00:01:25,000 --> 00:01:28,000
The other parameter is the age of the driver and here we're going to decline

27
00:01:28,000 --> 00:01:31,000
to insure drivers who are less than 18 years old.

28
00:01:31,000 --> 00:01:36,000
If the software treats this values independently will probably okay testing values around 18

29
00:01:36,000 --> 00:01:40,000
independently of the age of the car and testing car ages around

30
00:01:40,000 --> 00:01:42,000
20 years old independently of the age of the driver.

31
00:01:42,000 --> 00:01:46,000
Now on the other hand, if we had specific knowledge of our implementation

32
00:01:46,000 --> 00:01:51,000
consider these variables together then we probably also need to test this combinations of inputs

33
00:01:51,000 --> 00:01:54,000
put in the other boundaries and you could see the problem here is that of course

34
00:01:54,000 --> 00:01:57,000
as the number of inputs of the program goes up the number of test cases

35
00:01:57,000 --> 00:02:00,000
can grow very large because we have to consider the interaction between all

36
00:02:00,000 --> 00:02:02,000
possible combinations of variables that are dependent.

37
00:02:02,000 --> 00:02:06,000
On the other hand, if our variables are independent then we can test this separately.

38
00:02:06,000 --> 00:02:09,000
So that was briefly to visit the issue of whether we are doing boundary value coverage

39
00:02:09,000 --> 00:02:12,000
with respect to the requirements of this specification purpose of software or whether we are doing it

40
00:02:12,000 --> 00:02:14,000
with respect to the implementation.

41
00:02:14,000 --> 00:02:18,000
Let's go and revisit the program we have a little bit earlier where I inserted a bug into our stats function

42
00:02:18,000 --> 00:02:21,000
which causes it to misbehave for some inputs and not for others.

43
00:02:21,000 --> 00:02:25,000
So if you recall, we have the function here stats which computes the minimum, the maximum,

44
00:02:25,000 --> 00:02:29,000
median, and the mode of the list of numbers and the problem I post you in a quiz was

45
00:02:29,000 --> 00:02:32,000
to break this function in such a way that

46
00:02:32,000 --> 00:02:36,000
a collection of test cases getting good coverage on it wouldn't discover the bug.

47
00:02:36,000 --> 00:02:39,000
And so the way I accomplished this was by taking the absolute value of the inputs

48
00:02:39,000 --> 00:02:42,000
and so here is a bug, what we're going to do is it's only going to be discoverable when

49
00:02:42,000 --> 00:02:45,000
we pass numbers into the function which contain negative values.

50
00:02:45,000 --> 00:02:49,000
So if we think about what it takes to get boundary value coverage on a function like this

51
00:02:49,000 --> 00:02:52,000
and now we're talking about rounded boundary value coverage considering the implementation

52
00:02:52,000 --> 00:02:57,000
not just the specification what will happen is a function like absolute value

53
00:02:57,000 --> 00:03:01,000
would change its behavior around zero and so what we need to do get boundary value coverage

54
00:03:01,000 --> 00:03:05,000
of the absolute value function is call it with a negative argument and a positive argument.

55
00:03:05,000 --> 00:03:09,000
So to get good boundary value coverage on this function, we would have been forced to call it

56
00:03:09,000 --> 00:03:12,000
with a list containing at least one negative number and we most likely

57
00:03:12,000 --> 00:03:14,000
in that case would have discover the bug.

58
00:03:14,000 --> 00:03:17,000
Let's look at this function in its broader context. We have a lot of code here.

59
00:03:17,000 --> 00:03:19,000
For example, i is less than mean, i is greater than max.

60
00:03:19,000 --> 00:03:24,000
We have a lot of different operators in here but I'll have different behaviors around certain boundaries

61
00:03:24,000 --> 00:03:26,000
and so to get good boundary value coverage on this function over all

62
00:03:26,000 --> 00:03:28,000
would be probably extremely difficult.

63
00:03:28,000 --> 00:03:31,000
I don't know a good tools automating this on Python and there are techniques

64
00:03:31,000 --> 00:03:33,000
such as mutation testing that can automate boundary value coverage

65
00:03:33,000 --> 99:59:59,999
at least in some forms in general.
