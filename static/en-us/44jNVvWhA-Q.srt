1
00:00:00,000 --> 00:00:03,000
Now I'd like to talk about being great at testing software,

2
00:00:03,000 --> 00:00:05,000
and this involves a number of different elements.

3
00:00:05,000 --> 00:00:08,000
First of all, we need to recognize that testing and development

4
00:00:08,000 --> 00:00:11,000
are fundamentally different roles, even if they're often

5
00:00:11,000 --> 00:00:13,000
played by the same exact people.

6
00:00:13,000 --> 00:00:15,000
A developer's primary attitude is

7
00:00:15,000 --> 00:00:17,000
I want this code to succeed.

8
00:00:17,000 --> 00:00:21,000
A tester's main attitude is I want this code to fail,

9
00:00:21,000 --> 00:00:24,000
and of course, the reason the tester wants the code to fail

10
00:00:24,000 --> 00:00:26,000
is that the tester's end goal is creating stronger code

11
00:00:26,000 --> 00:00:28,000
which later on doesn't fail.

12
00:00:28,000 --> 00:00:31,000
If we look at these requirements a little bit we can see that for the same person

13
00:00:31,000 --> 00:00:34,000
to be a great tester and a great developer

14
00:00:34,000 --> 00:00:36,000
there might be a little bit of doublethink involved,

15
00:00:36,000 --> 00:00:39,000
and so those of you who read Orwell will know that the doublethink is the

16
00:00:39,000 --> 00:00:43,000
ability to hold 2 contradictory beliefs in one's mind simultaneously,

17
00:00:43,000 --> 00:00:48,000
and there is a bit of that required in order to be a great tester and a great developer.

18
00:00:48,000 --> 00:00:52,000
And of course, really the contradictory nature of these 2 beliefs

19
00:00:52,000 --> 00:00:55,000
is only apparent because, of course, the developers and the testers

20
00:00:55,000 --> 00:00:58,000
in the end want the same thing, which is to create a great software.

21
00:00:58,000 --> 00:01:02,000
The second element of being great at testing is to learn to test creatively,

22
00:01:02,000 --> 00:01:04,000
and I showed the example earlier of testing an ARM assembler and disassembler

23
00:01:04,000 --> 00:01:08,000
by exploiting the fact that they were inverses of each other

24
00:01:08,000 --> 00:01:11,000
and also exploiting the fact that the ARM instruction space

25
00:01:11,000 --> 00:01:13,000
could be fully enumerated, and that's something that I consider to be a great example

26
00:01:13,000 --> 00:01:16,000
of creative testing, and if we can think of creative ways to test

27
00:01:16,000 --> 00:01:20,000
we often do a much better job than rote testing,

28
00:01:20,000 --> 00:01:23,000
and furthermore, do a much better job than just

29
00:01:23,000 --> 00:01:25,000
rote testing with the most obvious inputs.

30
00:01:25,000 --> 00:01:28,000
The third thing is that great testers never ignore

31
00:01:28,000 --> 00:01:30,000
weird things that they notice.

32
00:01:30,000 --> 00:01:32,000
It turns out that at least in my experience

33
00:01:32,000 --> 00:01:35,000
it's very often the case that we get little hints of things wrong

34
00:01:35,000 --> 00:01:39,000
with the software that lead to threads that if tugged on

35
00:01:39,000 --> 00:01:42,000
would have led us to discover problems that were really quite serious.

36
00:01:42,000 --> 00:01:45,000
On the other hand, if we see these little things wrong

37
00:01:45,000 --> 00:01:47,000
and we paper over them, we ignore them,

38
00:01:47,000 --> 00:01:50,000
we end up not finding those problems until later.

39
00:01:50,000 --> 00:01:53,000
I'm going to end up today with the claim

40
00:01:53,000 --> 00:01:55,000
that great testing is a lot of fun because

41
00:01:55,000 --> 00:01:58,000
it's fun to break software, and it's very satisfying

42
00:01:58,000 --> 00:02:00,000
to produce software that's really great

43
00:02:00,000 --> 00:02:04,000
because it's been well tested, and great testing can also be profitable.

44
00:02:04,000 --> 00:02:06,000
And what I mean here is that testing is a separate career

45
00:02:06,000 --> 00:02:09,000
at many companies like Microsoft and that companies

46
00:02:09,000 --> 00:02:13,000
like Google and Mozilla offer bug bounties,

47
00:02:13,000 --> 00:02:17,000
and what this means is if you find a security critical bug in,

48
00:02:17,000 --> 00:02:19,000
for example, Google Chrome, they'll pay you up to $20,000,

49
00:02:19,000 --> 00:02:21,000
and this isn't at all theoretical.

50
00:02:21,000 --> 00:02:24,000
I was recently talking to a software testing researcher

51
00:02:24,000 --> 00:02:27,000
who wrote an automatic tester and applied it to Chrome and to Mozilla,

52
00:02:27,000 --> 00:02:30,000
and their research group, over the course of a few months,

53
00:02:30,000 --> 99:59:59,999
made about $50,000.
