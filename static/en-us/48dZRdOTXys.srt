1
00:00:00,008 --> 00:00:03,843
The position GL_Position, and the color vColor, were generated by the vertex

2
00:00:03,843 --> 00:00:08,039
shader. These are passed on to the rasterizer, which interpolates these across

3
00:00:08,039 --> 00:00:11,850
the triangle and creates fragments. Each fragment is then passed through the

4
00:00:11,850 --> 00:00:15,593
fragment shader. You'll be happy to hear this shader is very simple. All this

5
00:00:15,593 --> 00:00:18,631
shader does is takes the interpolated color, vColor, and copies it over to

6
00:00:18,631 --> 00:00:21,669
gl_FragColor, the built-in output variable for what color appears on the

7
00:00:21,669 --> 00:00:26,106
screen. The fourth coordinate is set to the alpha value, which says how solid

8
00:00:26,106 --> 00:00:30,185
the surface is. This is normally 1. Notice how the language elegantly

9
00:00:30,185 --> 00:00:34,357
understands vectors. VColor is a vector with three coordinates. We construct

10
00:00:34,357 --> 00:00:37,891
the gl_FragColor, a four-element vector, by using vColor and appending a

11
00:00:37,891 --> 00:00:42,145
number. GLSL knows what this means. In general, the language is very aware of

12
00:00:42,145 --> 00:00:46,108
common vector and scalar operations. Here's another example of vector

13
00:00:46,108 --> 00:00:50,015
operations. Say we have an input specular color and a specular amount. We've

14
00:00:50,015 --> 00:00:52,394
computed a value for the specular variable, how much it should affect the

15
00:00:52,394 --> 00:00:56,230
fragment's color. In this line of code we multiply this variable, a single

16
00:00:56,230 --> 00:01:00,278
floating point number, by a vector with three elements. We add this to the

17
00:01:00,278 --> 00:01:04,063
fragment color by specifying which components we want changed. Here the R, G,

18
00:01:04,063 --> 00:01:08,592
and B components are modified. The component names for the 4 elements are XYZW

19
00:01:08,592 --> 00:01:14,787
for points and vectors, RGBA for colors, and STPQ for texture coordinates. S

20
00:01:14,787 --> 00:01:17,756
and T are sort of like U and V. I won't go into all the features of the

21
00:01:17,756 --> 00:01:20,814
language, see the additional course materials for full references. One thing

22
00:01:20,814 --> 00:01:24,690
worth mentioning is that there all sorts of built-in functions. Some you'll

23
00:01:24,690 --> 00:01:28,344
probably be familiar with, such as absolute value, sign, power, and square

24
00:01:28,344 --> 00:01:32,214
root. Others are more specific to graphic, such as normalize, dot, cross

25
00:01:32,214 --> 00:01:36,780
product, and reflect. For debugging shader code, the browser's debug console

26
00:01:36,780 --> 00:01:40,518
can often give useful errors. For example, in this line of code, I put a

27
00:01:40,518 --> 00:01:44,214
representation for a floating point number that's perfectly valid in C, but is

28
00:01:44,214 --> 00:01:49,481
not part of the GLSL language, so it was flagged here. Sometimes the errors are

29
00:01:49,481 --> 00:01:54,475
a bit cryptic. In this case the 0 should be 0.0. GLSL is very picky about

30
00:01:54,475 --> 00:01:58,616
having a floating point number have a decimal point. In either case, you'll get

31
00:01:58,616 --> 00:02:02,012
a blank screen or not much warning otherwise. I sometimes found myself adding a

32
00:02:02,012 --> 00:02:05,622
line or two at a time and seeing if everything stays on the screen. If not, I

33
00:02:05,622 --> 00:02:09,217
comment out the lines until my scene reappears. I call this binary search

34
00:02:09,217 --> 00:02:09,940
debugging.
