1
00:00:00,000 --> 00:00:02,480
And the answer here, surprisingly,

2
00:00:02,480 --> 00:00:04,050
at least I think it's very surprising

3
00:00:04,050 --> 00:00:07,280
this algorithm is capable of finding any combination

4
00:00:07,280 --> 00:00:10,260
of program and input that halts,

5
00:00:10,260 --> 00:00:13,030
and the reason is simple; if a program halts,

6
00:00:13,030 --> 00:00:15,100
then the program has a finite length,

7
00:00:15,100 --> 00:00:17,800
the input has a finite length, and the number of steps in which

8
00:00:17,800 --> 00:00:20,410
the program can run on the input, if it halts,

9
00:00:20,410 --> 00:00:22,430
is finite, and at a certain point in time,

10
00:00:22,430 --> 00:00:24,660
since this loop here is infinite,

11
00:00:24,660 --> 00:00:27,520
max length will be larger than any of those 3 constraints,

12
00:00:27,520 --> 00:00:29,810
and once max length has become large enough,

13
00:00:29,810 --> 00:00:32,940
we will find that P terminates on the input

14
00:00:32,940 --> 00:00:34,810
after a certain number of steps,

15
00:00:34,810 --> 00:00:36,160
and so we will print it.

16
00:00:36,160 --> 00:00:39,360
The only reason why the algorithm could not find the certain combination of

17
00:00:39,360 --> 00:00:41,350
program and input is that

18
00:00:41,350 --> 00:00:43,390
the program does not halt on that input.

19
00:00:43,390 --> 00:00:45,900
The first one, amazingly,

20
00:00:45,900 --> 00:00:48,370
means that the algorithm is indeed correct.

21
00:00:48,370 --> 00:00:51,390
Of course it is totally infeasible in practice, as well,

22
00:00:51,390 --> 00:00:53,080
because if you think about it,

23
00:00:53,080 --> 00:00:55,140
a program is a text string;

24
00:00:55,140 --> 00:00:58,860
now even for very, very, very small values of max length

25
00:00:58,860 --> 00:01:01,440
the number of these text strings for the program

26
00:01:01,440 --> 00:01:04,400
and of course also the number of text strings for this input here

27
00:01:04,400 --> 00:01:06,690
becomes exponentially huge,

28
00:01:06,690 --> 00:01:09,330
so it's a purely theoretical construct,

29
00:01:09,330 --> 00:01:12,350
but it explains at least in some theoretical computer science courses,

30
00:01:12,350 --> 00:01:15,590
you will hear that the Halting Problem is referred to as

31
00:01:15,590 --> 00:01:17,300
recursively enumerable.

32
00:01:17,300 --> 00:01:19,330
So the algorithm is totally impractical,

33
00:01:19,330 --> 00:01:21,310
but it is nevertheless correct,

34
00:01:21,310 --> 00:01:24,860
and that is the reason why the combination of programs and inputs

35
00:01:24,860 --> 00:01:27,140
for which the program halts on the input

36
00:01:27,140 --> 00:01:29,670
is called recursively enumerable,

37
00:01:29,670 --> 00:01:32,040
at least in some theoretical computer science courses.

38
00:01:32,040 --> 00:01:35,280
Now this one is interesting; can this algorithm be modified

39
00:01:35,280 --> 00:01:37,290
to output any programs that don't halt?

40
00:01:37,290 --> 00:01:39,490
And the answer here of course is no,

41
00:01:39,490 --> 00:01:41,770
because this technique here clearly only works

42
00:01:41,770 --> 00:01:43,990
when the program stops.

43
00:01:43,990 --> 00:01:45,470
As long as the program goes on,

44
00:01:45,470 --> 00:01:47,470
we can not make any statement about it.

45
00:01:47,470 --> 00:01:49,050
We cannot say it's a program,

46
00:01:49,050 --> 00:01:52,190
will it still continues running, if it will stop at a certain point in time,

47
00:01:52,190 --> 00:01:55,000
and that is the reason why we can't modify this algorithm,

48
00:01:55,000 --> 00:01:58,230
so that it finds combinations of programs that input that don't halt.

49
00:01:58,230 --> 00:02:01,910
This of course also tells you again why the problem is semi decidable

50
00:02:01,910 --> 00:02:04,720
because we can find those combinations here,

51
00:02:04,720 --> 99:59:59,999
but we can not find those over here.
