1
00:00:00,100 --> 00:00:04,510
The third type of cryptographic
algorithms is hash functions.

2
00:00:04,510 --> 00:00:07,170
Hash functions don't use keys.

3
00:00:07,170 --> 00:00:14,000
A hash function computes the hash, or
the message digest of data of any size.

4
00:00:14,000 --> 00:00:18,500
The hash or the message digest is
a fixed length output, typically,

5
00:00:18,500 --> 00:00:22,700
in the range of 128 to 512 bits.

6
00:00:22,700 --> 00:00:26,700
Hash functions are ,typically,
useful authentication and

7
00:00:26,700 --> 00:00:30,490
protection of message authenticity and
integrity.

8
00:00:30,490 --> 00:00:33,370
In order to provide these services,

9
00:00:33,370 --> 00:00:37,580
hash functions must satisfy
these following properties.

10
00:00:37,580 --> 00:00:42,880
First, it should be relatively easy to
compute a hash of a given message m.

11
00:00:42,880 --> 00:00:47,200
This would make hardware and
software implementations practical.

12
00:00:47,200 --> 00:00:51,180
In other words, we want to be able
to compute hash very efficiently.

13
00:00:51,180 --> 00:00:56,830
Second, for given hash value,
it should be completely infeasible to

14
00:00:56,830 --> 00:01:02,970
find the original message m, such that,
the hash of m is this given hash value.

15
00:01:02,970 --> 00:01:06,630
This so called one way
property is very important.

16
00:01:06,630 --> 00:01:11,970
For example, suppose Alice wants
to authenticate herself to Bob.

17
00:01:11,970 --> 00:01:14,330
Alice would hash a secret,

18
00:01:14,330 --> 00:01:18,740
that she shares with Bob,
as with the current timestamp together.

19
00:01:18,740 --> 00:01:21,980
For example,
she can concatenate the secret s,

20
00:01:21,980 --> 00:01:24,170
with the current timestamp together,
and then,

21
00:01:24,170 --> 00:01:29,500
hash over the concatenated value,
and send the hash value over to Bob.

22
00:01:29,500 --> 00:01:32,910
Bob would know that, this must be Alice,

23
00:01:32,910 --> 00:01:36,950
because he can check the current time
stamp, and he has the share secret S.

24
00:01:36,950 --> 00:01:38,660
In other words,

25
00:01:38,660 --> 00:01:43,310
Bob can take the current time stamp
concatenate with the shared secret s,

26
00:01:43,310 --> 00:01:47,980
and compute his own hash, and compare
with the hash value with the received

27
00:01:47,980 --> 00:01:53,680
hash value, if they match, then he knows
that he's been communicating with Alice.

28
00:01:53,680 --> 00:01:58,060
Now, because the hash value is
transmitted over the Internet, and

29
00:01:58,060 --> 00:02:00,570
we must assume that an attacker

30
00:02:00,570 --> 00:02:04,510
can obtain any value that's
transmitted over the Internet.

31
00:02:04,510 --> 00:02:09,090
That is, the attacker may be
able to obtain this hash value.

32
00:02:09,090 --> 00:02:10,979
If the hash function is not one way,

33
00:02:10,979 --> 00:02:14,450
that means the attacker can
reverse the hash function, and

34
00:02:14,450 --> 00:02:20,160
find out the input to the hash function,
which includes the share secret s.

35
00:02:20,160 --> 00:02:22,760
If the attacker knows
the share secret s,

36
00:02:22,760 --> 00:02:27,260
then the attacker can impersonate
Alice to Bob, or Bob to Alice.

37
00:02:27,260 --> 00:02:29,370
So this is, an example,

38
00:02:29,370 --> 00:02:34,490
that demonstrates that the one way
property of hash function is essential.

39
00:02:34,490 --> 00:02:38,130
Another property of hash function
is that given a message m1,

40
00:02:38,130 --> 00:02:44,000
it should be computationally infeasible
to find a different message m2,

41
00:02:44,000 --> 00:02:47,070
such that they have
the exact same hash value.

42
00:02:47,070 --> 00:02:50,370
This is the weak collision
resistant property.

43
00:02:50,370 --> 00:02:54,150
This is an essential property for
message authenticity and

44
00:02:54,150 --> 00:02:55,860
integrity protection.

45
00:02:55,860 --> 00:02:57,960
Imagine the following situation.

46
00:02:57,960 --> 00:03:00,950
Alice wants to send a message,
m, to Bob.

47
00:03:00,950 --> 00:03:03,860
And she wants to make
sure that Bob knows that

48
00:03:03,860 --> 00:03:06,540
Alice is the real author of m.

49
00:03:06,540 --> 00:03:11,180
So Alice is going to send m,
along with a sign hash of m,

50
00:03:11,180 --> 00:03:16,970
meaning that Alice would hash m and
then, sign hash, using her private key.

51
00:03:16,970 --> 00:03:20,550
Now an attacker can look at
the traffic on the Internet, and

52
00:03:20,550 --> 00:03:25,430
find that Alice is sending m,
and assign hash to Bob.

53
00:03:25,430 --> 00:03:28,610
If the weak collision resistant
property is not there,

54
00:03:28,610 --> 00:03:32,090
then the attacker may be able to
find a different message m pi,

55
00:03:32,090 --> 00:03:36,560
such that the hash of m pi would
be the same as the hash of m,

56
00:03:36,560 --> 00:03:41,121
therefore, although the attacker has
changed the message from m to m pi,

57
00:03:41,121 --> 00:03:43,540
the signature will still match.

58
00:03:43,540 --> 00:03:50,400
And therefore, when Bob receives m pi,
and the original signature of hash of m,

59
00:03:50,400 --> 00:03:54,870
Bob will not know that the message
has been changed from m to m pi.

60
00:03:54,870 --> 00:03:59,420
This is a simple example to show that
the weak collision of system property

61
00:03:59,420 --> 00:04:04,225
is essential to protect message
authenticity and integrity.

62
00:04:04,225 --> 00:04:07,590
There's a stronger version of
the collision resistant property.

63
00:04:07,590 --> 00:04:12,330
It says that it should be
computationally infeasible to find

64
00:04:12,330 --> 00:04:18,420
different messages, m1 and m2, such that
they have exactly the same hash value.

65
00:04:18,420 --> 00:04:22,230
This is a stronger property
because it prevents the attacker

66
00:04:22,230 --> 00:04:26,530
from coming up with two different
messages, that have the same hash value.

67
00:04:26,530 --> 00:04:29,370
Again, this property is essential for

68
00:04:29,370 --> 00:04:32,960
protecting message authenticity and
integrity.

69
00:04:32,960 --> 00:04:39,930
For example, suppose Bob can write a IOU
message, and send it to Alice to sign.

70
00:04:39,930 --> 00:04:44,370
Again, the way that Alice will sign it
is to hash the message first, and then,

71
00:04:44,370 --> 00:04:47,090
sign the hash, using a private key.

72
00:04:47,090 --> 00:04:51,170
If Bob can find two different messages,
that have the same hash value,

73
00:04:51,170 --> 00:04:54,890
one of which requires Alice
to pay a small amount, and

74
00:04:54,890 --> 00:04:58,160
the other requires her to
pay a very large amount.

75
00:04:58,160 --> 00:05:01,660
And the two different messages
have exactly the same hash.

76
00:05:01,660 --> 00:05:06,960
Suppose Bob sends the message with
a small amount for Alice to sign.

77
00:05:06,960 --> 00:05:12,270
After Bob receives Alice's signature
on the message with the small amount,

78
00:05:12,270 --> 00:05:17,790
Bob can then go around and claim
that Alice owes her a larger amount,

79
00:05:17,790 --> 00:05:21,490
because the two different messages,
have the same hash.

80
00:05:21,490 --> 00:05:23,870
And the signatures
would then be the same.

81
00:05:23,870 --> 00:05:26,980
It should be obvious
that if a hash function

82
00:05:26,980 --> 00:05:30,110
satisfies the strong
collision resistant property,

83
00:05:30,110 --> 00:05:34,380
it automatically satisfies the weak
collision system property.
