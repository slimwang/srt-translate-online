1
00:00:00,650 --> 00:00:06,700
In cycle 5, two things will happen. One, this instruction will write its result.

2
00:00:06,700 --> 00:00:09,720
And two, I'll try to issue the next instruction if I can.

3
00:00:09,720 --> 00:00:14,190
We can do that in either or. Let's say that we do the issuing first this time.

4
00:00:14,190 --> 00:00:21,065
This is a subtract in ROB5, writing to R4. R1 and R5 are ROB4 and

5
00:00:21,065 --> 00:00:26,150
3. So I write the value of 3 here, and ROB4 here. And then,

6
00:00:26,150 --> 00:00:31,520
what I do is I mark that Register 4 is from now on going to be pointing to ROB5,

7
00:00:31,520 --> 00:00:34,710
because that's where I put this instruction. I have issued this instruction in

8
00:00:34,710 --> 00:00:38,710
cycle 5. And with that, I have completed the issue of this instruction, but

9
00:00:38,710 --> 00:00:42,560
it is not ready to execute because it still has one of its operands,

10
00:00:42,560 --> 00:00:46,470
is not available and we need to wait for it. Another thing again that happens in

11
00:00:46,470 --> 00:00:49,550
cycle 5 is that we need to take care of the writing of the result for

12
00:00:49,550 --> 00:00:55,185
the ROB3 instruction. So what happens is, this instruction writes the result of

13
00:00:55,185 --> 00:01:00,850
3, with a tab of ROB3. Now this 3 is really written here and

14
00:01:00,850 --> 00:01:05,440
the instruction is marked as done. Also, the value of 3 is broadcast under

15
00:01:05,440 --> 00:01:10,009
the name of ROB3, so that the reservation stations can try to capture it. So

16
00:01:10,009 --> 00:01:13,632
what's going to happen is there is a match here. This one is waiting for ROB 3.

17
00:01:13,632 --> 00:01:19,480
It's going to capture a value of 3 and no longer wait for ROB 3. So this

18
00:01:19,480 --> 00:01:23,310
is what happens in cycle 5, as far as broadcasting of this result is concerned.

19
00:01:23,310 --> 00:01:28,550
Note that the RAT and everything is not updated yet. That will happen at commit.

20
00:01:28,550 --> 00:01:31,330
So now, in cycle 5, we have finished our issuing here,

21
00:01:31,330 --> 00:01:34,680
we have broadcast our result, we are ready to move on to cycle 6.

22
00:01:34,680 --> 00:01:38,730
Neither of these instructions is ready to actually dispatch in cycle 5, so

23
00:01:38,730 --> 00:01:42,370
nothing will begin executing in cycle 6 because both of them still wait for

24
00:01:42,370 --> 00:01:47,770
something else. So in cycle 6, what happens is, as far as issuing is concerned,

25
00:01:47,770 --> 00:01:51,650
we're going to try to issue this instruction. As far as execution is concerned,

26
00:01:51,650 --> 00:01:54,690
these two cannot still execute because they're still waiting for

27
00:01:54,690 --> 00:01:57,488
something. As far as writing of results is concerned,

28
00:01:57,488 --> 00:02:03,150
the instruction 3 has finished writing the result and has been marked as done.

29
00:02:03,150 --> 00:02:06,540
These two still have a while to go before they're going to write their results.

30
00:02:06,540 --> 00:02:09,758
Because we're in cycle 6, the next thing here is going to happen in cycle 13.

31
00:02:09,758 --> 00:02:13,280
So in cycle 6, pretty much the only thing that happens is

32
00:02:13,280 --> 00:02:18,150
these two instructions continue to execute and we try to issue an instruction.

33
00:02:18,150 --> 00:02:23,210
We're going to issue this one by grabbing a reservation station and a ROB entry.

34
00:02:23,210 --> 00:02:28,540
We're going to be writing to R1. We are now named ROB6. R4 and

35
00:02:28,540 --> 00:02:33,450
R2 are coming from ROB5 and ROB1, so neither of those is available yet.

36
00:02:34,790 --> 00:02:38,510
And then, we're going to mark that R1 from now on is pointing to ROB6.

37
00:02:38,510 --> 00:02:41,990
So with this we have issued this instruction.

38
00:02:41,990 --> 00:02:46,500
Now, we have written the result of this instruction, so technically this

39
00:02:46,500 --> 00:02:51,580
instruction by itself could commit in cycle 6. However, remember that

40
00:02:51,580 --> 00:02:55,097
an instruction cannot commit until all previous instructions have committed. So

41
00:02:55,097 --> 00:02:58,785
all of this instruction would commit in 6 if everything else was committed

42
00:02:58,785 --> 00:03:03,770
already. It will actually not commit until at least cycle 43 or 4 or 5. So

43
00:03:03,770 --> 00:03:09,450
pretty much, this instruction sits here as done. Others can use its result but

44
00:03:09,450 --> 00:03:13,370
it cannot really commit until we commit the instructions 1 and 2. So in cycle 6,

45
00:03:13,370 --> 00:03:18,940
this is all that happens. There is no commit here. And now we move to cycles 7,

46
00:03:18,940 --> 00:03:24,200
in which case, we have nothing to issue anymore, so issuing will not be an issue

47
00:03:24,200 --> 00:03:28,390
anymore. We cannot execute anything until we see some results being broadcast.

48
00:03:28,390 --> 00:03:32,880
So, really, the next cycle when something interesting will happen, is cycle 13,

49
00:03:32,880 --> 00:03:35,700
in which, we will have another write of our results.

50
00:03:35,700 --> 00:03:38,090
So let's just kind of fast forward through to that.
