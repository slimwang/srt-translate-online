1
00:00:00,000 --> 00:00:03,000
[Sarah] This question comes from Crazy Puff.

2
00:00:03,000 --> 00:00:09,000
"Can you give some examples of how BackusÃ¢ÂÂNaur Form is used in practice?

3
00:00:09,000 --> 00:00:12,000
For example, being a formal way to describe a language,

4
00:00:12,000 --> 00:00:19,000
it seems that BNF might find some use in creating compilers or interpreters

5
00:00:19,000 --> 00:00:24,000
or other tasks involving teaching a computer to understand text.

6
00:00:24,000 --> 00:00:29,000
Also, BNF lets you go from the abstract form to the concrete form,

7
00:00:29,000 --> 00:00:34,000
but it seems like in practice you'd more often want to go in the opposite direction.

8
00:00:34,000 --> 00:00:39,000
For example, given a concrete example of a Python statement,

9
00:00:39,000 --> 00:00:45,000
you'd want to know how the interpreter parses it. So, Dave, how would you do this?"

10
00:00:45,000 --> 00:00:48,000
[Dave] Thanks for the question, Tracy. That's a great question.

11
00:00:48,000 --> 00:00:51,000
We're using BNF in this class to understand languages

12
00:00:51,000 --> 00:00:56,000
to see how we can construct the expressions in Python.

13
00:00:56,000 --> 00:01:02,000
But grammars are also used by the interpreter to break the strings that we put in into their parts.

14
00:01:02,000 --> 00:01:05,000
When you write a Python program and you run that in the interpreter,

15
00:01:05,000 --> 00:01:07,000
the interpreter has to figure out what the things are.

16
00:01:07,000 --> 00:01:09,000
It has to figure out is this an assignment expression?

17
00:01:09,000 --> 00:01:11,000
Is it a variable?

18
00:01:11,000 --> 00:01:13,000
Are these parts of a number? Is it a string?

19
00:01:13,000 --> 00:01:17,000
All the things that we've seen in unit 1 and in later units are constructs in Python,

20
00:01:17,000 --> 00:01:22,000
and we need the grammar that's built into the interpreter to break that string into its parts.

21
00:01:22,000 --> 00:01:25,000
That is part of what's implemented, and when people implement interpreters

22
00:01:25,000 --> 00:01:29,000
or compilers, they usually do it by starting by writing a grammar.

23
00:01:29,000 --> 00:01:33,000
Then there's a tool that takes that grammar and turns it into a program

24
00:01:33,000 --> 00:01:36,000
that will break the string down into its pieces.

25
00:01:36,000 --> 00:01:41,000
If you take the follow-on course to this--if you take CS262 programming languages course--

26
00:01:41,000 --> 00:01:44,000
that talks a lot more about how interpreters actually do that.

27
00:01:44,000 --> 00:01:46,000
There are lots of other uses of grammars

28
00:01:46,000 --> 00:01:49,000
besides just breaking down programming languages into pieces.

29
00:01:49,000 --> 00:01:54,000
Some are in the generative sense where you start from the grammar and produce strings.

30
00:01:54,000 --> 00:01:57,000
An interesting example of that is guessing passwords.

31
00:01:57,000 --> 00:02:01,000
There was a group at Florida State that looked at how to create passwords.

32
00:02:01,000 --> 00:02:04,000
First you learn a grammar from a set of passwords you might have.

33
00:02:04,000 --> 00:02:08,000
Then you can create more passwords, and you can use this as a way of guessing passwords

34
00:02:08,000 --> 00:02:12,000
or if you want to measure how strong a password is to estimate how hard it would be

35
00:02:12,000 --> 00:02:14,000
to produce that password from this grammar.

36
00:02:14,000 --> 00:02:17,000
There are lots of interesting uses of grammars to produce strings.

37
00:02:17,000 --> 00:02:21,000
The more common use in programming languages is where we use the grammar

38
00:02:21,000 --> 00:02:24,000
to break an input which is all one long string of text,

39
00:02:24,000 --> 00:02:28,000
that's your Python program, to turn that into the components of that program using a grammar.
