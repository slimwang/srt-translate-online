1
00:00:00,000 --> 00:00:02,000
Back to coverage metrics.

2
00:00:02,000 --> 00:00:05,000
We just talked about statement coverage, which is closely related to line coverage,

3
00:00:05,000 --> 00:00:07,000
but it's a bit more fine-grained,

4
00:00:07,000 --> 00:00:11,000
and now let's talk about what is probably the only other test coverage metric

5
00:00:11,000 --> 00:00:14,000
that will matter in your day-to-day life unless you go build avionics software.

6
00:00:14,000 --> 00:00:21,000
Branch coverage is a metric where a branch in a code is covered, if it executes both ways.

7
00:00:21,000 --> 00:00:26,000
For example, to get 100% branch coverage for the statement that tests whether x = 0,

8
00:00:26,000 --> 00:00:28,000
it would be needed to be executed in a state where x was zero

9
00:00:28,000 --> 00:00:31,000
and also in a state where x was not equal to zero.

10
00:00:31,000 --> 00:00:35,000
And so, in many cases, branch coverage and statement coverage have the same effect.

11
00:00:35,000 --> 00:00:39,000
For example, if our code only contained if-then-else loops,

12
00:00:39,000 --> 00:00:41,000
the metrics would be equivalent.

13
00:00:41,000 --> 00:00:45,000
On the other hand for code like this that's missing the else branches they're not quite equivalent.

14
00:00:45,000 --> 00:00:52,000
We can take as inputs to this code x =0 and y is -1.

15
00:00:52,000 --> 00:00:55,000
These inputs were sufficient to get 100% statement coverage.

16
00:00:55,000 --> 00:00:59,000
On the other hand, these are not sufficient to get 100% branch coverage.

17
00:00:59,000 --> 00:01:05,000
What happens is these cause the taken branch of the if to be executed but not the else branch.

18
00:01:05,000 --> 00:01:10,000
Then the taken branch of the second if to be executed, but not the else branch.

19
00:01:10,000 --> 00:01:13,000
There are different ways to score branch coverage, but one way we can do it

20
00:01:13,000 --> 00:01:16,000
is there are two ways to take this branch, two ways to take this branch,

21
00:01:16,000 --> 00:01:18,000
so we could say this is 50% branch coverage.

22
00:01:18,000 --> 00:01:23,000
The other thing we could do, however, it do what our Python module for coverage is going to do,

23
00:01:23,000 --> 00:01:26,000
we could say that both of these branches were partially executed.

24
00:01:26,000 --> 00:01:30,000
That is to say, one of their possibilities was realized during testing.

25
00:01:30,000 --> 00:01:33,000
No branches were completely missed, and no branches were totally covered.

26
00:01:33,000 --> 00:01:37,000
So, let's go ahead and see how our coverage module tells us this.

27
00:01:37,000 --> 00:01:42,000
Right, so as you see here, I've typed into an editor window the same code that I wrote down

28
00:01:42,000 --> 00:01:44,000
by hand on the left part of the slide.

29
00:01:44,000 --> 00:01:48,000
And so we're going to invoke the function foo with x being 0 and y being -1.

30
00:01:48,000 --> 00:01:50,000
Let's see what happens.

31
00:01:50,000 --> 00:01:52,000
We're going run this under the coverage tool,

32
00:01:52,000 --> 00:01:57,000
but this time we're going to give the coverage run command, and argument--branch.

33
00:01:57,000 --> 00:02:01,000
That simply tells it to measure branch coverage instead of just measuring statement coverage.

34
00:02:01,000 --> 00:02:04,000
It's again going to render some HTML as a result,

35
00:02:04,000 --> 00:02:07,000
and if we look at the output, it's going to tell us that out of six statements

36
00:02:07,000 --> 00:02:10,000
all six of them were run, and there were zero missing statements.

37
00:02:10,000 --> 00:02:13,000
So, at the statement level, we've achieved 100% coverage.

38
00:02:13,000 --> 00:02:17,000
On the other hand, at the branch level, we had two branches that were partially executed--

39
00:02:17,000 --> 00:02:21,000
that is to say, only one of their two possibilities was realized during execution.

40
00:02:21,000 --> 00:02:26,000
Now, if we change this a little bit by calling foo a second time with 0 and -2,

41
00:02:26,000 --> 00:02:31,000
run the coverage tool again, what we'll see is that the second branch,

42
00:02:31,000 --> 00:02:33,000
the test of y now is executed both ways.

43
00:02:33,000 --> 99:59:59,999
On the other hand, the first branch, the one that tests x still is partially executed.
