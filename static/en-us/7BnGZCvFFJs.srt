1
00:00:00,770 --> 00:00:02,905
To do this, I first want to look at the structure of credit card and see what

2
00:00:02,905 --> 00:00:06,932
I'm given already. I'm implementing a method, is valid, which returns a

3
00:00:06,932 --> 00:00:12,565
Boolean. Is valid calculates whether the credit card has a valid number. And

4
00:00:12,565 --> 00:00:16,695
returns true if the number's valid and false if it's not. So now I know how to

5
00:00:16,695 --> 00:00:21,608
write my test program. I need to create two credit cards. I'll create a valid

6
00:00:21,608 --> 00:00:27,947
card. And I have to mark that this is a long, by writing the L at the end. And

7
00:00:27,947 --> 00:00:32,228
I switched two digits to get the invalid card. Now I print out the actual value

8
00:00:32,228 --> 00:00:35,708
of isValid when called on the valid card, and I expect the valid card to be

9
00:00:35,708 --> 00:00:41,241
valid. The actual for the invalid card should be false. Now, it would be easy

10
00:00:41,241 --> 00:00:45,858
to test whether our implementation works. In the credit card class we can see

11
00:00:45,858 --> 00:00:49,579
that the first part of the pseudocode setting sum to 0 and count to 0, is the

12
00:00:49,579 --> 00:00:55,470
same as the code that had before for computing the sum of digits. So I'll keep

13
00:00:55,470 --> 00:01:00,680
that the same. The for each digit starting from the right part is the same. So

14
00:01:00,680 --> 00:01:04,218
I'll try to keep the code for counting the iterations in place. But now,

15
00:01:04,218 --> 00:01:08,440
instead of just adding the digit to the sum, I need to check whether the count

16
00:01:08,440 --> 00:01:12,527
is even or odd and how big the digit is, and use that to decide what to do with

17
00:01:12,527 --> 00:01:21,430
the sum. So, if the count mod 2 is 1, we add the digit to the sum. Else, if the

18
00:01:21,430 --> 00:01:25,287
digit is less than 5. We add twice the digit to the sum. Otherwise, we add

19
00:01:25,287 --> 00:01:31,076
twice the digit to the sum and subtract nine. And now, instead of just printing

20
00:01:31,076 --> 00:01:35,324
the sum the way we did before, we need to check whether the card number is

21
00:01:35,324 --> 00:01:40,958
valid. If the last digit of the sum is zero, the card number is valid. Some mod

22
00:01:40,958 --> 00:01:45,386
10 equals equals 0 is true when the last digit of sum is 0, and false

23
00:01:45,386 --> 00:01:52,248
otherwise. So we return that. For example, if the sum were 24, we would check

24
00:01:52,248 --> 00:01:58,381
sum mod 10 would be 4 which is not 0. So, returning this result would return

25
00:01:58,381 --> 00:02:04,367
false. If sum were 20, then we would check sum mod 10 is 0. So this would be

26
00:02:04,367 --> 00:02:06,746
true, so we would return true, but we can't be sure that this works until we

27
00:02:06,746 --> 00:02:13,598
test it. Let's compile and run the tester, huh. One of our tests failed. It's

28
00:02:13,598 --> 00:02:17,303
saying that the invalid card is valid. We're going to need more information if

29
00:02:17,303 --> 00:02:21,235
we want to debug this. What if I print each digit of the number? So if we run

30
00:02:21,235 --> 00:02:28,526
the credit card tester. That's funny. It printed exactly the same thing. My

31
00:02:28,526 --> 00:02:32,332
print line statement must not have run. For this statement not to run, we would

32
00:02:32,332 --> 00:02:38,827
have to never go into the loop. What's n? If I run it again, I find that n is

33
00:02:38,827 --> 00:02:45,452
this weird negative number. That looks a little bit like the result of an

34
00:02:45,452 --> 00:02:51,763
integer overflow. Clearly, n can't be an int anymore. Now, if I try to compile.

35
00:02:51,763 --> 00:02:57,806
I get a possible loss of precision. So if I want an int digit, I'm going to

36
00:02:57,806 --> 00:03:02,849
have to cast this somehow. What if I try casting n mod 10 this way? Looks like

37
00:03:02,849 --> 00:03:07,837
I didn't remove the cast that was causing trouble. Now, it looks like it's

38
00:03:07,837 --> 00:03:13,245
starting with the correct n. And then taking off one digit at a time correctly.

39
00:03:13,245 --> 00:03:17,645
But it's still getting the wrong answer for the valid card. I'll delete this,

40
00:03:17,645 --> 00:03:21,956
now that I have that part working. And I think I actually want to print out the

41
00:03:21,956 --> 00:03:26,908
digit itself, rather than n. And then I want to get some idea of what I do with

42
00:03:26,908 --> 00:03:31,983
each digit. So I'll print the digit. And then, on the same line. I'll print,

43
00:03:31,983 --> 00:03:36,123
add it to the sum, add twice the digit to the sum, or add twice the digit and

44
00:03:36,123 --> 00:03:41,370
subtract 9. Now, if I run the tester again, I should get much better

45
00:03:41,370 --> 00:03:47,324
information. It looks like the first digit is minus 9, but none of the digits

46
00:03:47,324 --> 00:03:53,994
should be negative. It looks like this cast didn't work properly. Maybe it's

47
00:03:53,994 --> 00:03:59,240
casting n before it takes the mod 10, instead of casting the result of the n

48
00:03:59,240 --> 00:04:05,021
mod 10. Let's see if these parentheses fix it. Now, if I run the main method

49
00:04:05,021 --> 00:04:09,697
again, you can see I'm still not getting what I expected. But I have some good

50
00:04:09,697 --> 00:04:14,674
data here. For 3, I add twice the digit to the sum, 1, I add twice the digit to

51
00:04:14,674 --> 00:04:20,165
the sum. And so on. Let's compare that with the example on the web page. In the

52
00:04:20,165 --> 00:04:24,860
example, the three shouldn't get doubled. The one should though. The next one

53
00:04:24,860 --> 00:04:29,802
shouldn't. The 9 should. In fact, it looks like we're adding twice the digit,

54
00:04:29,802 --> 00:04:37,390
way too often here. It's seems like count mod 2, never equals 1. So let's check

55
00:04:37,390 --> 00:04:44,378
what count is. With System.out.println("count:" + count). Now the main method

56
00:04:44,378 --> 00:04:51,255
says count is always 0. I know how to fix that. I'll increment count. Now, for

57
00:04:51,255 --> 00:04:55,490
the validCard I'm getting true when I expected true. And for the invalid card,

58
00:04:55,490 --> 00:04:59,540
I'm getting false when I expected false. I have just a tiny bit of cleanup left

59
00:04:59,540 --> 00:05:03,508
to do. To remove all of these extra system out print lines, that I added. I

60
00:05:03,508 --> 00:05:09,090
removed all of the print statements, in the credit card class. And now when I

61
00:05:09,090 --> 00:05:11,709
run the test, the output is much cleaner.
