1
00:00:00,000 --> 00:00:08,000
Here is one possible design for coding up a solver for these types of problems.

2
00:00:08,000 --> 00:00:15,000
That design would be to write down all the rules of arithmetic

3
00:00:15,000 --> 00:00:20,000
in terms of carry digits, in terms of odd and even and so on.

4
00:00:20,000 --> 00:00:23,000
Now, that seems like a challenging task.

5
00:00:23,000 --> 00:00:30,000
There's a lot of complexity involved in understanding all the rules about arithmetic.

6
00:00:30,000 --> 00:00:34,000
Even if we figured out everything about addition, there's also subtraction

7
00:00:34,000 --> 00:00:37,000
and multiplication and other operators.

8
00:00:37,000 --> 00:00:44,000
So what we really want is a short cut that'll allow us to eliminate this complexity.

9
00:00:44,000 --> 00:00:47,000
Let's go back to the back of the envelope

10
00:00:47,000 --> 00:00:50,000
and see if we can figure out a shortcut.

11
00:00:50,000 --> 00:00:54,000
One possibility would be to try all possibilities.

12
00:00:54,000 --> 00:00:57,000
There are 10 digits.

13
00:00:57,000 --> 00:01:01,000
All combinations of digits--all permutations of the digits, rather--

14
00:01:01,000 --> 00:01:04,000
would be only 10 factorial,

15
00:01:04,000 --> 00:01:07,000
which I happen to know is about 3 million.

16
00:01:07,000 --> 00:01:09,000
That's not so many.

17
00:01:09,000 --> 00:01:13,000
It seems like it's feasible to try all the possibilities.

18
00:01:13,000 --> 00:01:15,000
It's not going to be super quick.

19
00:01:15,000 --> 00:01:18,000
We would rather have this be thousands rather than millions

20
00:01:18,000 --> 00:01:24,000
because there seems to be a fair amount of work in substituting in all the letters with digits.

21
00:01:24,000 --> 00:01:28,000
But we can expect to be able to try all millions,

22
00:01:28,000 --> 00:01:32,000
not within a second, but within about a minute or so.

23
00:01:32,000 --> 00:01:40,000
Now we have an approved design, which is we represent our formula as a string,

24
00:01:40,000 --> 00:01:46,000
and we'll use official Python notation here with the double equal sign.

25
00:01:46,000 --> 00:01:57,000
Then we fill in with all permutations of the 10 digits for each of the letter,

26
00:01:57,000 --> 00:02:01,000
and if there's fewer letters, we have to account for that.

27
00:02:01,000 --> 00:02:09,000
For example, we might substitute a 1 for the Os,

28
00:02:09,000 --> 00:02:22,000
and a 2 for the Ds, and a 3 for the Es, and a 4 for the Vs, and a 5 for the Ns.

29
00:02:22,000 --> 00:02:26,000
Otherwise just copy the equation.

30
00:02:26,000 --> 00:02:33,000
Then evaluate that and check if that's equal to True.

31
00:02:33,000 --> 00:02:37,000
If it is, then we have a solution.

32
00:02:37,000 --> 00:02:41,000
If it's not, we'll go back and we'll try another combination--

33
00:02:41,000 --> 00:02:46,000
maybe 1, 3, 3, and so on.

34
00:02:46,000 --> 00:02:50,000
We'll keep on going through until we find some permutation that works.

35
00:02:50,000 --> 00:02:52,000
That's the design.

36
00:02:52,000 --> 00:02:56,000
Now, let's take an inventory of all the concepts we're going to need.

37
00:02:56,000 --> 00:02:58,000
First we have equations.

38
00:02:58,000 --> 00:03:05,000
There's two types of those--the original and the filled-in.

39
00:03:05,000 --> 00:03:08,000
The original has letters. The filled in has digits.

40
00:03:08,000 --> 00:03:14,000
Letters and digits are concepts we have to deal with.

41
00:03:14,000 --> 00:03:24,000
The assignment of a letter to a digit or set of those is also a concept we have to deal with.

42
00:03:24,000 --> 00:03:27,000
I think that's pretty much it.

43
00:03:27,000 --> 00:03:33,000
Maybe one more concept is evaluation or validation

44
00:03:33,000 --> 00:03:38,000
that the filled in equation is an accurate one.

45
00:03:38,000 --> 00:03:43,000
Now let's come up with some choices to represent each of these concepts.

46
00:03:43,000 --> 00:03:48,000
The original equation can be a string.

47
00:03:48,000 --> 00:03:51,000
The filled-in equation can also be a string.

48
00:03:51,000 --> 00:03:58,000
The letters will be single character strings like D.

49
00:03:58,000 --> 00:04:02,000
The digits will also be single character strings--like 3.

50
00:04:02,000 --> 00:04:09,000
The assignment of letters to digits will be some sort of mapping or a table

51
00:04:09,000 --> 00:04:20,000
that consists of this type of mapping that says D would be replaced by 3 and so on.

52
00:04:20,000 --> 00:04:26,000
It turns out that there is a facility built into Python that's part of strings

53
00:04:26,000 --> 00:04:29,000
called the translate function.

54
00:04:29,000 --> 00:04:39,000
We can call the str.translate method in order to enact that type of assignment or substitution.

55
00:04:39,000 --> 00:04:45,000
Then for the evaluation, there is a function called "eval" in Python,

56
00:04:45,000 --> 00:04:48,000
which takes a string and evaluates it as an expression.

57
00:04:48,000 --> 00:04:53,000
You may not be that familiar with these last two items, so let's go over them.

58
00:04:53,000 --> 00:04:56,000
Eval is pretty simple.

59
00:04:56,000 --> 00:05:07,000
If we asked for eval of the string "2 + 2," then that would give us a value 4.

60
00:05:07,000 --> 00:05:21,000
If we asked for eval of the string "2 + 2 == 3," Python would evaluate that

61
00:05:21,000 --> 99:59:59,999
using it's normal rules and tell us that that's equal to False.
