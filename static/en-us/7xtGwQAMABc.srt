1
00:00:00,170 --> 00:00:04,080
So let's down define what does it
mean for caches to be coherent.

2
00:00:04,080 --> 00:00:08,310
Intuitively, they're coherent when the
whole thing behaves like there was no

3
00:00:08,310 --> 00:00:09,220
caches.

4
00:00:09,220 --> 00:00:12,620
But let's define more precisely
what exactly does it mean.

5
00:00:12,620 --> 00:00:15,780
There are three requirements for
coherence.

6
00:00:15,780 --> 00:00:20,170
The first one says that the read,

7
00:00:20,170 --> 00:00:25,910
let's call that read R,
from some address X on some core C1 will

8
00:00:25,910 --> 00:00:31,430
return the value written by the most
recent write, let's call that write W,

9
00:00:31,430 --> 00:00:37,320
to the same location, and
that write was on the same core C1,

10
00:00:37,320 --> 00:00:43,470
if no other core has written to that
location between the accesses w and r.

11
00:00:43,470 --> 00:00:47,560
So this first part of
the coherence definition

12
00:00:47,560 --> 00:00:53,180
really says that if one core is
operating on a location alone,

13
00:00:53,180 --> 00:00:57,450
then its reads should be getting the
most recent writes from the same core.

14
00:00:57,450 --> 00:01:02,820
This basically says that a coherent
behavior includes correct

15
00:01:02,820 --> 00:01:07,610
unit processor behavior as long as the
location is accessed by only one core.

16
00:01:08,700 --> 00:01:13,680
The second part of the definition
says that, if core C1 writes

17
00:01:13,680 --> 00:01:19,180
to our location X, and
C2 reads X after a sufficient time,

18
00:01:19,180 --> 00:01:23,450
and if there are no other writes that
happen in between C1's write and

19
00:01:23,450 --> 00:01:29,750
C2's read, then C2's read must
return the value C1 wrote.

20
00:01:29,750 --> 00:01:31,980
So pretty much, if there is a write and

21
00:01:31,980 --> 00:01:36,930
the read happens sufficiently after that
write, then the read has to read what

22
00:01:36,930 --> 00:01:40,300
the write wrote, except if there
was another write in between,

23
00:01:40,300 --> 00:01:44,400
in which case the read is allowed to
return that value instead of this one.

24
00:01:44,400 --> 00:01:49,420
So this part of the definition
really prevents the case when,

25
00:01:49,420 --> 00:01:53,480
for example,
C1 writes something to its own cache,

26
00:01:53,480 --> 00:01:56,350
C2 reads forever from
its cache a stale value.

27
00:01:57,350 --> 00:02:01,030
To be coherent, if C1 writes,

28
00:02:01,030 --> 00:02:06,400
then after some sufficient time,
C2 must start reading the new value,

29
00:02:06,400 --> 00:02:10,639
even if maybe a normal cache with no
coherent support would just keep reading

30
00:02:10,639 --> 00:02:13,500
the stale value because
it never gets replaced.

31
00:02:13,500 --> 00:02:19,150
So we have to do something in order to
make this part of the finishing work for

32
00:02:19,150 --> 00:02:22,950
private caches, that the caching
data in a coherent system.

33
00:02:22,950 --> 00:02:27,424
So we must do something to make
this caches behave this way.

34
00:02:27,424 --> 00:02:31,900
And finally, the third part of the
definition says that if there is more

35
00:02:31,900 --> 00:02:37,320
then one write to the same location,
then these writes must be serialized.

36
00:02:37,320 --> 00:02:41,900
That is any two writes
to the same location

37
00:02:41,900 --> 00:02:47,330
must be seen to occur in
the same order on all the cores.

38
00:02:47,330 --> 00:02:52,010
What this part of the definition really
says different cores should not be able

39
00:02:52,010 --> 00:02:56,590
to disagree about which write occurred
first and which occurred second.

40
00:02:56,590 --> 00:03:01,490
Note that second part of the definition
doesn't really require this to happen.

41
00:03:02,500 --> 00:03:06,480
Let's say there was one write on C1 and
another write on C3.

42
00:03:06,480 --> 00:03:12,100
When C2 reads, it's allowed to return
after a sufficient time either C1's or

43
00:03:12,100 --> 00:03:17,330
C3's value, because it's
allowed to interpret this order

44
00:03:17,330 --> 00:03:21,600
as either C1 and then C3 wrote,
or the other way around.

45
00:03:21,600 --> 00:03:26,810
What this part of the definition says
is that whatever C2 sees, if C2,

46
00:03:27,970 --> 00:03:32,730
for example, sees that final
value is that from C1 and

47
00:03:32,730 --> 00:03:35,710
not from C3, then all the other cores,

48
00:03:35,710 --> 00:03:40,180
when they're in their location after C2,
need to also see that order.

49
00:03:40,180 --> 00:03:44,610
So, it cannot happen that
C2 thinks C1 wrote last.

50
00:03:44,610 --> 00:03:50,980
Some other core, sometime later,
reads and still sees C3's value.

51
00:03:50,980 --> 00:03:53,760
So, what this is really
saying is that everybody,

52
00:03:53,760 --> 00:03:57,960
including the writing cores,
will see the value that

53
00:03:57,960 --> 00:04:02,930
is consistent with there being some
particular order to the writes.

54
00:04:02,930 --> 00:04:05,330
It doesn't require any particular order.

55
00:04:05,330 --> 00:04:08,700
For example, the writes can happen
almost simultaneously, in which case,

56
00:04:08,700 --> 00:04:12,480
we are free to choose which happened
first and which happened second.

57
00:04:12,480 --> 00:04:16,490
But we cannot allow some
cores to think that

58
00:04:16,490 --> 00:04:21,209
one write was first and other cores
think that another write was first.
