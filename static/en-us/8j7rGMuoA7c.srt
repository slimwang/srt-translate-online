1
00:00:00,260 --> 00:00:04,310
As I already hinted, memory management
isn't currently done by the operating

2
00:00:04,310 --> 00:00:09,290
system alone, in order to make these
tasks efficient, over the last

3
00:00:09,290 --> 00:00:13,860
decades the hardware has evolved to
integrate a number of mechanisms

4
00:00:13,860 --> 00:00:18,040
that make it easier, faster, or
more reliable to perform allocation and

5
00:00:18,040 --> 00:00:21,040
arbitration tasks regarding
the memory management.

6
00:00:21,040 --> 00:00:25,580
First every CPU package is equipped
with a memory management unit.

7
00:00:25,580 --> 00:00:29,370
This CPU is used virtual address
as to the memory management unit.

8
00:00:29,370 --> 00:00:30,760
And it's responsible for

9
00:00:30,760 --> 00:00:33,950
translating them into
the appropriate physical address.

10
00:00:33,950 --> 00:00:36,830
Or potentially the MMU
can generate a fault.

11
00:00:36,830 --> 00:00:38,590
The faults are an exception or

12
00:00:38,590 --> 00:00:43,460
signal that's generated by the MMU that
can indicate one of several things.

13
00:00:43,460 --> 00:00:46,590
For instance,
it can say that the access is illegal.

14
00:00:46,590 --> 00:00:47,520
Like, for instance,

15
00:00:47,520 --> 00:00:52,070
that the memory address that's
requested hasn't been allocated at all.

16
00:00:52,070 --> 00:00:55,490
Or it can indicate that they're
inadequate permissions to perform

17
00:00:55,490 --> 00:00:57,040
a particular access.

18
00:00:57,040 --> 00:01:01,400
For instance, the memory reference
may be part of a store instruction,

19
00:01:01,400 --> 00:01:06,020
so the process is trying to override
a particular memory allocation.

20
00:01:06,020 --> 00:01:09,990
However, it doesn't have a write
permission for that particular access.

21
00:01:09,990 --> 00:01:12,840
That page is what we
call write protected.

22
00:01:12,840 --> 00:01:16,580
Or another type of fault may be
an indication that the particular

23
00:01:16,580 --> 00:01:20,250
page that's being referenced,
isn't present in memory, and

24
00:01:20,250 --> 00:01:22,120
must be fetched from disk.

25
00:01:22,120 --> 00:01:26,560
Another way hardware supports memory
management is by using designated

26
00:01:26,560 --> 00:01:29,810
registers during the address
translation process.

27
00:01:29,810 --> 00:01:34,050
For instance in a page based system,
there are registers that are used to

28
00:01:34,050 --> 00:01:38,370
point to the currently active
page table, or in a segment based

29
00:01:38,370 --> 00:01:42,410
memory management the registers that
are used to indicate the base address of

30
00:01:42,410 --> 00:01:47,280
the segment potentially it's limit,
so its overall size of the segment,

31
00:01:47,280 --> 00:01:50,990
maybe the total number of segments and
similar information.

32
00:01:50,990 --> 00:01:54,980
Since the memory address translation
happens on pretty much every memory

33
00:01:54,980 --> 00:01:59,280
reference, most memory
management units would integrate

34
00:01:59,280 --> 00:02:04,060
a small cache of valid virtual to
physical address translations.

35
00:02:04,060 --> 00:02:07,840
This is called
the Translation Lookaside Buffer or TLB.

36
00:02:07,840 --> 00:02:11,795
The presence of a TLB will make the
entire translation process much faster.

37
00:02:11,795 --> 00:02:16,290
Since, if this translation is
present in this cache then,

38
00:02:16,290 --> 00:02:20,130
there's no need to perform
any additional operations to

39
00:02:20,130 --> 00:02:25,290
access the page table or the segment and
to interpret the validity of the access.

40
00:02:25,290 --> 00:02:25,880
And finally,

41
00:02:25,880 --> 00:02:29,910
the actual generation of the physical
address from the virtual address.

42
00:02:29,910 --> 00:02:33,670
So the translation process,
that's done by the hardware.

43
00:02:33,670 --> 00:02:36,910
The operating system will
maintain certain data structures,

44
00:02:36,910 --> 00:02:41,710
such as the page tables, to maintain
certain information that's necessary for

45
00:02:41,710 --> 00:02:43,220
the translation process.

46
00:02:43,220 --> 00:02:47,680
However, the actual translation,
the hardware performs it.

47
00:02:47,680 --> 00:02:51,460
This also implies that the hardware
will dictate what type of

48
00:02:51,460 --> 00:02:53,390
memory management modes are supported.

49
00:02:53,390 --> 00:02:54,930
Can you support paging?

50
00:02:54,930 --> 00:02:57,220
Can you support segmentation, or both?

51
00:02:57,220 --> 00:03:00,590
So basically, are there any
kinds of registers of this sort?

52
00:03:00,590 --> 00:03:04,690
It will also potentially imply
what kinds of pages can there be?

53
00:03:04,690 --> 00:03:08,725
What is the virtual address format,
as well as the physical address format?

54
00:03:08,725 --> 00:03:11,710
Since the hardware needs to
understand both of these.

55
00:03:11,710 --> 00:03:15,280
There are other aspects of memory
management that are more flexible in

56
00:03:15,280 --> 00:03:18,300
terms of their design since
they're performed in software.

57
00:03:18,300 --> 00:03:20,430
For instance, the actual allocation.

58
00:03:20,430 --> 00:03:24,580
Basically determining which portions of
the main memory will be used by which

59
00:03:24,580 --> 00:03:25,430
process.

60
00:03:25,430 --> 00:03:29,850
That's done by software or
the replacement policies that determine

61
00:03:29,850 --> 00:03:33,480
which portions of state will be
in main memory versus on disk.

62
00:03:33,480 --> 00:03:38,370
So we will focus our discussion on those
software aspects of memory management,

63
00:03:38,370 --> 00:03:41,530
since that's more relevant from
an operating systems course perspective.
