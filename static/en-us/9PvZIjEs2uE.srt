1
00:00:00,250 --> 00:00:02,750
So having given you the high level description

2
00:00:02,750 --> 00:00:05,550
of what ANTS toolkit does, let's dig a little

3
00:00:05,550 --> 00:00:09,210
deeper and look at the structure of the

4
00:00:09,210 --> 00:00:12,840
ANTS capsule as well as the APIs provided by

5
00:00:12,840 --> 00:00:16,460
ANTS in order to do capsule processing. First

6
00:00:16,460 --> 00:00:18,550
of all, the header as I told you consists

7
00:00:18,550 --> 00:00:22,060
of three parts. The original IP header, which

8
00:00:22,060 --> 00:00:25,590
is important for routing the package towards the destination

9
00:00:25,590 --> 00:00:28,850
if a node is a normal node, not an active node.

10
00:00:28,850 --> 00:00:31,110
And this is of course the payload that was generated by

11
00:00:31,110 --> 00:00:34,740
the application. And in the middle is this ANTS header, and

12
00:00:34,740 --> 00:00:37,160
there are two fields in this ANTS header that are particularly

13
00:00:37,160 --> 00:00:39,660
important. One is a type field, the other is a prev

14
00:00:39,660 --> 00:00:42,890
field. The type field is a way by which you can

15
00:00:42,890 --> 00:00:47,060
identify the code that has to be executed to process this

16
00:00:47,060 --> 00:00:50,660
capsule. And this type field is really an MD5 hash of the

17
00:00:50,660 --> 00:00:53,460
code that needs to be executed on this capsule,

18
00:00:53,460 --> 00:00:56,039
and we'll come back to that in a minute. And

19
00:00:56,039 --> 00:00:58,307
the second field that I said is important is

20
00:00:58,307 --> 00:01:01,732
the prev field. And this prev field is the identity

21
00:01:01,732 --> 00:01:06,256
of the upstream node that successfully processed the capsule

22
00:01:06,256 --> 00:01:09,450
of this type. And this information is going to be

23
00:01:09,450 --> 00:01:12,510
useful for us in terms of identifying the code that

24
00:01:12,510 --> 00:01:15,640
needs to be executed in order to process this capsule.

25
00:01:15,640 --> 00:01:18,870
We'll come back to how these two fields are

26
00:01:18,870 --> 00:01:22,990
actually used in processing a capsule once this capsule arrives

27
00:01:22,990 --> 00:01:25,956
at an active node. The short hint that I'll

28
00:01:25,956 --> 00:01:29,072
give you is that the capsule itself, as you see,

29
00:01:29,072 --> 00:01:31,656
does not contain the code that needs to be

30
00:01:31,656 --> 00:01:35,304
executed to process this capsule, but it only contains a

31
00:01:35,304 --> 00:01:38,091
type field. And this type field is a vehicle by

32
00:01:38,091 --> 00:01:40,713
which we can identify the code that needs to be

33
00:01:40,713 --> 00:01:43,486
executed to process this capsule. More on that

34
00:01:43,486 --> 00:01:46,360
in a minute. First, let's talk about the

35
00:01:46,360 --> 00:01:49,516
API that ANTS toolkit provides you. The most

36
00:01:49,516 --> 00:01:52,759
important function that we want to accomplish using the

37
00:01:52,759 --> 00:01:56,002
ANTS toolkit is forwarding packets through the network

38
00:01:56,002 --> 00:01:59,625
intelligently. So routing the capsule is the most important

39
00:01:59,625 --> 00:02:02,442
function that needs to be done. And that's

40
00:02:02,442 --> 00:02:05,860
most of what this ANTS API is all about.

41
00:02:05,860 --> 00:02:09,100
And that part is contained right here, saying that,

42
00:02:09,100 --> 00:02:12,570
well, route this packet in this manner, and deliver

43
00:02:12,570 --> 00:02:15,150
the packet to an application. And this is the

44
00:02:15,150 --> 00:02:17,460
set of API calls that allows you to do

45
00:02:17,460 --> 00:02:20,040
routing of the capsule through the network. This is

46
00:02:20,040 --> 00:02:22,470
where what I said about virtualizing the network comes

47
00:02:22,470 --> 00:02:26,870
in. Regardless of the actual topology, physical topology, I

48
00:02:26,870 --> 00:02:31,460
can take routing decisions commensurate with the network flow requirements

49
00:02:31,460 --> 00:02:34,000
contained in the capsule that arrives at a node.

50
00:02:34,000 --> 00:02:37,390
So the second part of the API is API

51
00:02:37,390 --> 00:02:40,840
for manipulating what is called a soft-store. Now, soft-store

52
00:02:40,840 --> 00:02:44,140
is storage that's available in every routing node for

53
00:02:44,140 --> 00:02:48,540
personalizing the network flow with respect to a particular

54
00:02:48,540 --> 00:02:51,330
type of capsule. And I mentioned earlier that the

55
00:02:51,330 --> 00:02:53,490
type is only a pointer to the code, not

56
00:02:53,490 --> 00:02:56,850
the code itself. And the soft-store is a place where

57
00:02:56,850 --> 00:03:00,190
we can store the code that corresponds to

58
00:03:00,190 --> 00:03:03,160
a particular capsule type. So the primitives that

59
00:03:03,160 --> 00:03:05,790
are available for manipulating the soft-store are things

60
00:03:05,790 --> 00:03:08,100
like put object and get object. The soft-store

61
00:03:08,100 --> 00:03:10,520
is basically key value store and in this

62
00:03:10,520 --> 00:03:14,370
key value store, you can store whatever is

63
00:03:14,370 --> 00:03:19,250
important for personalizing the network flow for capsules

64
00:03:19,250 --> 00:03:21,954
of this type. An obvious candidate for storing

65
00:03:21,954 --> 00:03:24,564
in the soft-store is the code that is associated with

66
00:03:24,564 --> 00:03:26,960
this type. So you can store the code that is

67
00:03:26,960 --> 00:03:30,430
associated with this type, so that future capsules of the

68
00:03:30,430 --> 00:03:33,190
same type, when it arrives at a particular node, they can

69
00:03:33,190 --> 00:03:37,230
retrieve the code from the soft-store and execute the code

70
00:03:37,230 --> 00:03:40,680
that needs to be executed for processing capsules of this type.

71
00:03:40,680 --> 00:03:44,096
Other interesting things that you might put into this soft-store

72
00:03:44,096 --> 00:03:47,329
are things like computed hints about the state of the network,

73
00:03:47,329 --> 00:03:50,562
which can be used for future capsule processing for capsules of

74
00:03:50,562 --> 00:03:54,110
the same type. And the third category of API that's available

75
00:03:54,110 --> 00:03:57,714
is querying the node for interesting tidbits about the state of

76
00:03:57,714 --> 00:04:01,590
the network or details about that node itself, for instance, what

77
00:04:01,590 --> 00:04:04,718
is the identity of the node that I'm currently at, and

78
00:04:04,718 --> 00:04:07,574
what the local time is at this node, at this node,

79
00:04:07,574 --> 00:04:09,763
and so on and so forth. So these are the kinds

80
00:04:09,763 --> 00:04:12,500
of things that are available. So the key thing that I want

81
00:04:12,500 --> 00:04:17,329
you to get out of looking at this ANTS API is that it is a very, very minimal

82
00:04:17,329 --> 00:04:24,420
setup API. So the number of API calls fits in this little table here. So that's

83
00:04:24,420 --> 00:04:27,640
the idea. Remember that routers are in the

84
00:04:27,640 --> 00:04:32,320
public Internet. And if you're talking about executing code

85
00:04:32,320 --> 00:04:34,520
in the router that is part of the public

86
00:04:34,520 --> 00:04:37,560
Internet, the router program that we're executing at a

87
00:04:37,560 --> 00:04:40,510
router node has to have certain important characteristics. Number

88
00:04:40,510 --> 00:04:44,000
one, it has to be easy to program. Number two,

89
00:04:44,000 --> 00:04:47,088
it should be easy to debug, maintain, and understand. And

90
00:04:47,088 --> 00:04:49,780
number three, it should be very quick, because we are

91
00:04:49,780 --> 00:04:52,980
talking about routing packets, and so the router program should

92
00:04:52,980 --> 00:04:56,010
not take a long time to do its router processing.

93
00:04:56,010 --> 00:04:59,300
So the API, this very simple API, allows you to

94
00:04:59,300 --> 00:05:03,040
generate very simple router programs that are easy to program

95
00:05:03,040 --> 00:05:05,740
because the APIs are simple, easy to debug,

96
00:05:05,740 --> 00:05:08,860
easy to maintain and understand. And the program itself

97
00:05:08,860 --> 00:05:11,680
is pretty small, that it's going to take not a

98
00:05:11,680 --> 00:05:13,880
humongous amount of time to do the packet processing.
