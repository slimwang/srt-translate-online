1
00:00:00,570 --> 00:00:03,120
So far we have focused mainly on reading data. But what

2
00:00:03,120 --> 00:00:06,302
happens when we want to write to memory? Here we'll consider

3
00:00:06,302 --> 00:00:09,072
a single core system. I'll refer you to an architecture class

4
00:00:09,072 --> 00:00:12,140
for a shared memory system where keeping a cache consistent becomes a

5
00:00:12,140 --> 00:00:16,650
challenge. We need to consider both what happens on a hit

6
00:00:16,650 --> 00:00:18,580
when the block we want to write to is already in

7
00:00:18,580 --> 00:00:21,470
the cache. And what happens on a miss, when it isn't.

8
00:00:22,610 --> 00:00:26,394
On a hit, the most obvious thing to do is to write-through

9
00:00:26,394 --> 00:00:29,290
to memory. That is, we'll write to the cache, and then

10
00:00:29,290 --> 00:00:31,930
also write to the main memory to copy the data, and

11
00:00:31,930 --> 00:00:35,140
keep the cache and main memory consistent. As long as I

12
00:00:35,140 --> 00:00:37,730
don't have to worry about some other entity needing an updated

13
00:00:37,730 --> 00:00:41,170
version from memory however, there's actually no need to write everything

14
00:00:41,170 --> 00:00:45,010
this instant. This is the insight behind the write-back policy which

15
00:00:45,010 --> 00:00:48,610
only writes to the cache. After all, that's where we'll look

16
00:00:48,610 --> 00:00:51,530
first if the same processor tries to read the data or

17
00:00:51,530 --> 00:00:54,300
write to it later. Only when the cache block gets

18
00:00:54,300 --> 00:00:57,110
evicted sometime later does the data really need to be

19
00:00:57,110 --> 00:00:59,640
written to main memory. And then it'll be the whole

20
00:00:59,640 --> 00:01:03,670
cache block. This lazy approach can be beneficial when the same

21
00:01:03,670 --> 00:01:07,870
cache block is written to many times before [INAUDIBLE]. For

22
00:01:07,870 --> 00:01:10,745
cache misses we also have two strategies. The first is

23
00:01:10,745 --> 00:01:13,930
write-allocate, which first reads the current value in memory into

24
00:01:13,930 --> 00:01:17,120
the cache. Then it behaves as though it were a hit,

25
00:01:17,120 --> 00:01:20,630
using either of the two hit strategies. Lastly we have

26
00:01:20,630 --> 00:01:23,830
the no-write allocate policy, where we just write the data

27
00:01:23,830 --> 00:01:26,300
to memory and don't bother with the cache at all.

28
00:01:26,300 --> 00:01:30,300
The interactions among these policies can be subtle, particularly when

29
00:01:30,300 --> 00:01:33,020
there are multiple cache levels. It is worth pointing out

30
00:01:33,020 --> 00:01:36,590
however, that some of these policies share certain assumptions, and

31
00:01:36,590 --> 00:01:40,270
are therefore often paired together. The write back policy is

32
00:01:40,270 --> 00:01:42,360
betting that there will be subsequent writes to the same

33
00:01:42,360 --> 00:01:45,050
cache block. That's why he is bundling up all the

34
00:01:45,050 --> 00:01:47,900
changes he is making for one trip to memory, when the

35
00:01:47,900 --> 00:01:51,660
block gets evicted. Write allocate is also betting on subsequent

36
00:01:51,660 --> 00:01:55,030
writes to the same block. That's why he loads the data

37
00:01:55,030 --> 00:01:58,530
up into the cache. On the other hand, write-through is

38
00:01:58,530 --> 00:02:02,590
betting on the cache block being evicted sooner rather than later.

39
00:02:02,590 --> 00:02:04,840
He does his writes to memory up front, so that

40
00:02:04,840 --> 00:02:07,530
he can quickly evict the cap block from the cache later

41
00:02:07,530 --> 00:02:09,620
if he has to, not having to worry about any

42
00:02:09,620 --> 00:02:13,790
writes to the disk. Similarly, the no-write allocate policy is

43
00:02:13,790 --> 00:02:16,360
also betting on that same cached block not being used

44
00:02:16,360 --> 00:02:19,820
again soon. It doesn't even bring the data into the cache.
