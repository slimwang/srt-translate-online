1
00:00:00,000 --> 00:00:05,000
Why are we bothering to write an interpreter for JavaScript that just runs Python in the end anyway?

2
00:00:05,000 --> 00:00:10,000
Shouldn't we just write our code in Python directly and skip the middle step?

3
00:00:10,000 --> 00:00:16,000
That's an interesting idea and one that I think gets to the heart of language design.

4
00:00:16,000 --> 00:00:19,000
Programming languages, as we know them, are actually

5
00:00:19,000 --> 00:00:22,000
relatively old in the history of computer science.

6
00:00:22,000 --> 00:00:27,000
John Bacchus starting with speed coding, perhaps the first interpreted language, in 1953

7
00:00:27,000 --> 00:00:32,000
and moved on to FORTRAN, which is still alive and going well, in around 1957.

8
00:00:32,000 --> 00:00:38,000
Around the same time Admiral Grace Hopper made the first compiler around 1952

9
00:00:38,000 --> 00:00:43,000
and started really promulgating languages like FLOW-MATIC in 1957.

10
00:00:43,000 --> 00:00:47,000
Let's imagine that we transplant this question back in time.

11
00:00:47,000 --> 00:00:51,000
You're in the '60s saying, "You know? If I write this program in FORTRAN,

12
00:00:51,000 --> 00:00:54,000
ultimately it gets interpreted in assembly language and machine code.

13
00:00:54,000 --> 00:00:59,000
Why should I bother with FORTRAN? Why not write it all in assembly language?"

14
00:00:59,000 --> 00:01:04,000
Or these days more modern languages like Java were initially implemented in

15
00:01:04,000 --> 00:01:09,000
languages like C. Why bother with Java, if we could write everything in C?

16
00:01:09,000 --> 00:01:13,000
It turns out that all of the modern programming languages that we are considering--

17
00:01:13,000 --> 00:01:16,000
Java, C++, C#, F# --

18
00:01:16,000 --> 00:01:21,000
are all Turing completed, a term I won't define in this class explicitly,

19
00:01:21,000 --> 00:01:27,000
but it deals with Turing and models of computations--they're all equally powerful.

20
00:01:27,000 --> 00:01:30,000
Anything I could do in one language, I could do in another.

21
00:01:30,000 --> 00:01:34,000
Now it's a matter of choice and expediency.

22
00:01:34,000 --> 00:01:38,000
Some languages make it easier to write somethings or say some thoughts than others,

23
00:01:38,000 --> 00:01:42,000
and some make it easier to do it with fewer errors,

24
00:01:42,000 --> 00:01:48,000
and that's where I think the key motivations for modern languages really come from.

25
00:01:48,000 --> 00:01:54,000
I think in the future, we're going to see an explosion, a proliferation, a profusion

26
00:01:54,000 --> 00:01:58,000
of domain-specific languages--languages that aren't trying to be C or Java

27
00:01:58,000 --> 00:02:03,000
but are trying to solve a very particular problem and do it quite well.

28
00:02:03,000 --> 00:02:07,000
There are already a number of languages out there for dealing with mathematics,

29
00:02:07,000 --> 00:02:10,000
things like MATLAB or Maple or Mathematica.

30
00:02:10,000 --> 00:02:13,000
There are a number of ones out there for describing graphics.

31
00:02:13,000 --> 00:02:17,000
Game design actually has a history of using a number of domain-specific languages

32
00:02:17,000 --> 00:02:20,000
going all the way back to QuakeC from John Carmack.

33
00:02:20,000 --> 00:02:23,000
Even more modern at the time of this writing,

34
00:02:23,000 --> 00:02:27,000
modern games like Skyrim feature their own languages for describing events and quests--

35
00:02:27,000 --> 00:02:32,000
Papyrus--check it out. Although they're based on relatively old programming language concepts.

36
00:02:32,000 --> 00:02:36,000
Another more modern example is there are a number of hardware definition languages--

37
00:02:36,000 --> 00:02:38,000
VHDL and Veralog.

38
00:02:38,000 --> 00:02:42,000
Whenever Intel to some degree decides to design a new chip,

39
00:02:42,000 --> 00:02:47,000
they use a hardware definition language rather than C or Java or Python to describe it.

40
00:02:47,000 --> 00:02:52,000
These domain-specific languages hold out the promise of having higher-level operations

41
00:02:52,000 --> 00:02:55,000
and of helping you catch common mistakes.

42
00:02:55,000 --> 00:03:00,000
That's really important in economic terms for saving money in software engineering.

43
00:03:00,000 --> 00:03:03,000
I want to make it take less time for you to write the program,

44
00:03:03,000 --> 00:03:07,000
and I want to reduce the number of faults that we're going to find in it later.

45
00:03:07,000 --> 00:03:11,000
I think one of the advantages of more modern languages over something like C

46
00:03:11,000 --> 00:03:14,000
is that they feature higher order datatypes.

47
00:03:14,000 --> 00:03:19,000
In Python if you want a list or a dictionary it's easy to write it with just a little bit of syntax.

48
00:03:19,000 --> 00:03:25,000
In C you'd need to have those datatypes prepared or do all of the allocation yourself.

49
00:03:25,000 --> 00:03:29,000
It just takes longer, and it's easier for errors to creep in.

50
00:03:29,000 --> 00:03:32,000
I think one of the things that's been driving changes in programming languages over time

51
00:03:32,000 --> 00:03:39,000
is that we're recognizing that correctness is often more important than speed

52
00:03:39,000 --> 00:03:44,000
for many applications. Speed is still critical, but bugs can be really expensive.

53
00:03:44,000 --> 00:03:47,000
Especially in the financial district or in mission-critical applications.

54
00:03:47,000 --> 00:03:51,000
If you're making an airplane autopilot or an artificial heart pump.

55
00:03:51,000 --> 00:03:57,000
Languages where one line of code creates a dictionary and initializes it with some value

56
00:03:57,000 --> 00:04:02,000
save you a lot of work. You don't have to write out all of the lines to create that dictionary.

57
00:04:02,000 --> 00:04:06,000
As a result, you don't have to write out any lines with bugs in them.

58
00:04:06,000 --> 00:04:11,000
The fewer lines you can write, the more you can just declare your will and have the compiler

59
00:04:11,000 --> 00:04:14,000
fill it in, the happier I am.

60
00:04:14,000 --> 00:04:18,000
I think that there is a real reason to keep designing new languages,

61
00:04:18,000 --> 00:04:21,000
even if we bootstrap them on top of the old ones,

62
00:04:21,000 --> 00:04:24,000
because it might be easier or more concise to think a thought in the new language

63
00:04:24,000 --> 00:04:30,000
or because the new language might help us reduce errors or software engineering defects.

64
00:04:30,000 --> 00:04:35,000
Even thought our simple JavaScript interpreter is ultimately written in Python,

65
00:04:35,000 --> 00:04:39,000
webpages typically include JavaScript rather than Python, it's handy.

66
00:04:39,000 --> 00:04:42,000
People find it easier to write in one of these languages rather than the other,

67
00:04:42,000 --> 00:04:46,000
even though they're all Turing complete and can express the same computations.

68
00:04:46,000 --> 00:04:51,000
It's kind of a deep question and one that gets to personal choice and creativity.

69
00:04:51,000 --> 99:59:59,999
Sometimes we just prefer one language over another, even if they're all ultimately the same.
