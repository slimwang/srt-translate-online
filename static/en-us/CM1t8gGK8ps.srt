1
00:00:00,000 --> 00:00:05,000
Hi. Welcome back. I'm here with Joshua Bloch.

2
00:00:05,000 --> 00:00:15,000
Josh is a leading textbook author, Effective Java, a book on concurrency in Java,

3
00:00:15,000 --> 00:00:19,000
a devilish book on Java puzzlers,

4
00:00:19,000 --> 00:00:24,000
and was one of the leaders who brought Java to us

5
00:00:24,000 --> 00:00:28,000
and worked on the early APIs, including the collections class and so on.

6
00:00:28,000 --> 00:00:30,000
What was that process like?

7
00:00:30,000 --> 00:00:33,000
[Josh Bloch, Google Engineer:] I as in the right place at the right time,

8
00:00:33,000 --> 00:00:38,000
and I have always enjoyed APIs have kind of been the recurrent theme of the past 20 years,

9
00:00:38,000 --> 00:00:41,000
but I used to write them for 10 or 15 people.

10
00:00:41,000 --> 00:00:45,000
All of a sudden I was writing them for millions of people.

11
00:00:45,000 --> 00:00:50,000
It was chaotic. That's the way the internet was back in those days.

12
00:00:50,000 --> 00:00:54,000
Type systems should exist to serve the programmer and not vice versa.

13
00:00:54,000 --> 00:00:58,000
If you find yourself constantly fighting with the type system,

14
00:00:58,000 --> 00:01:04,000
writing a program that won't compile, and just spend lots of time jamming the thing

15
00:01:04,000 --> 00:01:06,000
through the compiler, and it wears you out.

16
00:01:06,000 --> 00:01:09,000
You don't really gain any insight in the process--

17
00:01:09,000 --> 00:01:12,000
then there's something wrong with the type system, and I believe

18
00:01:12,000 --> 00:01:17,000
that Java's wildcards have that problem.

19
00:01:17,000 --> 00:01:22,000
In the case of Java, you've got an existing language that was designed around

20
00:01:22,000 --> 00:01:26,000
storing static typing, and if you try to put dynamic stuff into it,

21
00:01:26,000 --> 00:01:29,000
there's a little bit of an impedance mismatch.

22
00:01:29,000 --> 00:01:37,000
Things that are added to languages after the fact tend not to reside comfortably in the language.

23
00:01:37,000 --> 00:01:40,000
When languages grow too much and stray too far from their roots,

24
00:01:40,000 --> 00:01:43,000
you generally end up with big messes.

25
00:01:43,000 --> 00:01:46,000
Now, we talked about reliability of algorithms.

26
00:01:46,000 --> 00:01:52,000
You did a blog post about a bug in a decades old algorithm on binary search.

27
00:01:52,000 --> 00:01:54,000
What happened there?

28
00:01:54,000 --> 00:01:56,000
That was a an amazing story.

29
00:01:56,000 --> 00:02:02,000
I was at Carnegie Mellon University for 1982 to 1990 or so,

30
00:02:02,000 --> 00:02:08,000
and when I'd first arrived I took a PhD-level algorithms course from John Bentley,

31
00:02:08,000 --> 00:02:14,000
who was a brilliant and funny, and he started out by asking us all,

32
00:02:14,000 --> 00:02:17,000
"How many of you know how to write binary search?" We all raised our hands

33
00:02:17,000 --> 00:02:20,000
We were hot shot computer scientists.

34
00:02:20,000 --> 00:02:23,000
We got our bachelor's and we felt we knew what we were doing.

35
00:02:23,000 --> 00:02:29,000
He said, "Okay. Fine. Take out a piece of paper and write it. You've got 10 minutes, and then we'll talk."

36
00:02:29,000 --> 00:02:32,000
Ten minutes later, he said, "Okay. Who got it right?" Everybody raised their hand.

37
00:02:32,000 --> 00:02:34,000
He picks one person and says, "Put your algorithm on the board."

38
00:02:34,000 --> 00:02:37,000
The person does, and he tears it apart.

39
00:02:37,000 --> 00:02:41,000
Of course, the person had not gotten it right. It was broken.

40
00:02:41,000 --> 00:02:45,000
The point of his lecture was that you need to use invariants in your code.

41
00:02:45,000 --> 00:02:48,000
In particular, in binary search the invariants are tricky,

42
00:02:48,000 --> 00:02:51,000
and if you donât think in terms of invariants, you'll get it wrong.

43
00:02:51,000 --> 00:02:56,000
Language design is always going to be an aesthetic exercise.

44
00:02:56,000 --> 00:03:00,000
You need good taste if you're going to do it, and you're operating partially from the gut.

45
00:03:00,000 --> 00:03:04,000
Empiricism is one important part of what you're doing,

46
00:03:04,000 --> 00:03:09,000
but if something feels wrong or feels ugly then it's probably a bad idea.

47
00:03:09,000 --> 00:03:12,000
There are some people who are really good at doing the aesthetic stuff

48
00:03:12,000 --> 00:03:16,000
and at sort of placing themselves in the shoes of the programmer

49
00:03:16,000 --> 00:03:20,000
and saying, yes, this'll feel right.

50
00:03:20,000 --> 00:03:24,000
Other people can't do that, but they're really good at looking at a grammar and saying,

51
00:03:24,000 --> 00:03:27,000
"I'm afraid that you're going to end up with an ambiguity here,

52
00:03:27,000 --> 00:03:31,000
if not now when we add these other features that we intend to add."

53
00:03:31,000 --> 00:03:37,000
The point is empiricism is great. I would even say it's necessary now, but it's not sufficient.
