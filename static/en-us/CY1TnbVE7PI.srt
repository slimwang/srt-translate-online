1
00:00:00,000 --> 00:00:03,000
Now I'm going to define the parser, and I want it to have this signature.

2
00:00:03,000 --> 00:00:06,000
I'm going to define a function pare, which takes a symbol,

3
00:00:06,000 --> 00:00:09,000
saying I want to parse something like an expression.

4
00:00:09,000 --> 00:00:12,000
It takes text that we're going to parse, and it takes the grammar

5
00:00:12,000 --> 00:00:14,000
that defines that symbol and all the other symbols.

6
00:00:14,000 --> 00:00:20,000
I want it to return--when we had regular expressions we looked at returning a set of remainders.

7
00:00:20,000 --> 00:00:23,000
I'm going to have this return a single remainder.

8
00:00:23,000 --> 00:00:28,000
The idea is that we want the author of the grammar to have some control over what's going on

9
00:00:28,000 --> 00:00:33,000
and make this grammar be unambiguous so that there is a single result for each parse

10
00:00:33,000 --> 00:00:36,000
rather than having to keep a set of results.

11
00:00:36,000 --> 00:00:41,000
The idea is that for each symbol we're going to consider the alternatives in left-to-right order.

12
00:00:41,000 --> 00:00:47,000
If we're asked to parse an expression, we'll say can we parse this alternative.

13
00:00:47,000 --> 00:00:51,000
If we can, if we can parse in succession a term and then a plus or minus

14
00:00:51,000 --> 00:00:54,000
then an expression and then we'll commit to that.

15
00:00:54,000 --> 00:00:57,000
We'll say that's the result we're going to return.

16
00:00:57,000 --> 00:01:02,000
That's the single remainder, and we're not going to even explore the other alternatives.

17
00:01:02,000 --> 00:01:08,000
Because we have this left-to-right choice, that's why we decide to write the expressions in this order.

18
00:01:08,000 --> 00:01:14,000
We don't write them in the opposite order because if we wrote the rule this way

19
00:01:14,000 --> 00:01:18,000
and we were trying to parse the expression a + 3,

20
00:01:18,000 --> 00:01:22,000
we'd be asked to parse this, we'd try to parse a term, we'd say, yes, a is a term,

21
00:01:22,000 --> 00:01:24,000
and then we'd stop, and we'd say that's the end.

22
00:01:24,000 --> 00:01:28,000
We wouldn't even consider parsing off the term plus the expression.

23
00:01:28,000 --> 00:01:30,000
This is no good.

24
00:01:30,000 --> 00:01:33,000
It's up to the author of the grammar to write rules in the correct order

25
00:01:33,000 --> 00:01:35,000
so that the longest thing gets tried first.

26
00:01:35,000 --> 00:01:40,000
Our regular expression functions are what is known as recognizers.

27
00:01:40,000 --> 00:01:43,000
They told us--yes or no--is a string part of a language.

28
00:01:43,000 --> 00:01:46,000
Here what we're doing is different. It's a parser.

29
00:01:46,000 --> 00:01:51,000
It tells you--yes and no--is it part of the language, but then it also gives you

30
00:01:51,000 --> 00:01:56,000
an internal structure, a tree structure of the parts of the expression.

31
00:01:56,000 --> 00:01:59,000
Here it would be a + 3.

32
00:01:59,000 --> 00:02:04,000
If we had m * x + b,

33
00:02:04,000 --> 00:02:12,000
then that would parse into a structure that had m * x + b.

34
00:02:12,000 --> 00:02:20,000
Here I said we were a remainder, but actually I want to return a two element tuple

35
00:02:20,000 --> 00:02:23,000
of the tree followed by the remainder.

36
00:02:23,000 --> 00:02:25,000
Here's what we're going for.

37
00:02:25,000 --> 00:02:28,000
If I asked to parse the expression a * x with the grammar G,

38
00:02:28,000 --> 00:02:31,000
I want to get back this tree structure. It looks kind of complicated.

39
00:02:31,000 --> 00:02:36,000
All it's really saying is that we have an a in the first element, then the multiply sign,

40
00:02:36,000 --> 00:02:39,000
and then an x in the third element, and there's no remainder.

41
00:02:39,000 --> 00:02:41,000
We parse the whole string.

42
00:02:41,000 --> 00:02:45,000
That's what it says, but there's all these intermediate parts here because that's the way the grammar is defined.

43
00:02:45,000 --> 00:02:51,000
I should say here that this is a tree, remainder result.

44
00:02:51,000 --> 00:02:57,000
We're going to use the convention that Fail corresponds to a value of None.

45
00:02:57,000 --> 00:03:00,000
Let's think then about what we have to do to be able to parse a text.

46
00:03:00,000 --> 00:03:03,000
I can think of four cases that we have to deal with.

47
00:03:03,000 --> 00:03:10,000
One, we want to be able to parse an expression or a symbol like the expression keyword.

48
00:03:10,000 --> 00:03:14,000
To do that we've got to be able to look that up in the grammar G.

49
00:03:14,000 --> 00:03:17,000
We've also got to be able to parse a regular expression, plus or minus,

50
00:03:17,000 --> 00:03:21,000
and we've seen how to do that before, so we reduce that to a solved problem.

51
00:03:21,000 --> 00:03:25,000
We're going to have to be able to parse a tuple of alternatives.

52
00:03:25,000 --> 00:03:29,000
Here one alternative or another alternative done in left-to-right order.

53
00:03:29,000 --> 00:03:35,000
Finally, we're going to have to be able to parse a list of atoms representing a sequence--1, 2, 3.

54
00:03:35,000 --> 00:03:39,000
Now, I'm going to tell you the plan for how we're going to implement this as code

55
00:03:39,000 --> 00:03:41,000
within the function parse.

56
00:03:41,000 --> 00:03:46,000
So this first case I'm going to handle with a subroutine called "parse_atom."

57
00:03:46,000 --> 00:03:49,000
This is an atomic expression. We should be able to handle that.

58
00:03:49,000 --> 00:03:56,000
The second part, the regular expression, is a type of atom so it occurs within the parse_atom routine.

59
00:03:56,000 --> 00:04:01,000
We're going to define a variable called "tokenizer" to help us do that.

60
00:04:01,000 --> 00:04:06,000
Then we're going to use the built-in re.match along with the tokenizer

61
00:04:06,000 --> 00:04:09,000
to recognize those regular expressions.

62
00:04:09,000 --> 00:04:14,000
Then for the alternatives, a tuple of alternatives is what you get when you look up

63
00:04:14,000 --> 00:04:17,000
the symbol, like exp, in the grammar.

64
00:04:17,000 --> 00:04:21,000
I could have had a separate function called parse_alternatives

65
00:04:21,000 --> 00:04:24,000
but instead I just decided to have that be part of parse_atom,

66
00:04:24,000 --> 00:04:27,000
because it was so simple it was just an immediate step

67
00:04:27,000 --> 00:04:30,000
to go from the symbol to the list of alternatives.

68
00:04:30,000 --> 00:04:37,000
Finally, to parse this sequence of atoms, I have a subroutine or function called "parse_sequence."
