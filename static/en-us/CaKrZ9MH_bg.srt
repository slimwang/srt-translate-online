1
00:00:00,670 --> 00:00:02,350
Well this sounds great.

2
00:00:02,350 --> 00:00:04,810
Are there any down sides,

3
00:00:04,810 --> 00:00:08,440
or where are you as far as
implementing this in your company?

4
00:00:09,890 --> 00:00:12,580
>> So, we haven't implemented
it everywhere yet.

5
00:00:12,580 --> 00:00:17,570
We're using it right now almost
exclusively for generating forecasters.

6
00:00:17,570 --> 00:00:22,680
Although we've started using it in some
newer applications for similar variance.

7
00:00:22,680 --> 00:00:24,831
We're not generating whole
applications with it yet,

8
00:00:24,831 --> 00:00:27,036
we're generating mostly
components of applications.

9
00:00:27,036 --> 00:00:32,430
So there's a lot of opportunity
there to expand its use and

10
00:00:32,430 --> 00:00:34,970
we're looking into that.

11
00:00:36,680 --> 00:00:38,570
Also, I think I mentioned that

12
00:00:40,330 --> 00:00:44,270
this whole approach is based
on a lot of prior work.

13
00:00:44,270 --> 00:00:49,390
In particular, it's based on the work
on these layered assemblies,

14
00:00:49,390 --> 00:00:52,350
the GenVoca approach, the Head approach,

15
00:00:52,350 --> 00:00:56,360
all the work of David Parnas,
Don Batory.

16
00:00:56,360 --> 00:01:00,700
That work is quite rich, and so
we've been able to borrow heavily

17
00:01:00,700 --> 00:01:04,435
from it to get the LayerBlox
to where it is right now.

18
00:01:04,435 --> 00:01:09,330
But that prior work also has
gone on beyond what we've done.

19
00:01:09,330 --> 00:01:13,360
So there are some pretty nice
things you can do in some of

20
00:01:13,360 --> 00:01:18,120
Batory's latest work where you can
actually think about generating product

21
00:01:18,120 --> 00:01:19,480
lines of product families.

22
00:01:20,590 --> 00:01:22,110
Which, if you can imagine,

23
00:01:22,110 --> 00:01:26,070
would scale much larger to
building whole applications.

24
00:01:26,070 --> 00:01:28,020
We don't have any support for
that yet in LayerBlox, but

25
00:01:28,020 --> 00:01:30,140
that's something we're looking into.

26
00:01:30,140 --> 00:01:33,230
>> So
let me get a little clarification here.

27
00:01:33,230 --> 00:01:35,810
You used the term product line and
product families.

28
00:01:35,810 --> 00:01:37,730
Can you differentiate those two?

29
00:01:37,730 --> 00:01:40,060
Probably the best is to give an example.

30
00:01:40,060 --> 00:01:44,350
So what we've looked at so
far is how to use LayerBlox to generate

31
00:01:44,350 --> 00:01:47,120
different forecasters,
different variants of a forecaster.

32
00:01:47,120 --> 00:01:50,000
But a forecaster is one kind of product.

33
00:01:50,000 --> 00:01:54,043
Often what you find, and
what we have to deliver to customers,

34
00:01:54,043 --> 00:01:56,193
is a family of related projects.

35
00:01:56,193 --> 00:01:59,547
Such as a forecaster that works together
with a replenishment system that works

36
00:01:59,547 --> 00:02:01,910
together with a promotion
planning system.

37
00:02:01,910 --> 00:02:04,700
And what you really would
like to do to scale this up

38
00:02:04,700 --> 00:02:09,038
is to be able to generate product
lines of entire product families.

39
00:02:09,038 --> 00:02:12,750
And that work is,
there is existing research in that area.

40
00:02:14,750 --> 00:02:18,780
But we have not incorporated that yet
into LayerBlox.

41
00:02:18,780 --> 00:02:23,710
>> So, there's this family
of compilers called GCC that

42
00:02:23,710 --> 00:02:27,900
are capable of targeting
various platforms.

43
00:02:27,900 --> 00:02:32,587
But also they can be used for different,
the technology can be used for

44
00:02:32,587 --> 00:02:35,080
different programming languages.

45
00:02:35,080 --> 00:02:38,810
Is that related to this product
lines and product families?

46
00:02:38,810 --> 00:02:39,377
>> Interesting question.

47
00:02:41,618 --> 00:02:43,071
Yeah, I guess you could say that.

48
00:02:43,071 --> 00:02:46,090
I wouldn't think of a compiler
as a product family.

49
00:02:46,090 --> 00:02:49,040
But to the extent that it is not for
a single language but

50
00:02:49,040 --> 00:02:51,870
for multiple languages, like GCC can
be used for FORTRAN and for Ada.

51
00:02:51,870 --> 00:02:54,340
>> Right.
>> Yeah, I think that's

52
00:02:55,430 --> 00:02:57,350
probably a good way
of thinking about it.

53
00:02:57,350 --> 00:03:00,770
>> Anything else you'd like to say about
the current status of LayerBlox or

54
00:03:00,770 --> 00:03:02,940
the things you'd like
to do in the future?

55
00:03:02,940 --> 00:03:07,660
We're interested in integrating
LayerBlox itself in this method

56
00:03:07,660 --> 00:03:10,490
of composition more tightly into

57
00:03:10,490 --> 00:03:14,108
the programming language that we
use to build our applications.

58
00:03:14,108 --> 00:03:16,260
Right now LayerBlox is
a separate generator.

59
00:03:17,290 --> 00:03:22,910
But historically, this kind of approach
has almost always started that way,

60
00:03:22,910 --> 00:03:24,225
started with a separate generator.

61
00:03:24,225 --> 00:03:27,415
But then led into very tight integration
into a programming language.

62
00:03:27,415 --> 00:03:29,191
And I think that's probably
where this belongs.

63
00:03:29,191 --> 00:03:33,198
That will then let us do much more
sophisticated analyses of type

64
00:03:33,198 --> 00:03:35,430
correctness of these assemblies.

65
00:03:36,730 --> 00:03:39,070
It'll help us make
some better decisions.

66
00:03:39,070 --> 00:03:43,070
You mentioned the generality
versus performance problem,

67
00:03:43,070 --> 00:03:44,770
which could at some point crop up.

68
00:03:44,770 --> 00:03:47,130
I have no doubt that,
eventually, it might.

69
00:03:47,130 --> 00:03:50,420
By integrating this more tightly into
the programming language, you get more

70
00:03:50,420 --> 00:03:54,980
opportunities for having more context
when you're doing generation.

71
00:03:54,980 --> 00:04:02,050
>> Is this anything like
the generic capability in Java?

72
00:04:02,050 --> 00:04:05,672
Where you can generate collection
classes of various types by

73
00:04:05,672 --> 00:04:07,070
parameterizing them?

74
00:04:07,070 --> 00:04:11,111
>> It's very similar, yeah, so in fact
that tends to be that kind of method.

75
00:04:11,111 --> 00:04:15,127
The use of templates that are supported
in the programming language is

76
00:04:15,127 --> 00:04:19,560
often ways that this general model gets
tightly integrated into a language.

77
00:04:19,560 --> 00:04:25,547
So there was some work, Janusz Mardok
just did some work on integrating

78
00:04:25,547 --> 00:04:32,110
this very approach into Java, in
exactly the way you're just suggesting.

79
00:04:32,110 --> 00:04:33,260
So yes.

80
00:04:33,260 --> 00:04:38,900
>> And we will put on the class
resources page some links to some

81
00:04:38,900 --> 00:04:42,850
of the papers that Kurt is
referring to in case you want to

82
00:04:42,850 --> 00:04:44,600
look into them a little more deeply.
