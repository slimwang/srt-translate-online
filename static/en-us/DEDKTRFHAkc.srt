1
00:00:00,000 --> 00:00:04,000
Welcome to homework one. We're going to be breaking some code today.

2
00:00:04,000 --> 00:00:10,000
What you need to do for this homework is break a few incorrect implementations

3
00:00:10,000 --> 00:00:15,000
of the fixed-size queue we've been working with earlier in the unit.

4
00:00:15,000 --> 00:00:21,000
Let's go ahead and take a look at what the queue is supposed to do first.

5
00:00:21,000 --> 00:00:28,000
The queue class is just a fixed-size queue of integers and the constructor down here

6
00:00:28,000 --> 00:00:32,000
is supposed to take a single integer parameter greater than 0.

7
00:00:32,000 --> 00:00:36,000
That is the maximum number of elements that the queue can hold at a time,

8
00:00:36,000 --> 00:00:40,000
and there are four methods that we're going to need to concern ourselves with,

9
00:00:40,000 --> 00:00:46,000
and these method calls are all you're going to have access to during this.

10
00:00:46,000 --> 00:00:51,000
The empty call should return true if and only if the queue

11
00:00:51,000 --> 00:00:55,000
currently holds no elements and false, otherwise.

12
00:00:55,000 --> 00:00:57,000
The full method should do the exact opposite.

13
00:00:57,000 --> 00:01:02,000
It should return true if and only if the queue cannot hold anymore elements--

14
00:01:02,000 --> 00:01:04,000
it's completely full and false, otherwise.

15
00:01:04,000 --> 00:01:14,000
You would call it like this or like this or the empty and full methods, respectively.

16
00:01:14,000 --> 00:01:19,000
The enqueue is the only one that takes a parameter. It takes an integer to put into the queue.

17
00:01:19,000 --> 00:01:24,000
It returns true if it's successfully does so and it returns false, otherwise,

18
00:01:24,000 --> 00:01:28,000
which would only happen or should only happen if the queue is full.

19
00:01:28,000 --> 00:01:36,000
The dequeue method does not take any parameters or removes an integer from the queue and returns it.

20
00:01:36,000 --> 00:01:40,000
If it doesn't, if it fails to return anything, which should only happen

21
00:01:40,000 --> 00:01:44,000
if the queue is empty, then it returns none.

22
00:01:44,000 --> 00:01:54,000
As an example if this code where we first create a queue of size 1, then we check if it's empty,

23
00:01:54,000 --> 00:01:58,000
which it should be immediately since we haven't done anything with it so it's empty,

24
00:01:59,000 --> 00:02:04,000
should be true then we try to enqueue the number of 10 which also should succeed since

25
00:02:04,000 --> 00:02:11,000
it should be able to hold one more element so succeeded should be true then we check if it's full

26
00:02:11,000 --> 00:02:15,000
which should also be true because we just enqueued one element we can only

27
00:02:15,000 --> 00:02:20,000
hold one element so it's full should be through then we dequeue that element and

28
00:02:20,000 --> 00:02:27,000
should return 10 the value, so value should be 10 in here to give an idea of what we

29
00:02:27,000 --> 00:02:30,000
should expect from the queue implementation.

30
00:02:30,000 --> 00:02:36,000
Now the five queues that you're going to test for are going to have bugs here and there in them,

31
00:02:36,000 --> 00:02:39,000
so they're not going to behave exactly like this.

32
00:02:39,000 --> 00:02:46,000
I very much recommend reading over this specification carefully before you start testing.

33
00:02:46,000 --> 00:02:52,000
Now to test the five queues you're going to do exactly what you do here.

34
00:02:52,000 --> 00:02:57,000
You would instantiate queue and call these four methods in sum fashion and then

35
00:02:57,000 --> 00:03:04,000
using assert statements, you would try to break this code and draw in it assertion error.

36
00:03:04,000 --> 00:03:08,000
On the back end, we'll have a test harness that runs your code against all of the buggy queue

37
00:03:08,000 --> 00:03:14,000
implementations and will return the incorrect output if you manage to find it and when you

38
00:03:14,000 --> 00:03:20,000
run submit bin on your code it will tell you how many of the buggy queue implementations

39
00:03:20,000 --> 00:03:22,000
you have manage to successfully catch.

40
00:03:22,000 --> 00:03:29,000
As an example of what your test code should do if we run my implementation against the buggy code

41
00:03:29,000 --> 00:03:32,000
then we see that we get in assertion error here.

42
00:03:32,000 --> 00:03:38,000
So your code should run assertion errors for all of the buggy code.

43
00:03:38,000 --> 00:03:44,000
We'll have a test harness that will run your code against all five of the incorrect implementations

44
00:03:44,000 --> 00:03:49,000
and when you submit your code we'll tell you how many of the implementations

45
00:03:49,000 --> 00:03:53,000
you've managed to successfully catch and your goal is to catch all five.

46
00:03:53,000 --> 00:04:00,000
It took me, I think 22 lines to catch all the bugs--so let's see if you can beat me.
