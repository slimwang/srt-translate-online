1
00:00:00,000 --> 00:00:02,000
And here's my solution.

2
00:00:02,000 --> 00:00:05,000
It's pretty much just copying out the version from Pwin and making sure it fits

3
00:00:05,000 --> 00:00:08,000
with this new definition of the parameters.

4
00:00:08,000 --> 00:00:12,000
So if me plus pending is greater than goal, then the probability is 1.

5
00:00:12,000 --> 00:00:15,000
Otherwise, if you wins, the probability is 0.

6
00:00:15,000 --> 00:00:18,000
Otherwise, we compute the probability of winning by rolling.

7
00:00:18,000 --> 00:00:21,000
And if there are no pending, then we better roll,

8
00:00:21,000 --> 00:00:25,000
because if we try to hold, we'll get stuck in an infinite loop.

9
00:00:25,000 --> 00:00:30,000
So the return value is just the probability of rolling if there's no pending, if pending is 0.

10
00:00:30,000 --> 00:00:33,000
If there is a pending, then we want to take the maximum result

11
00:00:33,000 --> 00:00:37,000
of either rolling or dealing with holding.

12
00:00:37,000 --> 00:00:39,000
How did we do?

13
00:00:39,000 --> 00:00:41,000
We've defined our new Pwin2 function.

14
00:00:41,000 --> 00:00:44,000
We can call that on the same initial state, and that will do all the computations

15
00:00:44,000 --> 00:00:46,000
and cache them.

16
00:00:46,000 --> 00:00:48,000
And it turns out it takes just about ¼ of a second,

17
00:00:48,000 --> 00:00:53,000
so it's 3 times faster than the previous version that took ¾ of a second.

18
00:00:53,000 --> 00:00:56,000
And if you see the probability that it computes, it's exactly the same.

19
00:00:56,000 --> 00:01:01,000
And just to be sure, you should probably go through and pick out a bunch of other states

20
00:01:01,000 --> 00:01:03,000
and test those.

21
00:01:03,000 --> 00:01:08,000
I actually did it for all states and showed that all of them compute exactly the same function.

22
00:01:08,000 --> 00:01:11,000
Then we can look at the size of the cache and see that that's about half as much--

23
00:01:11,000 --> 00:01:14,000
a little bit less than half as much--and that's where we're getting our speed-up.

24
00:01:14,000 --> 00:01:17,000
We're only computing half as much, so it goes a lot faster.

25
00:01:17,000 --> 00:01:19,000
And there's always a choice.

26
00:01:19,000 --> 00:01:23,000
When you get a speed-up like this, you can put it in the bank or you can spend it.

27
00:01:23,000 --> 00:01:28,000
So we can put it in the bank and say, "Now we can do in ¼ of a second

28
00:01:28,000 --> 00:01:30,000
"what previously took ¾ of a second."

29
00:01:30,000 --> 00:01:36,000
Or we can spend it. Here I'm spending it by increasing the goal to 60 rather than 40.

30
00:01:36,000 --> 00:01:38,000
So much more computation to do.

31
00:01:38,000 --> 00:01:44,000
Then I reload all my code so that the caches are flushed and do a timed call again,

32
00:01:44,000 --> 00:01:47,000
and this time it's about ¾ of a second,

33
00:01:47,000 --> 00:01:51,000
and I can do in the same amount of time--which I could only handle a goal up to 40;

34
00:01:51,000 --> 00:01:54,000
now I can handle a goal up to 60.

35
00:01:54,000 --> 00:01:57,000
And note that the probability is a little bit lower than it was before.

36
00:01:57,000 --> 00:02:02,000
If the goal is farther away, then the advantage of going first is a little bit less.
