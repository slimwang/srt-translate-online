1
00:00:00,410 --> 00:00:02,860
So this compare and swap instruction is going

2
00:00:02,860 --> 00:00:07,110
to return true if it found that L and

3
00:00:07,110 --> 00:00:09,600
me, that first two arguments, are the same and

4
00:00:09,600 --> 00:00:12,620
therefore it set L to the third argument, in

5
00:00:12,620 --> 00:00:14,900
that case, it's a success and success is

6
00:00:14,900 --> 00:00:18,450
indicated by a true being returned by the operation.

7
00:00:18,450 --> 00:00:22,540
But on the other hand, if the comparison failed,

8
00:00:22,540 --> 00:00:26,150
it won't do the swap. It'll simply return false.

9
00:00:26,150 --> 00:00:27,970
So it won't do the swap, but it'll return

10
00:00:27,970 --> 00:00:31,700
false. So that's the semantic of this particular instruction. Again,

11
00:00:31,700 --> 00:00:35,885
this is an atomic instruction. And this atomic instruction

12
00:00:35,885 --> 00:00:38,540
maybe available in the architecture. But if it isn't, then

13
00:00:38,540 --> 00:00:40,730
you have to simulate it using test and set

14
00:00:40,730 --> 00:00:44,110
instruction. So in this particular example that I am showing

15
00:00:44,110 --> 00:00:47,410
you, when I try to do this unlock operation

16
00:00:47,410 --> 00:00:50,975
because this new guy has come in and he's executing,

17
00:00:50,975 --> 00:00:54,850
he's halfway through executing his lock algorithm. So he has done

18
00:00:54,850 --> 00:00:58,560
the fetch and store and, and he's going to set up the

19
00:00:58,560 --> 00:01:01,550
list so that my next pointer will point to him. So

20
00:01:01,550 --> 00:01:04,379
that's the process that he's in right now. So at that

21
00:01:04,379 --> 00:01:06,510
point, I'm coming in, I'm saying, well, I want to do

22
00:01:06,510 --> 00:01:10,270
the unlock operation, and that's when I found that my next

23
00:01:10,270 --> 00:01:13,620
pointer is nil. And so what I have to do is,

24
00:01:13,620 --> 00:01:16,370
do this compare and swap, and at the compare and swap,

25
00:01:16,370 --> 00:01:19,460
now it's going to return to me false, indicating that

26
00:01:19,460 --> 00:01:22,590
this particular operation failed. So once I know that this

27
00:01:22,590 --> 00:01:25,340
operation has failed, then I'm going to spin. And so

28
00:01:25,340 --> 00:01:29,310
the semantic of the unlock call is, I come in,

29
00:01:29,310 --> 00:01:31,480
remove myself from L. And in order to do

30
00:01:31,480 --> 00:01:34,630
that, I'm going to do this compare and swap on the

31
00:01:34,630 --> 00:01:38,270
linked list. And if I find that the compare and

32
00:01:38,270 --> 00:01:41,390
swap instruction fails, I'm going to spin. Now what am I

33
00:01:41,390 --> 00:01:44,870
spinning on? When will it become not nil? So basically

34
00:01:44,870 --> 00:01:48,260
what I'm going to do is I'm going to spin on

35
00:01:48,260 --> 00:01:51,840
my next pointer, being not nil. So right now it's

36
00:01:51,840 --> 00:01:53,880
nil. That's the reason that I think that there's nobody

37
00:01:53,880 --> 00:01:56,350
after me. I was going to set this guy to nil.

38
00:01:56,350 --> 00:01:59,180
But I know that compare and swap fail and therefore

39
00:01:59,180 --> 00:02:02,290
I know that there's a request information and I'm going to

40
00:02:02,290 --> 00:02:07,130
spin waiting for my next pointer to become not nil.

41
00:02:07,130 --> 00:02:10,538
Now when will my next pointer become not nill? Remember

42
00:02:10,538 --> 00:02:13,190
that this guy the new guy that is doing this

43
00:02:13,190 --> 00:02:16,850
lock operations doing exactly what I did earlier. Right? And,

44
00:02:16,850 --> 00:02:20,080
and what he's doing is he's gotten my coordinates and

45
00:02:20,080 --> 00:02:21,740
he is in the process of setting it up, so

46
00:02:21,740 --> 00:02:25,000
that my next pointer's going to point to him. So, eventually,

47
00:02:25,000 --> 00:02:28,520
he'll complete that operation. So my spinning is on this

48
00:02:28,520 --> 00:02:32,190
becoming not nil and it'll become not nil because of this

49
00:02:32,190 --> 00:02:35,380
new guy completing what he needs to do as

50
00:02:35,380 --> 00:02:39,910
part of this, lock operation. And, so, eventually the

51
00:02:39,910 --> 00:02:44,480
next pointer in, in my note will point to him and at that point I can come out

52
00:02:44,480 --> 00:02:46,490
of my spin loop. Now, I'm ready to signal

53
00:02:46,490 --> 00:02:49,620
the successor that hey, you got the lock. So,

54
00:02:49,620 --> 00:02:53,590
that's how I can make sure that when we

55
00:02:53,590 --> 00:02:57,290
unlock the corner case that occurs during unlock and that

56
00:02:57,290 --> 00:02:59,520
is there is no requesters after me, I can take

57
00:02:59,520 --> 00:03:04,270
care of that by doing this atomic and ensuring that

58
00:03:04,270 --> 00:03:07,220
there's no race condition between me the unlocker and a

59
00:03:07,220 --> 00:03:10,240
new requester that is in the process of forming through this

60
00:03:10,240 --> 00:03:14,040
lock call. So once this lock data structure has been

61
00:03:14,040 --> 00:03:17,180
fixed up nicely by this new requester, so far as

62
00:03:17,180 --> 00:03:20,310
I'm concerned, everything is good. I can, the list is

63
00:03:20,310 --> 00:03:22,530
good, and therefore I can go ahead and signal the next

64
00:03:22,530 --> 00:03:24,800
guy that he's got the lock and be done with it.
