1
00:00:00,390 --> 00:00:02,530
Let's take stock of where you are.

2
00:00:02,530 --> 00:00:07,830
You start with a graph G, from G,
you can construct its Laplacian, L of G.

3
00:00:07,830 --> 00:00:12,064
Now, suppose you have a partition of G,
that implies the petitioning

4
00:00:12,064 --> 00:00:15,237
of the vertices into two sets,
call them V+ or V-.

5
00:00:15,237 --> 00:00:16,725
In linear algebraic terms,

6
00:00:16,725 --> 00:00:20,200
you can translate this vortex
partition into a partition vector.

7
00:00:21,200 --> 00:00:23,900
Each vertex i is assigned
to one partition or

8
00:00:23,900 --> 00:00:27,280
the other designated by a +1 or -1.

9
00:00:27,280 --> 00:00:30,720
Now suppose you want to know
the number of cut edges in G.

10
00:00:30,720 --> 00:00:32,970
Then you can count it algebraically.

11
00:00:32,970 --> 00:00:37,220
That suggests that partitioning could
be viewed as choosing an X to minimize

12
00:00:37,220 --> 00:00:38,850
this quantity.

13
00:00:38,850 --> 00:00:41,890
So this becomes a common
notarial optimization problem.

14
00:00:41,890 --> 00:00:45,570
Formally we want an x that minimizes
the number of cut edges subject to two

15
00:00:45,570 --> 00:00:46,860
conditions.

16
00:00:46,860 --> 00:00:50,500
First you want to assign every vertex
to one partition or the other and

17
00:00:50,500 --> 00:00:53,360
you want the same number of
vertices in each partition.

18
00:00:53,360 --> 00:00:56,210
This problem is
unfortunately NP-Complete.

19
00:00:56,210 --> 00:00:57,200
Rats!

20
00:00:57,200 --> 00:01:00,480
So to work around that,
let's relax the problem a little.

21
00:01:00,480 --> 00:01:04,290
Let's start by taking away
the requirement that we assign exactly

22
00:01:04,290 --> 00:01:07,010
a +1 or -1 to every vertex.

23
00:01:07,010 --> 00:01:09,429
If you do so, then there's
a really neat fact we can use.

24
00:01:10,510 --> 00:01:13,920
This fact combines everything we know
about Graph Laplacians, along with a

25
00:01:13,920 --> 00:01:18,390
cool theorem from linear algebra called
the Courant-Fisher Minimax Theorem.

26
00:01:18,390 --> 00:01:20,550
If we're allowed to use any vector y,

27
00:01:20,550 --> 00:01:24,730
where y is normalized in a certain
way and it's elements sum to 0,

28
00:01:24,730 --> 00:01:28,580
then the vector y that minimizes
this quantity is actually q1.

29
00:01:28,580 --> 00:01:30,300
Q1, you'll remember,

30
00:01:30,300 --> 00:01:34,430
is the eigenvector corresponding
to the second smallest eigenvalue.

31
00:01:34,430 --> 00:01:38,040
And in fact the minimum value simplifies
to something that is proportional to

32
00:01:38,040 --> 00:01:39,600
that eigenvalue.

33
00:01:39,600 --> 00:01:41,320
So what does this mean?

34
00:01:41,320 --> 00:01:43,980
Let's go back to the original
optimization problem.

35
00:01:43,980 --> 00:01:48,610
Our most recent fact tells us that the
optimal value is at least this quantity.

36
00:01:48,610 --> 00:01:52,120
To turn all this into an algorithm
you need one more idea.

37
00:01:52,120 --> 00:01:56,570
Choosing x to be q1 give us a lower
bound on the thing we want.

38
00:01:56,570 --> 00:01:58,070
But how do we take a q1, and

39
00:01:58,070 --> 00:02:01,460
actually turn it into something
that is a partition vector.

40
00:02:01,460 --> 00:02:05,140
In other words, something that has plus
or minus 1 values in all the entries?

41
00:02:05,140 --> 00:02:07,470
Do you remember our spring analogy?

42
00:02:07,470 --> 00:02:11,260
In fact, the Laplacian derived from
the spring system gives us a second

43
00:02:11,260 --> 00:02:13,990
smallest eigenvector
that looks like this.

44
00:02:13,990 --> 00:02:16,170
If you plot the components
of the eigenvector for

45
00:02:16,170 --> 00:02:19,545
the second smallest eigenvalue,
you get something that looks like this.

46
00:02:19,545 --> 00:02:20,440
It's sine curvy,

47
00:02:20,440 --> 00:02:24,210
because that's what the fundamental
modes of the spring system look like.

48
00:02:24,210 --> 00:02:27,130
And as it turns out,
half of its elements are positive, and

49
00:02:27,130 --> 00:02:28,740
the other half are negative.

50
00:02:28,740 --> 00:02:31,340
So that suggests
the following algorithm.

51
00:02:31,340 --> 00:02:34,160
First, compute the Laplacian for
the graph.

52
00:02:34,160 --> 00:02:36,930
Then compute its second
smallest eigen pair.

53
00:02:36,930 --> 00:02:39,880
Then determine the partition
using the sines of

54
00:02:39,880 --> 00:02:41,840
the components of the eigenvector.

55
00:02:41,840 --> 00:02:46,695
So, that was a lot of work, but
the final algorithm is very compact.

56
00:02:46,695 --> 00:02:50,805
And indeed for plainer algorithms
it works really, really well.

57
00:02:50,805 --> 00:02:54,315
Here are two examples of what the
spectral partitioning algorithm produces

58
00:02:54,315 --> 00:02:55,805
on two graphs.

59
00:02:55,805 --> 00:02:56,385
Hey.

60
00:02:56,385 --> 00:02:57,795
Someone should make
a t-shirt out of these.
