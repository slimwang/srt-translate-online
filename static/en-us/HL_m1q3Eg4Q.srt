1
00:00:00,120 --> 00:00:03,352
Now, as you can see, keyboard input only allows firing in the cardinal and

2
00:00:03,352 --> 00:00:08,310
ordinal directions from where the player is, i.e the red and black arrows here.

3
00:00:08,310 --> 00:00:13,095
With this, players using mice as an input would get an unfair advantage. As you

4
00:00:13,095 --> 00:00:16,155
can see where the cursor is here, a mouse player would be able to shoot in a

5
00:00:16,155 --> 00:00:21,028
direction and at an angle that keyboard players wouldn't be able to use. In

6
00:00:21,028 --> 00:00:24,450
order to level the playing field, what we do in GRITS is eliminate that

7
00:00:24,450 --> 00:00:28,167
advantage by snapping the firing vector to one of the eight directions that

8
00:00:28,167 --> 00:00:33,172
keyboard controls allow. So, if you click where the cursor is now, it would go

9
00:00:33,172 --> 00:00:37,258
along the right-up vector. Each of the shaded regions corresponds to only one

10
00:00:37,258 --> 00:00:40,610
firing vector. We started out the unit talking about how important it was to

11
00:00:40,610 --> 00:00:44,330
make sure that every player had a fair experience. But an issue is, that mouse

12
00:00:44,330 --> 00:00:47,330
players with the current code can actually fire in more directions than

13
00:00:47,330 --> 00:00:51,455
keyboard players. So, what we need to do is take the actual mouse input and

14
00:00:51,455 --> 00:00:54,770
snap it to one of the eight directions that the keyboards actually have access

15
00:00:54,770 --> 00:00:59,778
to. In order to do this, we need to do a little bit more trigonometry. Now, in

16
00:00:59,778 --> 00:01:02,898
order to snap the arbitrary directional vector that we're getting from mouse

17
00:01:02,898 --> 00:01:06,018
input to one of our eight directional values that a keyboard player can use, we

18
00:01:06,018 --> 00:01:11,090
are going to utilize a lookup table. This lookup table is already populated to

19
00:01:11,090 --> 00:01:14,522
contain the eight directional vectors, unitized, that keyboard players have

20
00:01:14,522 --> 00:01:19,082
access to. Now, the magic sauce here, is taking this arbitrary directional

21
00:01:19,082 --> 00:01:22,678
vector and turning it into a lookup index that we can then query against the

22
00:01:22,678 --> 00:01:27,977
lookup table. For us, we have a magical pixie of a function, called

23
00:01:27,977 --> 00:01:32,153
getQuantizedAngleIndex. Now, I'll spare you most of the math that's inside of

24
00:01:32,153 --> 00:01:35,938
this function, because really, our intent is not to teach you trigonometry. The

25
00:01:35,938 --> 00:01:39,578
overview is this, we use the atan2 function to find the angle between the input

26
00:01:39,578 --> 00:01:44,365
directional vector, and the x positive vector. This gives us an angle between

27
00:01:44,365 --> 00:01:48,354
the two InRadians. We then use some nice fun little tricky math here to scale

28
00:01:48,354 --> 00:01:53,562
that angle value into an integer between zero and seven. That zero and seven

29
00:01:53,562 --> 00:01:57,901
value is passed back and used as an index inside of our lookup table. The

30
00:01:57,901 --> 00:02:01,097
result gives us a directional vector that matches exactly what keyboard players

31
00:02:01,097 --> 00:02:02,110
can use
