1
00:00:00,000 --> 00:00:05,340
The answer here is that all of these six factors can influence the running time of an algorithm.

2
00:00:05,340 --> 00:00:10,230
So the size of the input, I think that's a rather obvious one so in the example of Alice--

3
00:00:10,230 --> 00:00:14,290
if she is running her algorithm on a very small network that takes much shorter time

4
00:00:14,290 --> 00:00:18,800
than if she is running it on the huge Python communication center network for example.

5
00:00:18,800 --> 00:00:23,740
The structure of the input can also influence the running time of an algorithm.

6
00:00:23,740 --> 00:00:29,930
So for example if the network was structured in a way that we find that it can be covered

7
00:00:29,930 --> 00:00:35,470
with one or two monitoring devices, then the algorithm could worked in a way that

8
00:00:35,470 --> 00:00:39,500
we could immediately stop and not need to look at more complex assignments.

9
00:00:39,500 --> 00:00:43,520
Finally, the type of computer that we're using that is also very obvious one.

10
00:00:43,520 --> 00:00:48,600
If you're using a computer that is much faster so say we're using a huge workstation

11
00:00:48,600 --> 00:00:53,430
instead of a super laptop, then the algorithm would run much faster.

12
00:00:53,430 --> 00:00:57,530
The amount of memory the computer has that can also be a very important factor,

13
00:00:57,530 --> 00:01:01,790
although it might not be obvious at first sight while the memory has to do with running time.

14
00:01:01,790 --> 00:01:06,720
Let's say the memory of your computer is not enough to keep all the data

15
00:01:06,720 --> 00:01:11,560
that the algorithm is using and it has to use the hard disk for example to do some of the work

16
00:01:11,560 --> 00:01:16,860
or the memory is not enough and the algorithm has to recalculate certain parts of the solution.

17
00:01:16,860 --> 00:01:21,160
Memory is also an important factor for running time.

18
00:01:21,160 --> 00:01:24,200
How the algorithm is implemented that is of course very important.

19
00:01:24,200 --> 00:01:31,180
So are you using an implementation that is very efficient or do you have unnecessary code or

20
00:01:31,180 --> 00:01:34,050
any data structures that are inefficient that can

21
00:01:34,050 --> 00:01:36,880
make a huge difference in the practice when we run an algorithm.

22
00:01:36,880 --> 00:01:41,020
And finally the programming language use that is of course a debate

23
00:01:41,020 --> 00:01:44,100
that many people like to have that it certainly a factor.

24
00:01:44,100 --> 00:01:48,260
So there are some programming languages that will make an algorithm run a lot faster

25
00:01:48,260 --> 00:01:51,270
than other programming languages.

26
00:01:51,270 --> 00:01:53,430
And so you need to think about if efficiency matters,

27
00:01:53,430 --> 00:01:56,760
they usually also use a programming language that is suited for that.

28
00:01:56,760 --> 00:02:01,180
That's quite a lot of factors to look at and actually, I think there are lots of other factors

29
00:02:01,180 --> 00:02:04,290
that would also determine the running time of an algorithm.

30
00:02:04,290 --> 00:02:08,410
So that's why when we talked about analyzing algorithms,

31
00:02:08,410 --> 00:02:12,800
we'll have to work with the number of simplifications to focus on what's really important

32
00:02:12,800 --> 99:59:59,999
and not have to take account of all these factors and all the countless others that you might think of.
