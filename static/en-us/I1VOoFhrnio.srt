1
00:00:00,868 --> 00:00:05,670
In Cycle 5 we will try to issue this next instruction which is a divide.

2
00:00:05,670 --> 00:00:10,250
This divide is going to look for this type of a unit and find it, so

3
00:00:10,250 --> 00:00:15,404
we're going to mark that ML2 is not four. We are going to say that this is

4
00:00:15,404 --> 00:00:21,042
issued in Cycle 5. We're going to look at F0 and F6 as our inputs. F0 comes from

5
00:00:21,042 --> 00:00:26,280
ML1. F6 is actually in the register file, because this doesn't say so, for

6
00:00:26,280 --> 00:00:29,700
example, if this load has been a little bit later, we would have to wait for it,

7
00:00:29,700 --> 00:00:34,910
but because it's done, we can read 7.1 and put it here. And then we're going to

8
00:00:34,910 --> 00:00:40,380
rename F10 to point to this ML2 which is where we put the divide. And that

9
00:00:40,380 --> 00:00:45,230
concludes the issue for this cycle. Now as far as the dispatch is concerned,

10
00:00:45,230 --> 00:00:49,160
we have already dispatched this load and there is nothing else that is ready to

11
00:00:49,160 --> 00:00:53,230
dispatch, so we don't dispatch anything this cycle. In this cycle, this load is

12
00:00:53,230 --> 00:00:56,740
still executing, it is going to broadcast as a result in the very next cycle,

13
00:00:56,740 --> 00:01:02,710
in Cycle 6, and there is no result that gets broadcast in this cycle either,

14
00:01:02,710 --> 00:01:07,759
so we are basically done with Cycle 5. Now letâ€™s look at Cycle 6. In Cycle 6,

15
00:01:07,759 --> 00:01:11,627
we are going to try to dispatch this ADD. There is a unit available, so

16
00:01:11,627 --> 00:01:17,601
we will succeed in dispatching it. F8 and F2 are going to be AD1 and LD2,

17
00:01:17,601 --> 00:01:23,740
rename F6 to point to the AD2 now which is where we put this instruction.

18
00:01:23,740 --> 00:01:26,090
And that concludes the issuing of this instruction.

19
00:01:26,090 --> 00:01:30,930
Now let's look at whether we can dispatch something. Well, in Cycle 5,

20
00:01:30,930 --> 00:01:36,300
this instruction is still executing, so in Cycle 6 is going to write the result,

21
00:01:36,300 --> 00:01:40,480
but until that writes the result, nothing is ready really to execute, so

22
00:01:40,480 --> 00:01:44,600
basically we don't really dispatch anything, but there will be a right result by

23
00:01:44,600 --> 00:01:49,964
the load. As a result of this, several things will happen. First of all,

24
00:01:49,964 --> 00:01:55,575
we will deposit the result of the load, which is whatever is at address 245,

25
00:01:55,575 --> 00:02:01,480
to the register F2. So, let's say that our F2 just became, I don't know,

26
00:02:01,480 --> 00:02:06,989
minus 2.5. We can then provide this value also to all of the things that

27
00:02:06,989 --> 00:02:12,033
are waiting for LD2. In this case there are several instructions, so

28
00:02:12,033 --> 00:02:17,472
the operant here matches LD2. So, minus 2.5 will be captured here.

29
00:02:17,472 --> 00:02:21,458
And, we are no longer waiting for it. The second operant of this

30
00:02:21,458 --> 00:02:25,822
instruction also matches, but we are going to capture it here and mark this as

31
00:02:25,822 --> 00:02:30,811
no longer waiting for it. And then the first operant of this matches it,

32
00:02:30,811 --> 00:02:36,115
minus 2.5, so we are going to un-mark it here, too. And finally,

33
00:02:36,115 --> 00:02:41,958
because this entry matches LD2, we are going to change the RAT to once

34
00:02:41,958 --> 00:02:47,642
more point to the register file. So this concludes the writing of the result.

35
00:02:47,642 --> 00:02:51,158
Remember that, because now these instructions are actually ready to go, but

36
00:02:51,158 --> 00:02:53,767
because that happens kind of towards the end of the cycle,

37
00:02:53,767 --> 00:02:56,665
we consider that they cannot really dispatch in the same cycle.

38
00:02:56,665 --> 00:03:00,984
Because we are considering that we cannot first broadcast the result and

39
00:03:00,984 --> 00:03:06,370
then dispatch instructions that use that result. It's easier if we then

40
00:03:06,370 --> 00:03:09,330
first try to dispatch instructions and then broadcast the result,

41
00:03:09,330 --> 00:03:12,710
because if we now consider what can dispatch, this looks like it can dispatch,

42
00:03:12,710 --> 00:03:16,370
so we need to remember that the broadcast has happened in the same cycle, and

43
00:03:16,370 --> 00:03:20,400
this really is not eligible for dispatch yet. So that's why we did, kind of,

44
00:03:20,400 --> 00:03:24,640
dispatch before broadcast. Similarly, it would help if we just did the,

45
00:03:24,640 --> 00:03:28,030
you know, dispatch and then issue, and then broadcast, just so

46
00:03:28,030 --> 00:03:31,020
that, you know, kind of, we don't consider things that have just issued for

47
00:03:31,020 --> 00:03:34,570
dispatch. But that's easy, because only one thing gets to dispatch and

48
00:03:34,570 --> 00:03:38,860
it's very, very quick. So in Cycle 6, we have issued an instruction,

49
00:03:38,860 --> 00:03:41,820
we have broadcast the result, and nothing really has been dispatched. So

50
00:03:41,820 --> 00:03:44,285
now it's time to consider what happens in Cycle 7.
