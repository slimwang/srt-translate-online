1
00:00:00,000 --> 00:00:04,455
The solutions that we described on
how to virtualize memory in inode

2
00:00:04,455 --> 00:00:08,443
clearly indicate that there is
some degree of complexity and

3
00:00:08,443 --> 00:00:12,997
overhead that have to be incurred
by the due to virtualization.

4
00:00:12,997 --> 00:00:17,405
Given the wide recognition that
virtualization delivers important

5
00:00:17,405 --> 00:00:21,737
benefits and it's been pointed out
earlier in this lesson in that it

6
00:00:21,737 --> 00:00:26,525
presented an important path to address
some of the issues related to rising

7
00:00:26,525 --> 00:00:29,198
operating costs in the IT industry.

8
00:00:29,198 --> 00:00:34,227
The hardware companies responded and
they modified their architectures

9
00:00:34,227 --> 00:00:38,538
in a way that makes them more
appropriate for virtualization.

10
00:00:38,538 --> 00:00:42,680
In the x86 world these virtualization
friendly architectures

11
00:00:42,680 --> 00:00:45,097
started appearing around 2005.

12
00:00:45,097 --> 00:00:50,818
Read AMD Pacifica and Intel Vanderpool
Technology or LIntel-VT for short.

13
00:00:50,818 --> 00:00:55,732
With respect to x86, so one of the first
things that was fixed was to close

14
00:00:55,732 --> 00:01:00,725
the holes with respect to those 17
non-virtualizable instructions, so

15
00:01:00,725 --> 00:01:05,337
that they will cause a trap and
pass control over in a privileged mode.

16
00:01:05,337 --> 00:01:09,077
Also, the new protection
mode was introduced.

17
00:01:09,077 --> 00:01:12,986
So, as opposed to having just one
protection mode with four ranks,

18
00:01:12,986 --> 00:01:16,498
now there are two protection modes,
so root and non-root.

19
00:01:16,498 --> 00:01:21,206
Also referred to as host because this is
the route is the mode in which the host

20
00:01:21,206 --> 00:01:25,183
operating system, the hypervisor
would run and the non route,

21
00:01:25,183 --> 00:01:29,618
that's also referred to as guest which
is where the guest VM would run.

22
00:01:29,618 --> 00:01:32,801
Also, a support was added for
the processor,

23
00:01:32,801 --> 00:01:38,108
the hardware processor to understand and
to be able to interpret information

24
00:01:38,108 --> 00:01:42,697
that describes the state of
the virtual processors called VCPUs.

25
00:01:42,697 --> 00:01:46,607
This information is captured
in a VM Control Structure or

26
00:01:46,607 --> 00:01:51,258
also called a VM control block
in the AMD x86 architectures.

27
00:01:51,258 --> 00:01:55,817
The fact that the hypervisor understands
how to interpret this data, so

28
00:01:55,817 --> 00:02:00,018
it can walk this data structure
is the term that's commonly used.

29
00:02:00,018 --> 00:02:05,918
Means that it can specify whether or
not a system call should trap.

30
00:02:05,918 --> 00:02:09,726
So, it's easy for
the hypervisor to know that a particular

31
00:02:09,726 --> 00:02:13,459
type of operation should not
cause a trap into root mode and

32
00:02:13,459 --> 00:02:18,256
instead should be handled by the
privilege layer in the non-root mode, so

33
00:02:18,256 --> 00:02:22,618
the privilege layer in the non-root
mode is the operating system.

34
00:02:22,618 --> 00:02:24,921
Then other pieces of information,

35
00:02:24,921 --> 00:02:29,918
then that in a certain way can help
reduce the virtualization overhats.

36
00:02:29,918 --> 00:02:34,609
The next step in terms of virtualization
related advances was to make it

37
00:02:34,609 --> 00:02:36,237
easier to manage memory.

38
00:02:36,237 --> 00:02:41,321
Since hardware was already able to
understand the presence of different

39
00:02:41,321 --> 00:02:46,320
VMs, the next step here involved
tagging the memory structures used by

40
00:02:46,320 --> 00:02:50,338
the hypervisor with
the corresponding VM identifiers.

41
00:02:50,338 --> 00:02:55,318
So this led to support for extended
page tables where the page table entries

42
00:02:55,318 --> 00:02:59,678
now include information about
the VMI team and also tagged TLBs.

43
00:02:59,678 --> 00:03:04,394
What this means is that if there is a
context switch am, among VMs that's also

44
00:03:04,394 --> 00:03:08,837
called the world switch, when we're
switching from one VM to another.

45
00:03:08,837 --> 00:03:10,690
We don't have to flush or

46
00:03:10,690 --> 00:03:16,358
invalidate those entries that are in
the TLB that belong to the previous VM.

47
00:03:16,358 --> 00:03:21,076
This is because the MMU,
when it performs a check against

48
00:03:21,076 --> 00:03:25,977
the TLB entries will try to match
both the virtual address that is

49
00:03:25,977 --> 00:03:30,718
causing the access request as
well as the VM identifier.

50
00:03:30,718 --> 00:03:32,118
And if they both match,

51
00:03:32,118 --> 00:03:36,747
then it will proceed with the address
that's specified in the TLB entry.

52
00:03:36,747 --> 00:03:40,887
Otherwise, it will deal with
the page fault failures.

53
00:03:40,887 --> 00:03:44,168
As a result, context switches
are now much more efficient.

54
00:03:44,168 --> 00:03:48,956
Hardware was also extended to add better
support for IO virtualization and

55
00:03:48,956 --> 00:03:53,668
this included modifications both to
the processor and the chipset side.

56
00:03:53,668 --> 00:03:58,467
And also device and system interconnect
capabilities that were introduced in

57
00:03:58,467 --> 00:03:59,928
order to support this.

58
00:03:59,928 --> 00:04:04,925
Some examples of these features include
things like multiqueue capabilities on

59
00:04:04,925 --> 00:04:09,699
the device and you can think of this
as the device having multiple logical

60
00:04:09,699 --> 00:04:13,528
interfaces where each interface
can be used by a separate VM.

61
00:04:13,528 --> 00:04:16,752
And also better support
of interrupt routing, so

62
00:04:16,752 --> 00:04:21,740
that when a device needs to deliver an
interrupt to a specific VM, it actually

63
00:04:21,740 --> 00:04:26,368
interrupts the core where that VM is
executing and not some other CPUs.

64
00:04:26,368 --> 00:04:32,018
Additional virtualization related
hardware features were also included for

65
00:04:32,018 --> 00:04:36,555
stronger security guarantees that
now can be made to the VMs and

66
00:04:36,555 --> 00:04:41,447
also to protect VMs from one another
as well as from the hypervisor.

67
00:04:41,447 --> 00:04:47,558
And also, features for better management
support or for more efficiently to be

68
00:04:47,558 --> 00:04:53,028
able to perform various management
operations in virtualized environments.

69
00:04:53,028 --> 00:04:56,321
You can think of this as
more virtualization friendly

70
00:04:56,321 --> 00:04:57,938
management interfaces.

71
00:04:57,938 --> 00:05:02,700
Also, a number of new instructions
were added to x86 in order to actually

72
00:05:02,700 --> 00:05:05,057
exercise all of these new features.

73
00:05:05,057 --> 00:05:06,047
For instance,

74
00:05:06,047 --> 00:05:10,778
a new instruction was introduced to
transition from one mode to another.

75
00:05:10,778 --> 00:05:16,328
Basically, to transition from root mode
or to return control to non-root mode.

76
00:05:16,328 --> 00:05:21,084
Or a new instructions to
manipulate in certain ways

77
00:05:21,084 --> 00:05:25,860
state that's in the per VM
control data structure, etc.
