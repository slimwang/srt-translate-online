1
00:00:00,220 --> 00:00:01,589
We will now turn our attention to

2
00:00:01,589 --> 00:00:04,550
the Datastore Commit Process. This process describes

3
00:00:04,550 --> 00:00:07,890
to consistency rules for storing data. Datastore

4
00:00:07,890 --> 00:00:12,280
has two consistency models, Eventual Consistency and Strong

5
00:00:12,280 --> 00:00:14,850
Consistency. Let's look at these in more

6
00:00:14,850 --> 00:00:17,790
detail. In this use case diagram we have

7
00:00:17,790 --> 00:00:22,030
three things. Your Application, the datastore API

8
00:00:22,030 --> 00:00:25,300
that your application calls and the datastore backend,

9
00:00:25,300 --> 00:00:27,660
which performs work that your application is not involved

10
00:00:27,660 --> 00:00:30,790
in. When your application wants to store an entity,

11
00:00:30,790 --> 00:00:33,860
it performs a put operation towards the datastore API.

12
00:00:35,140 --> 00:00:37,740
The datastore backend then writes this entity to a

13
00:00:37,740 --> 00:00:40,940
log. When the write is completed, control is turned

14
00:00:40,940 --> 00:00:44,080
back to your application. At this point the Datastore

15
00:00:44,080 --> 00:00:47,790
backend has promised to write the entity to Datastore.

16
00:00:47,790 --> 00:00:50,720
Observe however that the entity has not been written yet.

17
00:00:50,720 --> 00:00:52,280
It has only been written to a log.

18
00:00:53,720 --> 00:00:55,890
The Datastore backend now goes through to work to

19
00:00:55,890 --> 00:00:59,360
make everything consistent. It does this by using the

20
00:00:59,360 --> 00:01:03,440
login information to update the entity storage and then

21
00:01:03,440 --> 00:01:06,920
it updates all the indexes. So observe that

22
00:01:06,920 --> 00:01:10,270
when control is returned to your application, datastore may

23
00:01:10,270 --> 00:01:12,310
not have done all the work required for the

24
00:01:12,310 --> 00:01:16,170
data to be updated. Is this good or bad?

25
00:01:16,170 --> 00:01:18,540
Well it's good, because this means that you have

26
00:01:18,540 --> 00:01:22,230
less latency in your application. But the question now

27
00:01:22,230 --> 00:01:24,800
becomes, what happens if a query is issued that

28
00:01:24,800 --> 00:01:27,870
would retrieve the data your application just requested to

29
00:01:27,870 --> 00:01:31,850
put into data store? Well, with eventual consistency the

30
00:01:31,850 --> 00:01:34,220
data store API will not wait for this to

31
00:01:34,220 --> 00:01:37,960
happen. So it only considers matching data that already

32
00:01:37,960 --> 00:01:41,730
exists. That is data, that was already in data store

33
00:01:41,730 --> 00:01:44,840
prior to your put call. And then it

34
00:01:44,840 --> 00:01:48,730
returns that result. That's why it's called eventual

35
00:01:48,730 --> 00:01:52,570
consistency. Queries will be eventually consistent with put

36
00:01:52,570 --> 00:01:55,070
operations performed to what's the data store API.
