1
00:00:00,550 --> 00:00:03,450
So welcome to Unit Five. The main topic for this

2
00:00:03,450 --> 00:00:06,890
unit is trying to understand the cost of running programs. So

3
00:00:06,890 --> 00:00:09,260
far, we haven't really worried about this. We've been very happy

4
00:00:09,260 --> 00:00:12,590
to write code. If we get the correct result, that's a

5
00:00:12,590 --> 00:00:16,640
great thing. But once we start making programs bigger, worrying

6
00:00:16,640 --> 00:00:19,750
about programs that do more things, running on larger inputs, we

7
00:00:19,750 --> 00:00:22,380
have to start thinking about the cost of running our programs.

8
00:00:22,380 --> 00:00:26,290
And this question of what it costs to evaluate an execution

9
00:00:26,290 --> 00:00:28,570
is a very important problem in computer science. In some

10
00:00:28,570 --> 00:00:31,490
sense, it's one of the most fundamental problems. Many people

11
00:00:31,490 --> 00:00:33,930
spend their whole careers working on this. And it's a

12
00:00:33,930 --> 00:00:38,060
problem called Algorithm Analysis. I haven't yet explained what an

13
00:00:38,060 --> 00:00:41,220
algorithm is. But you've actually written many of them already.

14
00:00:41,220 --> 00:00:44,370
So an algorithm is a procedure that always finishes. A

15
00:00:44,370 --> 00:00:48,920
procedure is just a well-define sequence of steps. It has

16
00:00:48,920 --> 00:00:52,410
to be defined precisely enough that it could be executed mechanically.

17
00:00:52,410 --> 00:00:54,080
So to be a procedure, it has to be something

18
00:00:54,080 --> 00:00:58,550
that can be executed without any thought. And we're mostly interested

19
00:00:58,550 --> 00:01:01,140
in procedures that can be executed by computers. But the

20
00:01:01,140 --> 00:01:03,300
important part of what makes it a procedure is that the

21
00:01:03,300 --> 00:01:06,320
steps are very precisely defined and don't require any thought

22
00:01:06,320 --> 00:01:09,950
to execute. To be an algorithm, it has to always finish,

23
00:01:11,150 --> 00:01:14,170
and we've pointed out already that this is a very tough

24
00:01:14,170 --> 00:01:17,900
problem to figure out whether a program will finish. In general,

25
00:01:17,900 --> 00:01:21,470
it's not possible to answer that question, but for many specific

26
00:01:21,470 --> 00:01:23,720
programs it is, and in order for a program to be an

27
00:01:23,720 --> 00:01:26,610
algorithm, we have to know that it always finishes, and it always

28
00:01:26,610 --> 00:01:30,150
produces a correct result. So once we have an algorithm, well, we

29
00:01:30,150 --> 00:01:32,870
know we have a well-defined sequence of steps, so we can reason

30
00:01:32,870 --> 00:01:36,660
about what will happen on any input, and we know that we

31
00:01:36,660 --> 00:01:39,720
will always finish and always produce the correct result. So then we

32
00:01:39,720 --> 00:01:42,920
can think about what the cost is of executing that algorithm on

33
00:01:42,920 --> 00:01:46,810
some input. So how should we think about cost?

34
00:01:46,810 --> 00:01:49,280
And the way computer scientists think about cost is

35
00:01:49,280 --> 00:01:52,860
quite different from how most people think about cost.

36
00:01:52,860 --> 00:01:56,080
So if you're normally thinking about cost, well, if

37
00:01:56,080 --> 00:01:58,340
you've got a specific object, let's say, you've got

38
00:01:58,340 --> 00:02:02,447
a cool car. This is supposed to be a

39
00:02:02,447 --> 00:02:05,246
cool car. It doesn't quite look like a cool

40
00:02:05,246 --> 00:02:08,365
car, and it's got a cost associated with it.

41
00:02:08,365 --> 00:02:11,470
Let's say, that's a $25,000 car, and you have some

42
00:02:11,470 --> 00:02:14,040
other car. So you have one car, it's got a

43
00:02:14,040 --> 00:02:16,880
particular cost, that's what it costs you get that car.

44
00:02:16,880 --> 00:02:20,365
You could another car that would be smaller and green, and

45
00:02:20,365 --> 00:02:24,480
let's say that car costs $10,000. And when we think

46
00:02:24,480 --> 00:02:27,340
about the cost of things normally, we have very specific things,

47
00:02:27,340 --> 00:02:29,290
and they have specific costs. And we know that the

48
00:02:29,290 --> 00:02:33,550
red car costs $25,000; the green car costs $10,000; the red

49
00:02:33,550 --> 00:02:35,420
car costs more than the green car. We

50
00:02:35,420 --> 00:02:38,190
just need to compare those costs. So when we

51
00:02:38,190 --> 00:02:41,790
think about the cost of algorithms, we don't

52
00:02:41,790 --> 00:02:45,680
have a specific execution in mind usually. What we

53
00:02:45,680 --> 00:02:47,730
want to understand is how the cost depends on

54
00:02:47,730 --> 00:02:50,830
input. So we might have two different algorithms. Let's

55
00:02:50,830 --> 00:02:54,060
say this is algorithm one, and we have a

56
00:02:54,060 --> 00:02:58,670
second algorithm that solves the same problem. And both

57
00:02:58,670 --> 00:03:03,410
of these are algorithms that take inputs and produce output.

58
00:03:05,420 --> 00:03:09,660
And if we want to decide which algorithm is better, well, we

59
00:03:09,660 --> 00:03:11,980
don't have a specific cost for the algorithm the way we

60
00:03:11,980 --> 00:03:13,760
do for the cars. And we can say the red car

61
00:03:13,760 --> 00:03:16,230
costs more than the green car. The cost depends on the

62
00:03:16,230 --> 00:03:18,820
actual input that we run the algorithm on, so it might

63
00:03:18,820 --> 00:03:22,640
be the case for some inputs algorithm one is faster, and

64
00:03:22,640 --> 00:03:27,350
for other inputs, algorithm two is faster, and I should label

65
00:03:27,350 --> 00:03:30,920
this algorithm two. So what we need to understand is how

66
00:03:30,920 --> 00:03:35,380
the cost of executing the algorithm depends on the input. We

67
00:03:35,380 --> 00:03:38,450
don't want to do that for every specific input, right, if we

68
00:03:38,450 --> 00:03:40,450
had to do that for every input, well, we might as

69
00:03:40,450 --> 00:03:42,930
well just run it on the input and see what it costs.

70
00:03:42,930 --> 00:03:45,510
What we want to do is be able to predict this without

71
00:03:45,510 --> 00:03:49,430
actually having to run on on every input. Normally, there isn't that

72
00:03:49,430 --> 00:03:52,120
much that matters about this specific input. The main thing that's going to

73
00:03:52,120 --> 00:03:55,940
matter about the input is the size of the input. That's not

74
00:03:55,940 --> 00:03:59,434
always the case, and we'll see examples where other properties

75
00:03:59,434 --> 00:04:01,760
of the input matter, but the primary way that we talk

76
00:04:01,760 --> 00:04:04,340
about cost in computer Science is based on the size

77
00:04:04,340 --> 00:04:07,660
of the input. As the size of income, input increases, how

78
00:04:07,660 --> 00:04:11,420
does the cost to evaluate the procedure increase? So cost

79
00:04:11,420 --> 00:04:14,920
ultimately always comes down to money. And when it comes down

80
00:04:14,920 --> 00:04:17,410
to money, well, what are the things that cost money when

81
00:04:17,410 --> 00:04:21,110
we execute algorithms? And the main things that costs money are

82
00:04:21,110 --> 00:04:24,090
the time it takes to finish. If we get an answer

83
00:04:24,090 --> 00:04:27,370
more quickly, well, we've spent less time on it, and we

84
00:04:27,370 --> 00:04:30,570
can also rent computers by the time to execute. There are

85
00:04:30,570 --> 00:04:33,980
lots of cloud computing services now that will give you a processor

86
00:04:33,980 --> 00:04:36,360
of a certain power for a certain amount of time, for

87
00:04:36,360 --> 00:04:39,600
a certain number of cents per hour. So time really is money.

88
00:04:39,600 --> 00:04:43,060
So we don't need to turn our cost estimates into money

89
00:04:43,060 --> 00:04:46,570
because we don't necessarily know how much our computing cost will be.

90
00:04:46,570 --> 00:04:48,970
But if we can understand the time it takes to execute, that

91
00:04:48,970 --> 00:04:52,380
will give us a good sense of the cost. The other main

92
00:04:52,380 --> 00:04:56,000
cost is often memory. So, if we know that we need a

93
00:04:56,000 --> 00:04:58,630
certain amount of memory to be able to execute our algorithms, well,

94
00:04:58,630 --> 00:05:01,140
that tells us something about the size of computer we need and

95
00:05:01,140 --> 00:05:04,320
how expensive that's going to be. So, we don't usually talk about cost

96
00:05:04,320 --> 00:05:07,570
in terms of dollars when we analyze algorithms, we're talking about

97
00:05:07,570 --> 00:05:11,880
cost in terms of time and memory. But those things in real

98
00:05:11,880 --> 00:05:14,160
implementations end up being cost in terms of

99
00:05:14,160 --> 00:05:18,080
dollars. So we're mostly going to focus on measuring time,

100
00:05:18,080 --> 00:05:20,630
and time is usually the most important cost

101
00:05:20,630 --> 00:05:24,210
of running an algorithm. Memory is often another consideration.
