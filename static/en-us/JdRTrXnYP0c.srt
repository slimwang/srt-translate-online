1
00:00:00,220 --> 00:00:02,210
The chief goal of a virtual memory system

2
00:00:02,210 --> 00:00:04,430
is to provide a process with the abstraction that

3
00:00:04,430 --> 00:00:06,630
it has an address space all to itself,

4
00:00:06,630 --> 00:00:10,560
typically organized like this. We have addresses for the

5
00:00:10,560 --> 00:00:15,870
program code. We have addresses for variables that

6
00:00:15,870 --> 00:00:19,920
are initialized, literals, constants, things like that. Space for

7
00:00:19,920 --> 00:00:22,850
uninitialized global variables that we expect to change over

8
00:00:22,850 --> 00:00:25,780
the course of the program. Space for the heap

9
00:00:25,780 --> 00:00:28,860
which is dynamically allocated and might grow or shrink over

10
00:00:28,860 --> 00:00:32,080
the course of the program and space for the user

11
00:00:32,080 --> 00:00:36,400
stack the procedures, local variables, all that sort of thing.

12
00:00:36,400 --> 00:00:38,840
There are also addresses reserved for the kernel, we'll see

13
00:00:38,840 --> 00:00:42,030
how this improves efficiency later in the lesson. The advantage

14
00:00:42,030 --> 00:00:45,330
of this abstration are best seen from the compiler's perspective.

15
00:00:45,330 --> 00:00:47,980
The compiler can choose an address for a local variable

16
00:00:47,980 --> 00:00:50,970
or code for the body of a procedure without having

17
00:00:50,970 --> 00:00:53,330
to worry about what other processes might be running on the

18
00:00:53,330 --> 00:00:57,250
computer at the same time as the application is compiling. And what

19
00:00:57,250 --> 00:01:01,160
physical memory those applications might be using. He gets to pretend that

20
00:01:01,160 --> 00:01:04,720
the application and the OS will have the computer entirely to themselves.
