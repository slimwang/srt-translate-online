1
00:00:00,070 --> 00:00:05,226
If n is 123, count will end up as 3, which would be correct. There are three

2
00:00:05,226 --> 00:00:09,280
digits. If n is 100, count will end up as 2, which is not the correct number of

3
00:00:09,280 --> 00:00:15,850
digits. The loop condition should actually be. While temp is greater than or

4
00:00:15,850 --> 00:00:20,146
equal to 10. We can see this by hand tracing the code. The values I'm

5
00:00:20,146 --> 00:00:26,164
interested in are count and temp. If n starts out as 123, then count will start

6
00:00:26,164 --> 00:00:33,470
as 1, temp will start as 123. Temp is greater than 10, so we increment count.

7
00:00:34,880 --> 00:00:40,705
And divide temp by 10 and divide temp by 10.0 which will give us 12.3. Now, we

8
00:00:40,705 --> 00:00:45,976
go back to the loop condition. Temp is still greater then 10 so we increment

9
00:00:45,976 --> 00:00:51,930
the count and then divide temp by 10.0 again so we have 1.23. Now, when we

10
00:00:51,930 --> 00:00:55,830
check again, temp is less than 10. So we skip to the end, and we're done. But

11
00:00:55,830 --> 00:01:02,100
what would happen if n was 100? Count would start as 1, the way it did before.

12
00:01:02,100 --> 00:01:05,608
And temp would start as 100. Temp is greater than 10, so we would increment

13
00:01:05,608 --> 00:01:13,950
count and then divide temp by 10.0. So we would have 10. And then check the

14
00:01:13,950 --> 00:01:18,940
condition again. But this time, 10 is not greater than 10. It's equal, so it

15
00:01:18,940 --> 00:01:24,860
skips out immediately. When in fact, we still had two digits left. We needed to

16
00:01:24,860 --> 00:01:28,665
increment count again. This is why the condition should be temp is greater than

17
00:01:28,665 --> 00:01:30,187
or equal to 10.
