1
00:00:00,080 --> 00:00:04,370
A hash function can be applied
to a block of data of any size.

2
00:00:04,370 --> 00:00:08,440
A hash function produces
an output of fixed size.

3
00:00:08,440 --> 00:00:11,556
Typically in the range
of 128 bits to 512 bits.

4
00:00:11,556 --> 00:00:18,100
It should be very efficient
to compute a hash of a input.

5
00:00:18,100 --> 00:00:22,850
For given hash value it should
be computationally infeasible

6
00:00:22,850 --> 00:00:28,290
to find the input so that the hash
matches the given hash value.

7
00:00:28,290 --> 00:00:32,259
That is a hash function
should be a one way function.

8
00:00:32,259 --> 00:00:38,380
Given the input data say m1,
it should be computationally infeasible

9
00:00:38,380 --> 00:00:44,510
to find another input value,
say m2 that is not equal to m1.

10
00:00:44,510 --> 00:00:47,380
Such that they have the same hash value.

11
00:00:47,380 --> 00:00:50,031
This is the weak collision
resistant property.

12
00:00:50,031 --> 00:00:54,560
The strong collision resistant
property is such that it should be

13
00:00:54,560 --> 00:00:58,310
computationally infeasible
to five different inputs,

14
00:00:58,310 --> 00:01:02,910
m1 not equal to m2 such that
they have the same hash value.

15
00:01:02,910 --> 00:01:06,620
The first three properties make
hash functions practical for

16
00:01:06,620 --> 00:01:08,100
security applications.

17
00:01:08,100 --> 00:01:11,160
In particular,
it can handle data of any size, and

18
00:01:11,160 --> 00:01:13,390
it's very efficient to compute hash.

19
00:01:13,390 --> 00:01:17,960
The one way property says that it's
quite easy to compute a hash value

20
00:01:17,960 --> 00:01:21,570
given a message, but
it is virtually impossible to find or

21
00:01:21,570 --> 00:01:22,940
generate input message.

22
00:01:22,940 --> 00:01:24,200
Given a hash value.

23
00:01:24,200 --> 00:01:28,130
This property is very important for
message authentication.

24
00:01:28,130 --> 00:01:31,530
For example,
we can authenticate a message by hashing

25
00:01:31,530 --> 00:01:33,720
a secret value together
with the message.

26
00:01:33,720 --> 00:01:37,760
The secret is not sent,
the hash and the message is sent.

27
00:01:37,760 --> 00:01:40,920
If the hash function is not one-way,
then the attacker

28
00:01:40,920 --> 00:01:44,710
being able to intercept the hash
value that's being transmitted.

29
00:01:44,710 --> 00:01:48,140
He can then find an input
that computes the hash value.

30
00:01:48,140 --> 00:01:50,940
And the input would
include the secret value,

31
00:01:50,940 --> 00:01:54,550
that is the attacker would be
able to obtain the secret value.

32
00:01:54,550 --> 00:01:58,280
Therefore, this one way property
is extremely important.

33
00:01:58,280 --> 00:02:01,340
The weak collision resistant
property says that for

34
00:02:01,340 --> 00:02:05,670
given message, it is not possible
to find a different message,

35
00:02:05,670 --> 00:02:09,470
such that it will have the same
hash value as the given message.

36
00:02:09,470 --> 00:02:13,350
This is a very important property
to ensure message integrity.

37
00:02:13,350 --> 00:02:17,730
Now let's take a closer look at this
weak collision resistant property.

38
00:02:17,730 --> 00:02:20,730
Suppose when a sender sends
a message to the receiver,

39
00:02:20,730 --> 00:02:23,500
he wants to ensure
the integrity of the message.

40
00:02:23,500 --> 00:02:28,250
So the sender sends a message along with
an encrypted hash code of the message.

41
00:02:28,250 --> 00:02:31,690
Now an attacker can
intercept the message, and

42
00:02:31,690 --> 00:02:33,920
the encrypted hash code
that is being transmitted.

43
00:02:33,920 --> 00:02:37,570
Given a message, the attacker
can also compute the hash code.

44
00:02:37,570 --> 00:02:40,090
Of course this hash
code is not encrypted,

45
00:02:40,090 --> 00:02:42,320
because the attacker
does not have the key.

46
00:02:42,320 --> 00:02:46,140
Then if the weak collision
resistant poverty is not true.

47
00:02:46,140 --> 00:02:48,940
The attacker will be able
to find another message,

48
00:02:48,940 --> 00:02:54,130
such that each hash value is the same as
the hash value of the original message.

49
00:02:54,130 --> 00:02:58,500
Then the hacker simply forwards to
the receiver the forged message,

50
00:02:58,500 --> 00:03:01,050
along with the original
encrypted hash code.

51
00:03:01,050 --> 00:03:04,110
The receiver will not be able
to tell that the message

52
00:03:04,110 --> 00:03:06,050
has been modified by the attacker.

53
00:03:06,050 --> 00:03:10,140
Because the forged message has
exactly the same hash value

54
00:03:10,140 --> 00:03:11,560
as the original message.

55
00:03:11,560 --> 00:03:15,940
The strong collision resistant property,
says that it is not possible to find

56
00:03:15,940 --> 00:03:19,980
any pair of two different messages, so
that they have the same hash value.

57
00:03:19,980 --> 00:03:23,390
It should be obvious that the strong
collision resistant property

58
00:03:23,390 --> 00:03:26,350
implies the weak collision
resistant property.

59
00:03:26,350 --> 00:03:30,150
The weak collision resistant property
means that the hash function

60
00:03:30,150 --> 00:03:31,810
is collision resistant.

61
00:03:31,810 --> 00:03:34,685
Only to the specific
given input messages.

62
00:03:34,685 --> 00:03:39,650
Whereas the strong collision resistant
property, means that the hash function

63
00:03:39,650 --> 00:03:43,450
is collision resistant to any
pair of different messages.

64
00:03:43,450 --> 00:03:47,980
Therefore, this is stronger property and
it implies the weaker property.

65
00:03:47,980 --> 00:03:53,130
The strong collision resistant property,
provides strong message authenticity and

66
00:03:53,130 --> 00:03:54,800
integrity protection.

67
00:03:54,800 --> 00:03:56,680
Let's take a look at an example.

68
00:03:56,680 --> 00:04:01,520
Suppose Bob did some work for Alice,
and he wants Alice to pay him later.

69
00:04:01,520 --> 00:04:04,210
So he can draft a IOU message and

70
00:04:04,210 --> 00:04:08,320
ask Alice to sign and
then agree to pay for it.

71
00:04:08,320 --> 00:04:12,160
To sign the message,
Alice will hash the IOU message.

72
00:04:12,160 --> 00:04:15,270
And then sign the hash
using her private key.

73
00:04:15,270 --> 00:04:19,649
This will prove that Alice
authorized the IOU message.

74
00:04:19,649 --> 00:04:23,350
In other words, Alice would
agree to pay this amount later.

75
00:04:23,350 --> 00:04:28,470
In a later day, Bob can present this
IOU message, along with the signature,

76
00:04:28,470 --> 00:04:31,870
to Alice or
Alice's bank to get the money.

77
00:04:31,870 --> 00:04:35,670
Now suppose the strong collision
resistant property is not true.

78
00:04:35,670 --> 00:04:38,800
That would mean that Bob can
find two different messages,

79
00:04:38,800 --> 00:04:41,010
one with a smaller dollar amount.

80
00:04:41,010 --> 00:04:42,030
For example,

81
00:04:42,030 --> 00:04:47,220
this small amount can be just one
installment of Alice's payment to Bob.

82
00:04:47,220 --> 00:04:51,780
And the larger amount would be
several times the amount of money

83
00:04:51,780 --> 00:04:53,770
that Alice owes Bob.

84
00:04:53,770 --> 00:04:58,750
And if these two messages have the same
hash value, then Bob can present

85
00:04:58,750 --> 00:05:04,520
the message with a small amount
to Alice, and have Alice sign it.

86
00:05:04,520 --> 00:05:07,690
Bob can present a signature
with a different message.

87
00:05:07,690 --> 00:05:12,750
That is, the message with a larger
amount, and ask Alice to pay for it.

88
00:05:12,750 --> 00:05:16,680
And because these two different
messages have the same hash value,

89
00:05:16,680 --> 00:05:19,670
Alice can not deny
that she has signed it.

90
00:05:19,670 --> 00:05:22,350
That means that Alice can not deny that

91
00:05:22,350 --> 00:05:24,640
she has agreed to pay
this larger amount.
