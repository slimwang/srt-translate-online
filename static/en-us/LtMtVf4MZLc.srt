1
00:00:00,140 --> 00:00:03,240
You've been working a lot with and and or now, and the expressions got kind of

2
00:00:03,240 --> 00:00:08,263
complicated. In fact, so complicated that they've attracted the interest of

3
00:00:08,263 --> 00:00:13,900
mathematicians, such as this stern looking fellow. His name is George Boole.

4
00:00:13,900 --> 00:00:17,612
And he figured out the rules for working with conditions that could be true or

5
00:00:17,612 --> 00:00:23,480
false. And ever since, that's been called Boolean logic. Now, why do we care?

6
00:00:23,480 --> 00:00:27,478
We want our programs to be simpler to read. And so, when we have a long and

7
00:00:27,478 --> 00:00:30,598
complex condition, such as this one, we might want to put it in a separate

8
00:00:30,598 --> 00:00:35,877
method. Let's think about what this test here was. This was the test for the s

9
00:00:35,877 --> 00:00:41,659
flag, where you had a blue square in the middle. And this test you checked, is

10
00:00:41,659 --> 00:00:46,080
our pixel, in the middle. Alright, so if we had a method that could test that,

11
00:00:46,080 --> 00:00:51,470
we could say, if x and y is in the middle, then we want blue, otherwise white.

12
00:00:51,470 --> 00:00:55,930
Much easier to read. Lets go and write this method. Here it is, isInMiddle,

13
00:00:55,930 --> 00:01:00,132
takes and x and a y, coordinate. And here, you have the exact same condition

14
00:01:00,132 --> 00:01:04,500
that we've had before. And we simply compute, and return that. There's just one

15
00:01:04,500 --> 00:01:09,184
catch. We have to specify a return type for this method. And what is this thing

16
00:01:09,184 --> 00:01:13,315
that's being returned? Well it's either true or false. In Java, the type, that

17
00:01:13,315 --> 00:01:17,965
has two values, true and false, is called, Boolean, in honor, of our friend

18
00:01:17,965 --> 00:01:23,470
George. Here it is. So when you have a method, that can return a condition,

19
00:01:23,470 --> 00:01:28,843
that's true or false, you declare it as a Boolean method. Then you can use that

20
00:01:28,843 --> 00:01:32,914
method inside an if statement just as much as you can use the relational

21
00:01:32,914 --> 00:01:38,224
operator. You would want to do that whenever a condition has become so

22
00:01:38,224 --> 00:01:43,040
complicated, that you want to put it inside its own method. You can also

23
00:01:43,040 --> 00:01:55,490
declare variables of Boolean type. Let me give you a quick example. [SOUND].

24
00:01:55,490 --> 00:02:00,050
I've reimplemented the isInMiddle method to use two Boolean variables. Let's

25
00:02:00,050 --> 00:02:04,230
check it out. The first variable, x in middle, checks where the x is between 1

26
00:02:04,230 --> 00:02:09,530
3rd and 2 3rds of the weight. It's said to true if this condition is fulfilled.

27
00:02:09,530 --> 00:02:14,709
Or to false if it's not. And similarly. This variable over here, yInMiddle, is

28
00:02:14,709 --> 00:02:19,796
set to true when this condition is fulfilled, and to false if it's not. Why

29
00:02:19,796 --> 00:02:24,561
might I want to do this? Because each of those conditions is complicated enough

30
00:02:24,561 --> 00:02:30,240
that by saving it in a variable, it makes the code easier to read. Now over

31
00:02:30,240 --> 00:02:34,650
here, I say if both of these conditions are fulfilled then the point is in the

32
00:02:34,650 --> 00:02:40,558
middle, so I return the and of these two. Generally, you use a Boolean variable

33
00:02:40,558 --> 00:02:43,798
if you want to remember a value that's true of false, so that you can use it

34
00:02:43,798 --> 00:02:50,839
later. Sarah has an example of that for you, in a different context.
