1
00:00:00,000 --> 00:00:06,000
And the answer is p--is indeed contained within np and the reason is if the problem that we had

2
00:00:06,000 --> 00:00:12,000
can be decided by some polynomial time algorithm s that takes the input, runs in polynomial time,

3
00:00:12,000 --> 00:00:16,000
and either says yes or no correctly for that input, then we can design--

4
00:00:16,000 --> 00:00:20,000
remember that the main thing in the definition of np is that it has a verification algorithm,

5
00:00:20,000 --> 00:00:27,000
so we can define a verification algorithm like this--define a to take the input and any certificate

6
00:00:27,000 --> 00:00:36,000
that simply returns s of x--this runs in polynomial time and it accepts inputs and certificates correctly.

7
00:00:36,000 --> 00:00:42,000
So for any input x, there's some certificate that makes it say yes--that is to say any certificate--

8
00:00:42,000 --> 00:00:44,000
because if the answer is yes, it's always going to return yes.

9
00:00:44,000 --> 00:00:47,000
And if the answer is no, there's no certificate you can give it

10
00:00:47,000 --> 00:00:50,000
that would get it to say anything other than no.

11
00:00:50,000 --> 00:00:53,000
That's again because it's a growing certificate and actually just giving the answer.

12
00:00:53,000 --> 00:00:57,000
So it's satisfies the two things that we need for the problem to be an np.

13
00:00:57,000 --> 00:01:01,000
So anything np is also an np.
