1
00:00:00,012 --> 00:00:01,885
Okay, let's look at these.

2
00:00:01,885 --> 00:00:03,551
So here I've drawn a chunk of memory.

3
00:00:03,551 --> 00:00:05,649
And we're going to say that g points into this memory.

4
00:00:05,649 --> 00:00:09,186
So this is g sub 0, g sub 1, g sub 2, and so forth.

5
00:00:09,186 --> 00:00:11,821
And here's a bunch of threads, and we're just going to reason out

6
00:00:11,821 --> 00:00:14,870
where each of these threads is accessing in memory.

7
00:00:14,870 --> 00:00:17,333
So in the first case, g sub i equals a.

8
00:00:17,333 --> 00:00:23,930
Well every thread is simply accessing allocation and memory defined by its thread index.

9
00:00:23,945 --> 00:00:26,372
This is exactly the example we've been talking about.

10
00:00:26,372 --> 00:00:30,136
A given set of threads will be accessing a bunch of adjacent

11
00:00:30,136 --> 00:00:33,773
contiguous locations in memory, so this case is clearly coalesced.

12
00:00:33,773 --> 00:00:38,447
In this case, every thread is accessing a location in memory defined by its index times 2.

13
00:00:38,447 --> 00:00:41,359
So there's going to be a strided access here, right?

14
00:00:41,391 --> 00:00:45,240
Threads are going to end up reading every other location in memory.

15
00:00:45,240 --> 00:00:49,785
So, this is the access pattern we've called strided, it's not coalesced.

16
00:00:49,831 --> 00:00:54,866
This next access pattern is exactly like the first time, except that we're doing reads instead of writes.

17
00:00:54,866 --> 00:00:59,504
So again, every thread is simply reading a location defined by it's own index in memory.

18
00:00:59,504 --> 00:01:03,678
Therefore, adjacent threads will access adjacent locations in memory, and just

19
00:01:03,678 --> 00:01:06,980
like the first example, we're going to have a nice coalesced access pattern.

20
00:01:06,980 --> 00:01:11,846
This next example is coalesced because every thread is reading from a location

21
00:01:11,846 --> 00:01:19,613
defined by g plus some offset block width over 2 plus the thread's index.

22
00:01:19,613 --> 00:01:28,923
So if this is block width number 2, then every thread will be accessing adjacent locations starting at that offset.

23
00:01:28,923 --> 00:01:33,466
So this is coalesced. And this example is simply the same pattern.

24
00:01:33,466 --> 00:01:38,492
We're going to read from this location which is defined by an offset plus the thread index.

25
00:01:38,492 --> 00:01:40,363
We're going to multiply it times a constant.

26
00:01:40,363 --> 00:01:45,186
And we're going to store the result back into a contiguous, chunk of memory.

27
00:01:45,186 --> 00:01:48,724
So this is simply a coalesced read followed by a coalesced write.

28
00:01:48,724 --> 00:01:54,970
Therefore, the statement is coalesced. And finally, this example is a little different.

29
00:01:54,970 --> 00:01:59,766
Here we're going to be accessing a location, offset of memory minus the thread index.

30
00:01:59,796 --> 00:02:06,394
So thread 0 will access block width over 2, thread 1 will access block

31
00:02:06,394 --> 00:02:11,921
width over 2 minus 1, thread 2 will access block width over 2 minus 2, and so forth.

32
00:02:11,921 --> 00:02:14,699
And as you can see, even though we're doing the subtraction

33
00:02:14,699 --> 00:02:17,519
here instead of an addition, we're still accessing a contiguous region in memory.

34
00:02:17,519 --> 00:02:22,561
Every thread is accessing adjacent locations and contiguous chunk of

35
00:02:22,561 --> 00:02:24,893
memory, so this is still coalesced.
