1
00:00:00,470 --> 00:00:04,160
The second part of CPU virtualization, which

2
00:00:04,160 --> 00:00:06,770
is common to both full and para-virtualized

3
00:00:06,770 --> 00:00:10,750
environments, is being able to deliver events

4
00:00:10,750 --> 00:00:13,880
to the parent guest operating system. And these

5
00:00:13,880 --> 00:00:19,450
events are events that are generated by a process that belongs to the guest

6
00:00:19,450 --> 00:00:23,310
operating system, currently executing On the CPU.

7
00:00:23,310 --> 00:00:26,130
Let's see what is happening to this process,

8
00:00:26,130 --> 00:00:31,190
when it is executing on the CPU. Once this process has been scheduled

9
00:00:31,190 --> 00:00:36,210
on the CPU, during its normal program execution, everything should

10
00:00:36,210 --> 00:00:41,330
be happening on hardware speech, what is that mean? Well. The process

11
00:00:41,330 --> 00:00:46,630
is going to generate virtual addresses that has to be translated to

12
00:00:46,630 --> 00:00:51,180
machine page addresses. And we talked at

13
00:00:51,180 --> 00:00:57,690
length about how the hypervisor can ensure that the virtual address translation

14
00:00:57,690 --> 00:01:04,730
to the machine page address. Can be done at hardware speeds by clever tricks

15
00:01:04,730 --> 00:01:09,220
in the hypervisor and or the guest operating system. In a fully virtualized

16
00:01:09,220 --> 00:01:13,840
environment, the hypervisor is responsible for ensuring

17
00:01:13,840 --> 00:01:16,970
that the virtual address gets translated directly

18
00:01:16,970 --> 00:01:18,710
to the machine address. With all the

19
00:01:18,710 --> 00:01:22,520
intervention of the guest operating system. And para-virtualized

20
00:01:22,520 --> 00:01:26,770
environment once again with cooperation between the guest

21
00:01:26,770 --> 00:01:30,010
and the hypervisor, we can ensure that the

22
00:01:30,010 --> 00:01:33,490
page table that is used for translating virtual

23
00:01:33,490 --> 00:01:36,010
address to physical addresses is something that had

24
00:01:36,010 --> 00:01:38,890
been installed. On behalf of the guest operating

25
00:01:38,890 --> 00:01:42,150
system, by the hypervisor so that the translation

26
00:01:42,150 --> 00:01:47,400
can happen at hardware speeds. And is the most crucial part of ensuring

27
00:01:47,400 --> 00:01:50,240
good performance for the currently executing,

28
00:01:50,240 --> 00:01:55,050
process in a virtualized environment. All address

29
00:01:55,050 --> 00:01:59,620
translations. I dealt with. That's why I kept harping on the fact that

30
00:01:59,620 --> 00:02:03,830
virtual memory, managing the virtual memory, is

31
00:02:03,830 --> 00:02:07,060
the thorny issue in a virtualized setting.

32
00:02:07,060 --> 00:02:09,430
So we know that this is in good hands,

33
00:02:09,430 --> 00:02:12,500
we know how to handle that. Let's look at other

34
00:02:12,500 --> 00:02:15,430
things that can happen to this process during the course

35
00:02:15,430 --> 00:02:19,160
of its execution. One thing that this process may do.

36
00:02:19,160 --> 00:02:22,590
Is execute a system call. For instance, it might want

37
00:02:22,590 --> 00:02:26,060
to open a file. And that's really a call into

38
00:02:26,060 --> 00:02:29,290
the guest operating system. That's something that this process may

39
00:02:29,290 --> 00:02:32,160
do. Another thing that can happen to this process is

40
00:02:32,160 --> 00:02:37,180
that it can incur a page fault. Not all of. The virtual address piece of the

41
00:02:37,180 --> 00:02:41,010
process is going to be in the machine memory.

42
00:02:41,010 --> 00:02:45,790
And therefore if some virtual page cannot be translated,

43
00:02:45,790 --> 00:02:48,400
then it's going to result in a page fault.

44
00:02:48,400 --> 00:02:51,260
Or the process may throw an exception. For

45
00:02:51,260 --> 00:02:54,490
instance, it might do something silly like divide

46
00:02:54,490 --> 00:02:57,750
by zero which can result in an exception And

47
00:02:57,750 --> 00:03:00,710
lastly, though no fault of this process, there

48
00:03:00,710 --> 00:03:02,640
could be an external interrupt when this process

49
00:03:02,640 --> 00:03:05,120
is executing. So these are the kind of

50
00:03:05,120 --> 00:03:09,790
discontinuities, these are called program discontinuities, that is, affecting

51
00:03:09,790 --> 00:03:13,280
the normal execution of this process. And the

52
00:03:13,280 --> 00:03:16,040
first three things that I mentioned, syscall, page

53
00:03:16,040 --> 00:03:19,900
fault, and exceptions, are due to this process

54
00:03:19,900 --> 00:03:22,710
in some shape or form. But the fourth one,

55
00:03:22,710 --> 00:03:25,370
the external interrupt is something that is

56
00:03:25,370 --> 00:03:30,240
happening asynchronously and unbeknownst to what this

57
00:03:30,240 --> 00:03:32,550
process intended to do while running on

58
00:03:32,550 --> 00:03:35,820
the processor. And all of these continuities

59
00:03:35,820 --> 00:03:40,720
have to be passed up, by the hypervisor to the guest operating system. So

60
00:03:40,720 --> 00:03:43,580
the common issue. To both full and

61
00:03:43,580 --> 00:03:48,260
para virtualized environment, is that all such program

62
00:03:48,260 --> 00:03:52,020
disk continuities for the currently running process

63
00:03:52,020 --> 00:03:55,250
have to be passed up to the parent

64
00:03:55,250 --> 00:03:58,970
guest operating system by the hypervisor. Whether it

65
00:03:58,970 --> 00:04:01,800
is a para virtualized or a fully virtualized

66
00:04:01,800 --> 00:04:05,190
operating system. Nothing special needs to be done

67
00:04:05,190 --> 00:04:08,750
in the guest operating system for fielding these

68
00:04:08,750 --> 00:04:11,130
events from the hypervisor. because all of these

69
00:04:11,130 --> 00:04:13,420
events are going to be packaged as software

70
00:04:13,420 --> 00:04:16,290
interrupts by the hypervisor and delivered to the

71
00:04:16,290 --> 00:04:19,410
guest operating system. Any operating system knows how

72
00:04:19,410 --> 00:04:22,600
to handle interrupts. So all the hypervisor has

73
00:04:22,600 --> 00:04:25,570
to do. Is to package these events as software

74
00:04:25,570 --> 00:04:27,910
interrupts, and pass it up to the guest

75
00:04:27,910 --> 00:04:32,170
operating system. There are some quirks of the architecture

76
00:04:32,170 --> 00:04:34,230
that may get in the way and the

77
00:04:34,230 --> 00:04:39,150
hypervisor may have to deal with that. Recall that

78
00:04:39,150 --> 00:04:47,250
syscalls and page faults and exceptions. Or all things that need to be handled

79
00:04:47,250 --> 00:04:48,820
by the guest operating system. So it

80
00:04:48,820 --> 00:04:52,220
probably has entry points in it, for leading

81
00:04:52,220 --> 00:04:57,560
with all these kinds of program list continuities. Now some of the things that

82
00:04:57,560 --> 00:04:59,260
the guest operating system may have to

83
00:04:59,260 --> 00:05:04,230
do to deal with these. Program discontinuities may

84
00:05:04,230 --> 00:05:08,430
require the guest operating system to have privileged

85
00:05:08,430 --> 00:05:12,670
access to the CPU. That is, certain instructions

86
00:05:12,670 --> 00:05:16,050
of the processor can only be executed in

87
00:05:16,050 --> 00:05:18,500
the kernel mode, or the privileged mode. But

88
00:05:18,500 --> 00:05:21,800
recall that the guest operating system itself Is

89
00:05:21,800 --> 00:05:23,990
not running in the privileged mode. It is

90
00:05:23,990 --> 00:05:26,330
above the red line, which means it has

91
00:05:26,330 --> 00:05:30,480
no more privilege than a normal user-level process.

92
00:05:30,480 --> 00:05:32,250
This is a problem, especially in a

93
00:05:32,250 --> 00:05:36,010
fully virtualized environment. Because the fully virtualized

94
00:05:36,010 --> 00:05:38,540
environment, the guest operating system has no

95
00:05:38,540 --> 00:05:42,400
knowledge that it does not have the privileges.

96
00:05:42,400 --> 00:05:45,480
So when it tries to execute some

97
00:05:45,480 --> 00:05:49,530
instruction, that can be executed only in publish

98
00:05:49,530 --> 00:05:52,770
mode, the expectation is that. It'll trap,

99
00:05:52,770 --> 00:05:55,595
get in the hypervisor, and the hypervisor will

100
00:05:55,595 --> 00:05:58,490
then do the work that the fully

101
00:05:58,490 --> 00:06:01,410
virtualized guest operating system was intending to do.

102
00:06:01,410 --> 00:06:02,790
But here is where the quirks of

103
00:06:02,790 --> 00:06:06,790
the architecture come into play. Because unfortunately, some

104
00:06:06,790 --> 00:06:12,130
privileged instructions fail silently in some architectures

105
00:06:12,130 --> 00:06:15,000
when they're executed at the user level. And

106
00:06:15,000 --> 00:06:16,990
this is a problem for the fully virtualized

107
00:06:16,990 --> 00:06:20,710
environment. Where the binary is unchanged. In the

108
00:06:20,710 --> 00:06:24,520
paravirtualized environment, because we know that the paravirtualized guest

109
00:06:24,520 --> 00:06:28,060
is not running on bare metal, we know that

110
00:06:28,060 --> 00:06:31,260
it does not have the same privilege as the

111
00:06:31,260 --> 00:06:36,010
hypervisor. And therefore, we can collaboratively make sure that

112
00:06:36,010 --> 00:06:38,540
anything that the guest has to do in privileged

113
00:06:38,540 --> 00:06:40,790
mode. It can take the help of the hypervisor

114
00:06:40,790 --> 00:06:43,230
to do it. But in a fully virtualized setting,

115
00:06:43,230 --> 00:06:46,690
the guest has no knowledge. So the only mechanism

116
00:06:46,690 --> 00:06:49,330
that will save the day, is if the

117
00:06:49,330 --> 00:06:52,270
guest tries to execute a privileged instruction, it'll

118
00:06:52,270 --> 00:06:54,710
trap into the hypervisor, and the hypervisor can

119
00:06:54,710 --> 00:07:00,010
do the necessary thing. However, because some instructions

120
00:07:00,010 --> 00:07:02,310
when executed at the user level. Even though

121
00:07:02,310 --> 00:07:05,400
they are privileged instructions. They don't trap, but

122
00:07:05,400 --> 00:07:08,190
fail silently and that can be a problem.

123
00:07:08,190 --> 00:07:12,160
This happens in older versions of Access Architecture

124
00:07:12,160 --> 00:07:17,230
for privilege instructions, executed in user mode. Therefore, the hypervisor has

125
00:07:17,230 --> 00:07:22,520
to be intimately aware of the quirks of the hardware, and ensure

126
00:07:22,520 --> 00:07:27,260
that there is workaround such quirks. Specifically, in a fully virtualized

127
00:07:27,260 --> 00:07:32,250
setting, the hypervisor has to look at the unchanged binary

128
00:07:32,250 --> 00:07:37,204
of the operating system, and look for Places where

129
00:07:37,204 --> 00:07:42,280
these quarks may surface and do binary rewriting in

130
00:07:42,280 --> 00:07:47,500
order to catch those instructions when and if

131
00:07:47,500 --> 00:07:52,460
they're executed on the CPU. Having said that, I should mention that. Newer

132
00:07:52,460 --> 00:07:57,390
versions of Intel's architecture and AMD architecture for the

133
00:07:57,390 --> 00:08:02,530
x86 constructions have included virtualization support so

134
00:08:02,530 --> 00:08:06,250
that these kinds of problems don't occur. As

135
00:08:06,250 --> 00:08:09,430
a result of servicing the events that are

136
00:08:09,430 --> 00:08:12,470
delivered with a hypervisor, the guest may have

137
00:08:12,470 --> 00:08:15,570
to do certain things. Which may result in communication

138
00:08:15,570 --> 00:08:18,060
back to the hypervisor. In the case of

139
00:08:18,060 --> 00:08:21,440
a fully virtualized environment, communication from the guest

140
00:08:21,440 --> 00:08:25,120
to the hypervisor is always implicit via traps.

141
00:08:25,120 --> 00:08:28,320
For example, as a result of page four servicing,

142
00:08:28,320 --> 00:08:31,620
the guest may try to install a new entry

143
00:08:31,620 --> 00:08:33,789
into the page table. When it tries to do

144
00:08:33,789 --> 00:08:35,679
that, that's a trap that will come in to

145
00:08:35,679 --> 00:08:37,870
the hypervisor and the hypervisor will take the appropriate

146
00:08:37,870 --> 00:08:43,056
action. In a pair of a virtualized environment the communication from the guest

147
00:08:43,056 --> 00:08:48,240
to the hypervisor is explicit, so that API's that the hypervisor supports

148
00:08:48,240 --> 00:08:53,610
for the guest OS to communicate back to the hypervisor. What maybe

149
00:08:53,610 --> 00:08:56,610
reasons for that? Well. We talked about memory

150
00:08:56,610 --> 00:09:00,662
management done by the guest operating system in a

151
00:09:00,662 --> 00:09:04,260
pair of virtualized environment such as [UNKNOWN] where

152
00:09:04,260 --> 00:09:07,620
the guest operating system may have to tell the

153
00:09:07,620 --> 00:09:10,860
hypervisor, here is a page table entry. Please

154
00:09:10,860 --> 00:09:13,900
install it in the page table for me. So

155
00:09:13,900 --> 00:09:16,040
that is the kind of communication that may have

156
00:09:16,040 --> 00:09:18,720
to come back from the guest operating system down

157
00:09:18,720 --> 00:09:19,428
to the hypevisor.
