1
00:00:00,000 --> 00:00:03,354
So this is a pretty tough question--I hope you were able to solve it.

2
00:00:03,354 --> 00:00:05,277
There are lots of different ways to solve this.

3
00:00:05,277 --> 00:00:09,000
I'll start by working out one way on the sketchpad,

4
00:00:09,000 --> 00:00:13,000
and then we'll see a few different ways to solve it in the Python Interpreter.

5
00:00:13,000 --> 00:00:15,000
So I'm going to call the 3 inputs "a", "b", and "c".

6
00:00:15,000 --> 00:00:17,000
We can call them anything we want,

7
00:00:17,000 --> 00:00:19,000
and since they're not meaningful numbers,

8
00:00:19,000 --> 00:00:22,000
might as well just use the first 3 letters.

9
00:00:22,000 --> 00:00:26,000
So one way to solve it is to have a big, complicated, nested "if" statement.

10
00:00:26,000 --> 00:00:28,000
So we're going to have several comparisons.

11
00:00:28,000 --> 00:00:31,000
First, we want to check if "a" is greater than "b".

12
00:00:31,000 --> 00:00:34,000
If "a" is greater than "b"--well "a" might be the biggest,

13
00:00:34,000 --> 00:00:38,000
but we don't know yet; we still have to check if "a" is greater than "c".

14
00:00:38,000 --> 00:00:40,585
So we need 2 "ifs" and the important thing

15
00:00:40,585 --> 00:00:42,000
to notice about the 2 "ifs"--

16
00:00:42,000 --> 00:00:48,000
the comparison, "a greater than c" is indented inside the "if a is greater than b".

17
00:00:48,000 --> 00:00:51,000
So this will only happen when "a" is greater than "b".

18
00:00:51,000 --> 00:00:54,000
That means if "a" is greater than "b" and "a" is greater than "c",

19
00:00:54,000 --> 00:00:57,000
"a" is the biggest, so we can return "a".

20
00:00:57,000 --> 00:01:01,000
If it's not--well, now we've got the case where "a" was greater than "b".

21
00:01:01,000 --> 00:01:06,000
"a" is not greater than "c", so that means "c" is greater than or equal to "a".

22
00:01:06,000 --> 00:01:08,000
So now we know that "c" is the biggest since "c" is bigger

23
00:01:08,000 --> 00:01:11,000
or as big as "a" and "a" is bigger than "b".

24
00:01:11,000 --> 00:01:13,000
So now we can return "c".

25
00:01:13,000 --> 00:01:18,000
So when this is not True, we know that "c" is greater than or equal to "a",

26
00:01:18,000 --> 00:01:20,415
and we know that "a" is greater than "b" because this test

27
00:01:20,415 --> 00:01:22,000
evaluated it to True.

28
00:01:22,000 --> 00:01:24,000
So we know it's correct to return "c".

29
00:01:24,000 --> 00:01:28,000
Now, we want an "else" that corresponds to this condition,

30
00:01:28,000 --> 00:01:33,000
so here if "a" is greater than "b", we evaluated this code.

31
00:01:33,000 --> 00:01:35,000
If "a" is not greater than "b",

32
00:01:35,000 --> 00:01:40,000
well that means we have: "b" is greater than or equal to "a".

33
00:01:40,000 --> 00:01:46,000
And in this case, we want to check whether "b" is greater than "c"

34
00:01:46,000 --> 00:01:51,000
so we need another "if"--I'm going to use "if b is greater than c".

35
00:01:51,000 --> 00:01:53,000
Now we know that "b" is greater than "c".

36
00:01:53,000 --> 00:01:56,000
"b" was greater than or equal to "a" because we went to the "else" here.

37
00:01:56,000 --> 00:01:58,000
So that means we can return "b".

38
00:01:58,000 --> 00:02:02,000
If not--well then, we know "b" is greater than or equal to "a",

39
00:02:02,000 --> 00:02:05,000
and "c" is greater than or equal to "b",

40
00:02:05,000 --> 00:02:07,000
which is greater than or equal to "a".

41
00:02:07,000 --> 00:02:09,369
So that means "c" is the biggest.

42
00:02:09,369 --> 00:02:11,000
We should return "c".

43
00:02:11,000 --> 00:02:13,708
So here we have a definition of "biggest".

44
00:02:13,708 --> 00:02:15,000
It's pretty complicated.

45
00:02:15,000 --> 00:02:19,000
We have 3 different "if" statements.

46
00:02:19,000 --> 00:02:23,000
The main one that starts by comparing "a" and "b",

47
00:02:23,000 --> 00:02:25,723
and then within that, we compare "a" and "c".

48
00:02:25,723 --> 00:02:27,554
Then we have the "else,"

49
00:02:27,554 --> 00:02:29,831
and within the else, we compare "b" and "c."

50
00:02:29,831 --> 00:02:32,446
Whenever we have lots of nested "if" expressions--

51
00:02:32,446 --> 00:02:34,754
and certainly, we can have more than this amount,

52
00:02:34,754 --> 00:02:37,000
but this is already getting to be enough to be confusing.

53
00:02:37,000 --> 00:02:39,615
We should try to think if there's a clearer way to do this,

54
00:02:39,615 --> 00:02:42,000
a way to make the code smaller and simpler,

55
00:02:42,000 --> 00:02:44,000
easier to understand--and if it's easier to understand,

56
00:02:44,000 --> 00:02:47,000
that means it's also easier to write it correctly.

57
00:02:47,000 --> 00:02:50,000
So the easier way to write this would be to use the "bigger" procedure

58
00:02:50,000 --> 00:02:52,000
that we defined earlier in this unit.

59
00:02:52,000 --> 00:02:57,000
And if we remember what that was, we defined "bigger" like this:

60
00:02:57,000 --> 00:03:01,000
"bigger" took 2 inputs, it compares them: if "a" is greater than "b",

61
00:03:01,000 --> 00:03:03,000
it returns "a".

62
00:03:03,000 --> 00:03:07,000
If not, well then "b" is bigger--or at least equally big--

63
00:03:07,000 --> 00:03:09,000
so we can return "b".

64
00:03:09,000 --> 00:03:13,000
So if we have "bigger" defined, which we already did,

65
00:03:13,000 --> 00:03:15,000
then we can define "biggest" in a much simpler way.

66
00:03:15,000 --> 00:03:17,000
We don't need all these "ifs".

67
00:03:17,000 --> 00:03:19,000
All we need to do is use "bigger" twice.

68
00:03:19,000 --> 00:03:22,000
So if we remember that we have the "biggest" procedure,

69
00:03:22,000 --> 00:03:25,000
well then we can think about "biggest" this way.

70
00:03:25,000 --> 00:03:27,000
So we've got 3 inputs coming into "biggest",

71
00:03:27,000 --> 00:03:30,000
and it should produce 1 output--the biggest of those 3.

72
00:03:30,000 --> 00:03:33,000
Well, we've got the "bigger" procedure

73
00:03:33,000 --> 00:03:36,000
so we could use "bigger" to compare two.

74
00:03:36,000 --> 00:03:40,000
If we put "a" and "b" into "bigger"

75
00:03:40,000 --> 00:03:43,000
the output here is going to be the bigger of "a" and "b".

76
00:03:43,000 --> 00:03:47,000
To know the biggest of the 3--well now we need to compare that one

77
00:03:47,000 --> 00:03:51,000
with "c", so the inputs to this ""bigger" procedure

78
00:03:51,000 --> 00:03:54,000
will be the result of "bigger" of "a" and "b"

79
00:03:54,000 --> 00:03:56,000
and the input, "c".

80
00:03:56,000 --> 00:03:59,000
And the output of that will be the biggest of the three.

81
00:03:59,000 --> 00:04:02,000
So this is composing 2 calls to "bigger".

82
00:04:02,000 --> 00:04:05,000
We want the inputs to the first call to be "a" and "b".

83
00:04:05,000 --> 00:04:08,000
We want the output of that call to be one of the inputs to the next call.

84
00:04:08,000 --> 00:04:10,000
So here's how we can do that, in code.

85
00:04:10,000 --> 00:04:12,000
We can return the result directly,

86
00:04:12,000 --> 00:04:17,000
and the result will be the result of "bigger"--

87
00:04:17,000 --> 00:04:20,000
and this is the last "bigger".

88
00:04:20,000 --> 00:04:22,000
When we do composition,

89
00:04:22,000 --> 00:04:25,262
we need to think about the function that we actually do last

90
00:04:25,262 --> 00:04:29,000
coming first because that one needs the inputs of the other ones.

91
00:04:29,000 --> 00:04:32,877
So the input to this call to "bigger", it has 2 inputs.

92
00:04:32,877 --> 00:04:38,000
It has the result of this one, which took "a" and "b" as its inputs.

93
00:04:38,000 --> 00:04:40,000
So that's what's here,

94
00:04:40,000 --> 00:04:42,000
taking in "a" and "b", producing this output.

95
00:04:42,000 --> 00:04:48,000
That's one of the inputs, and then the second input to "bigger" is "c".

96
00:04:48,000 --> 00:04:50,000
So that's a much shorter way to write "biggest".

97
00:04:50,000 --> 00:04:52,231
It takes advantage of the fact that we already

98
00:04:52,231 --> 00:04:55,000
defined a procedure that does this for 2 inputs.

99
00:04:55,000 --> 00:04:58,000
And now we want to do the "biggest" for 3 inputs.

100
00:04:58,000 --> 00:05:00,262
There's actually an even easier way to do it,

101
00:05:00,262 --> 00:05:02,092
and that's using a built-in operator.

102
00:05:02,092 --> 00:05:06,000
There's a built-in operator, "max", and we could use "max" directly

103
00:05:06,000 --> 00:05:09,215
to implement "bigger", just returning the "max" of a, b, and c.

104
00:05:09,215 --> 00:05:11,477
If we actually knew about the built-in operator, "max"--

105
00:05:11,477 --> 00:05:14,000
well then, we wouldn't need to find "biggest" at all.

106
00:05:14,000 --> 00:05:15,877
We could just use the built-in "max".

107
00:05:15,877 --> 00:05:19,400
But the important thing to see here is that we can define procedures ourselves.

108
00:05:19,400 --> 00:05:22,000
And, in fact, we've seen enough at this point

109
00:05:22,000 --> 00:05:25,000
that every built-in procedure in Python,

110
00:05:25,000 --> 00:05:27,000
you could actually define yourself.

111
00:05:27,000 --> 00:05:28,415
And it's even better than that,

112
00:05:28,415 --> 00:05:30,092
that you actually know enough at this point,

113
00:05:30,092 --> 00:05:32,354
that you could write every possible computer program,

114
00:05:32,354 --> 00:05:34,185
using just the things that we've seen.

115
00:05:34,185 --> 00:05:36,231
And this is a pretty astounding result,

116
00:05:36,231 --> 00:05:38,000
and I mean this in a very strong sense,

117
00:05:38,000 --> 00:05:40,569
that everything that could be computed mechanically

118
00:05:40,569 --> 00:05:44,000
by any machine can be described using a program

119
00:05:44,000 --> 00:05:46,000
that only used the things that we've seen so far.

120
00:05:46,000 --> 00:05:48,000
All you need is procedures, simple arithmetic

121
00:05:48,000 --> 00:05:51,000
with the comparisons, and "if" statements.

122
00:05:51,000 --> 00:05:53,000
And this is a pretty amazing thing.

123
00:05:53,000 --> 00:05:57,000
This was shown by Alan Turing, back in the 1930s.

124
00:05:57,000 --> 00:06:00,000
Alan Turing is probably the most important computer scientist.

125
00:06:00,000 --> 00:06:03,354
In the 1930s, he developed an abstract model of the computer

126
00:06:03,354 --> 00:06:05,000
which we now know as the "Turing Machine".

127
00:06:05,000 --> 00:06:08,215
And he proved that that machine, with a very few simple operations,

128
00:06:08,215 --> 00:06:10,000
could simulate any other machine.

129
00:06:10,000 --> 00:06:13,000
I should point out that Alan Turing was doing this back in the 1930s,

130
00:06:13,000 --> 00:06:16,000
when there weren't computers like we think of today.

131
00:06:16,000 --> 00:06:18,554
In the 1930s, what someone thought a computer was

132
00:06:18,554 --> 00:06:20,462
was a human who did calculations,

133
00:06:20,462 --> 00:06:23,000
and they did calculations in a mechanical way,

134
00:06:23,000 --> 00:06:26,000
following steps such as what you might have learned in grade school

135
00:06:26,000 --> 00:06:29,000
to do long division or long arithmetic.

136
00:06:29,000 --> 00:06:32,000
Alan Turing showed that a very simple model

137
00:06:32,000 --> 00:06:35,000
was enough to capture everything that a mechanical computer could do,

138
00:06:35,000 --> 00:06:38,000
whether it was a human computer or a modern computer

139
00:06:38,000 --> 00:06:41,000
that operates electronically, like we think of today.

140
00:06:41,000 --> 00:06:43,000
Following World War II, he worked at Bletchley Park.

141
00:06:43,000 --> 00:06:45,000
This was the headquarters where all the

142
00:06:45,000 --> 00:06:48,000
British efforts to break the Nazi encryptions were done.

143
00:06:48,000 --> 00:06:51,000
Alan Turing lead the effort there to break the Enigma Code.

144
00:06:51,000 --> 00:06:57,000
Enigma was the most widely used cypher code by the Nazis.

145
00:06:57,000 --> 00:07:01,000
And Alan Turing built machines that could be used to break the Enigma Code.

146
00:07:01,000 --> 00:07:03,000
These were sort of like computers.

147
00:07:03,000 --> 00:07:05,000
They would do lots and lots of calculations.

148
00:07:05,000 --> 00:07:09,000
The big difference between these machines and what we think of as computers

149
00:07:09,000 --> 00:07:11,000
is these machines weren't programmable.

150
00:07:11,000 --> 00:07:13,000
They were built for one very specific task,

151
00:07:13,000 --> 00:07:17,000
for doing a calculation that was useful for breaking Enigma encrypted messages.

152
00:07:17,000 --> 00:07:19,000
And it was tremendously useful that they could do that.

153
00:07:19,000 --> 00:07:21,000
This had a huge impact on WWII.

154
00:07:21,000 --> 00:07:25,000
But they weren't computers because they couldn't be programmed to do anything else.

155
00:07:25,000 --> 00:07:28,000
We're not going to get into the theory of Turing Machines in this course,

156
00:07:28,000 --> 00:07:31,000
but I hope you'll take one of the later courses that we'll do.

157
00:07:31,000 --> 00:07:35,785
The important point to make now is that, with a very few simple operations,

158
00:07:35,785 --> 00:07:39,000
you can simulate any other operation you want.

159
00:07:39,000 --> 00:07:42,338
And you've seen arithmetic, you've seen comparisons,

160
00:07:42,338 --> 00:07:45,000
you've seen how to define and call procedures,

161
00:07:45,000 --> 00:07:48,000
and you've seen how to use "if" to make decisions.

162
00:07:48,000 --> 00:07:51,000
This is enough to simulate anything else a computer can do.

163
00:07:51,000 --> 00:07:55,000
So with just that, you could write every possible computer program.

164
00:07:55,000 --> 00:07:59,000
We could end the course here and you could, from just the things that you know now,

165
00:07:59,000 --> 00:08:01,000
build any computation you want.

166
00:08:01,000 --> 00:08:03,000
We're not going to end the course here though.

167
00:08:03,000 --> 00:08:05,615
And the reason for that is, although you could, in theory,

168
00:08:05,615 --> 00:08:07,000
build every computation

169
00:08:07,000 --> 00:08:09,677
using just these very simple things that we have so far,

170
00:08:09,677 --> 00:08:12,000
that's not going to be the best way to build computations,

171
00:08:12,000 --> 00:08:16,000
that there are more powerful constructs that we can use

172
00:08:16,000 --> 00:08:19,846
that mean, with a smaller amount of code, or in a more elegant way,

173
00:08:19,846 --> 00:08:22,000
that we can write the computations we want.

174
00:08:22,000 --> 00:08:25,000
We also have a lot to learn to get practice using these

175
00:08:25,000 --> 00:08:27,000
to define more interesting programs.

176
00:08:27,000 --> 00:08:29,323
But in theory, everything that you need to know

177
00:08:29,323 --> 00:08:31,000
to write any possible computation,

178
00:08:31,000 --> 00:08:35,000
you already know, from just these constructs that we've seen so far.
