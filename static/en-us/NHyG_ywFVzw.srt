1
00:00:00,000 --> 00:00:03,000
Now, mostly we're looking for correct code.

2
00:00:03,000 --> 00:00:06,000
If you wrote some more tests, you may start to have some more confidence

3
00:00:06,000 --> 00:00:08,000
in the code that we have.

4
00:00:08,000 --> 00:00:11,000
We're also considering efficiency to some degree.

5
00:00:11,000 --> 00:00:16,000
It seems like there's a big problem with the efficiency of the program we have so far.

6
00:00:16,000 --> 00:00:18,000
Let me show you one of the issues.

7
00:00:18,000 --> 00:00:22,000
Now we represented states as a (here, there, t) triplet.

8
00:00:22,000 --> 00:00:28,000
The problem with this is there can be two states that have identical here and there's

9
00:00:28,000 --> 00:00:32,000
but differ in the t, and they're going to be considered different states.

10
00:00:32,000 --> 00:00:34,000
Why is that a problem?

11
00:00:34,000 --> 00:00:36,000
Consider this problem.

12
00:00:36,000 --> 00:00:42,000
We have two people--one who takes 1 unit to cross the bridge, and one who takes 1000.

13
00:00:42,000 --> 00:00:46,000
It seems pretty clear there is an easy solution. The two of them go across together.

14
00:00:46,000 --> 00:00:50,000
It takes 1000, but look how we're going to explore this space.

15
00:00:50,000 --> 00:00:55,000
We're going to start out in the initial state that took time 0,

16
00:00:55,000 --> 00:00:58,000
and then we're going to start adding things to the frontier.

17
00:00:58,000 --> 00:01:02,000
Out of all the ways we could cross, the one that adds the least

18
00:01:02,000 --> 00:01:06,000
is for the 1 to go across by himself.

19
00:01:06,000 --> 00:01:11,000
Now he's on the other side with the 1 on the other side and the 1000 on the original side.

20
00:01:11,000 --> 00:01:13,000
That only took 1 step.

21
00:01:13,000 --> 00:01:16,000
Now what's the fastest thing we can do after that?

22
00:01:16,000 --> 00:01:20,000
We could take 1 more step and go back to the original state.

23
00:01:20,000 --> 00:01:28,000
Here we had 1 and we'll call K for the 1000 on the left-hand side.

24
00:01:28,000 --> 00:01:32,000
Here K was left behind and 1 went over to the right.

25
00:01:32,000 --> 00:01:37,000
Here we took one more time unit, and we had 1, K on this side.

26
00:01:37,000 --> 00:01:41,000
If we continue taking the fastest step we can,

27
00:01:41,000 --> 00:01:47,000
we'll get to another distinct state where K is on this side and 1 is on the other side.

28
00:01:47,000 --> 00:01:49,000
The flashlight is always going with the 1.

29
00:01:49,000 --> 00:01:54,000
We keep on going on like that. We'll go out 1000 different steps.

30
00:01:54,000 --> 00:01:57,000
Each of these will be a distinct state,

31
00:01:57,000 --> 00:02:02,000
because this will be the state with time t equals 0.

32
00:02:02,000 --> 00:02:07,000
Here time t equals 1, t equals 2, t equals 3.

33
00:02:07,000 --> 00:02:10,000
But really, although it looks like we're getting different states,

34
00:02:10,000 --> 00:02:13,000
in another way of looking at it, we're always getting the same state.

35
00:02:13,000 --> 00:02:18,000
We're just going back and forth from here to there and back to here and back and back.

36
00:02:18,000 --> 00:02:20,000
We're going around in circles.

37
00:02:20,000 --> 00:02:24,000
In order to recognize that these are in fact the same states,

38
00:02:24,000 --> 00:02:26,000
we're going to have to take t out of our state,

39
00:02:26,000 --> 00:02:29,000
and we're going to have to deal with the t someplace else.

40
00:02:29,000 --> 00:02:34,000
We want our representation of a state to be just (here, there).

41
00:02:34,000 --> 00:02:38,000
We've got to figure out someplace else to put the t.

42
00:02:38,000 --> 00:02:41,000
I'm not sure what the right way to do it is, but why don't we do it this way?

43
00:02:41,000 --> 00:02:47,000
We have a path, which is state, action, state dot, dot, dot--

44
00:02:47,000 --> 00:02:50,000
keeps on alternating between states and actions.

45
00:02:50,000 --> 00:02:57,000
Let's change that so that the path is a state followed by a tuple of the action

46
00:02:57,000 --> 00:03:00,000
and the total time it took after applying that action,

47
00:03:00,000 --> 00:03:05,000
then the next state, then the next action and the total time after applying that, and so on.

48
00:03:05,000 --> 00:03:08,000
That'll be our new representation.

49
00:03:08,000 --> 00:03:13,000
States are going to look like that, and paths are going to look like that.

50
00:03:13,000 --> 00:03:16,000
Now, I want you to write the new successor function for the bridge problem.

51
00:03:16,000 --> 00:03:22,000
We'll call it bsuccessors2--the "2" just to keep it distinct from the first version.

52
00:03:22,000 --> 00:03:25,000
Again it returns a dict of state-action pairs.

53
00:03:25,000 --> 00:03:30,000
A state now is just a two-tuple of (here, there),

54
00:03:30,000 --> 00:03:32,000
and the here and there are still frozen sets.

55
00:03:32,000 --> 00:03:36,000
It's pretty much the same except we dropped out the time t.

56
00:03:36,000 --> 99:59:59,999
Go ahead and implement that for me.
