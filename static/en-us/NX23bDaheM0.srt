1
00:00:00,000 --> 00:00:04,290
And the answer here is that I would recommend that Alice run both algorithms

2
00:00:04,290 --> 00:00:08,780
because both algorithms, if you look at them, are very simple so they can be implemented

3
00:00:08,780 --> 00:00:12,560
to run very fast even if the input graph is very large.

4
00:00:12,560 --> 00:00:18,190
So if she can first, for example, run the take 2 algorithm and then she already has a solution

5
00:00:18,190 --> 00:00:22,670
for which she has a guaranteed, so running the take 2 algorithm will defer some information

6
00:00:22,670 --> 00:00:29,640
about an optimum solution and that is the optimum solution cannot be smaller than some quantity x.

7
00:00:29,640 --> 00:00:34,220
And if she then runs the greedy algorithm, she can just see if the greedy algorithm

8
00:00:34,220 --> 00:00:38,080
gives her a solution that is better than the take 2 algorithm.

9
00:00:38,080 --> 00:00:43,650
In this case, she should take the greedy solution or if it produces adverse solution,

10
00:00:43,650 --> 00:00:49,300
so if by some accident she's running it on a graph that has the same properties than the one that

11
00:00:49,300 --> 00:00:53,470
we just constructed to trick the algorithm, then she can take the solution,

12
00:00:53,470 --> 00:00:55,900
and in this way, she gets the best of both algorithms.

13
00:00:55,900 --> 00:01:00,260
She gets the good performance or the generally good performance of this algorithm,

14
00:01:00,260 --> 00:01:03,780
but she ensures that she is within certain guarantees.

15
00:01:03,780 --> 00:01:07,740
The important thing here to keep in mind is just because an approximation algorithm

16
00:01:07,740 --> 00:01:13,490
sounds like it make sens or sounds like it is a good idea, doesn't really mean that it is a good idea.

17
00:01:13,490 --> 00:01:16,500
It could be a good idea, but unless you analyze the algorithms

18
00:01:16,500 --> 99:59:59,999
and try to prove that properties--you'll never know.
