1
00:00:00,000 --> 00:00:03,000
Let's think about it for a little bit, you'll see there is really only two possibilities.

2
00:00:03,000 --> 00:00:08,000
If we're trying to find the shortest path from I to J that is allowed to use K

3
00:00:08,000 --> 00:00:11,000
and any of the nodes with numbers smaller than K.

4
00:00:11,000 --> 00:00:15,000
There are two possibilities. It may be that we don't need to use K at all for the smallest path.

5
00:00:15,000 --> 00:00:19,000
We just follow path from I to J only using nodes who have values less than K

6
00:00:19,000 --> 00:00:23,000
or we go and visit K and then we go from K to J,

7
00:00:23,000 --> 00:00:28,000
but in visiting K, we don't ever need to visit K on the way to K that wouldn't be a very good path.

8
00:00:28,000 --> 00:00:33,000
The shortest path from I to K only using nodes that are less than K

9
00:00:33,000 --> 00:00:39,000
then we follow another path now from K to J only using nodes whose numbers are less than K.

10
00:00:39,000 --> 00:00:42,000
Those are the only things that could happen. We don't want to visit K twice.

11
00:00:42,000 --> 00:00:45,000
We're not allowed to use any nodes that are greater than K

12
00:00:45,000 --> 00:00:48,000
those are the two possibilities and whichever one of these two things is shortest.

13
00:00:48,000 --> 00:00:53,000
The shortest path from I to K followed by the shortest path from K to J

14
00:00:53,000 --> 00:00:56,000
or the shortest path from I to J whichever those two things are shortest,

15
00:00:56,000 --> 00:00:59,000
is the shortest path from I to J possibly using K and things less than K.

16
00:00:59,000 --> 00:01:02,000
We can just write that in a straightforward way

17
00:01:02,000 --> 00:01:05,000
by taking advantage of the fact that someone has given us the K,

18
00:01:05,000 --> 00:01:08,000
not tooth decay but matrix decay.

19
00:01:08,000 --> 00:01:16,000
The length of the shortest path from I to K using only those less than K, we have that already.

20
00:01:16,000 --> 00:01:18,000
Someone gave it to us very helpfully.

21
00:01:18,000 --> 00:01:21,000
All we need to do is compare the distance of I to J not using K

22
00:01:21,000 --> 00:01:25,000
and the distance from I to K not using K and K to J not using K.

23
00:01:25,000 --> 00:01:27,000
It's weird, but it's the right thing to do.

24
00:01:27,000 --> 00:01:31,000
We can take advantage of this insight to actually create an efficient algorithm

25
00:01:31,000 --> 00:01:38,000
We can initialize D⁰ so this is the length of the shortest path from I to J

26
00:01:38,000 --> 00:01:43,000
using nodes only numbered less than zero which is to say no intermediate node,

27
00:01:43,000 --> 00:01:46,000
but that's just the direct cost of going from I to J.

28
00:01:46,000 --> 00:01:50,000
From the cost in our graph, we can fill in this matrix.

29
00:01:50,000 --> 00:01:57,000
And once we have D⁰ initialize, we can run K from 0 to n-1

30
00:01:57,000 --> 00:02:01,000
and for each pair of I and J, take Dk+1 to be the smaller of D⁰[k,i,,j]

31
00:02:01,000 --> 00:02:07,000
and D⁰[k,i,k} and D⁰[k,i,j] add it together just as I was describing before.

32
00:02:07,000 --> 00:02:10,000
When this is all over, when this loop is done, we have the D⁰n,

33
00:02:10,000 --> 00:02:15,000
but D⁰[n,i,j} is the length of the shortest from I to J

34
00:02:15,000 --> 00:02:18,000
only hopping on nodes that are numbered less than n, but that's all the nodes.

35
00:02:18,000 --> 00:02:20,000
All the nodes are numbered less than n.

36
00:02:20,000 --> 00:02:22,000
They are all numbered from 0 to n-1.

37
00:02:22,000 --> 00:02:25,000
so this is the length of the shortest path from I to J, unrestricted, full stop.

38
00:02:25,000 --> 00:02:28,000
so that's pretty cool, and if you think about what's going on here,

39
00:02:28,000 --> 00:02:32,000
this initialization step runs over all pairs of nodes so that's n².

40
00:02:32,000 --> 00:02:39,000
This loop runs over all pairs of nodes n², but it does this from each value from 0 to n-1.

41
00:02:39,000 --> 00:02:44,000
So altogether we're talking about n*n² or n³.

42
00:02:44,000 --> 00:02:51,000
This better than the n3/logn we get by applying repeat Dijkstra to a dense graph.

43
00:02:51,000 --> 00:02:57,000
So for a dense graph, you're better off using Floyd-Warshall n³ instead of the n³/logn.

44
00:02:57,000 --> 00:03:00,000
Log n is often not that huge a number so your mileage may vary.

45
00:03:00,000 --> 00:03:05,000
so you can actually try the overhead, but boy it's hard to imagine having less overhead than this

46
00:03:05,000 --> 00:03:08,000
It is very straightforward it runs through the n³ possibilities,

47
00:03:08,000 --> 00:03:14,000
and in fact, if we do this carefully, we don't need to keep a separate D matrix for each of this cases.

48
00:03:14,000 --> 00:03:18,000
You can actually do these updates completely in place so the storage is pretty low too.
