1
00:00:00,000 --> 00:00:02,000
Alright, let's go through a possible answer together.

2
00:00:02,000 --> 00:00:06,000
To see if there's an outgoing edge, we'll just check to see if the

3
00:00:06,000 --> 00:00:08,000
tuple (current, letter) is in edges.

4
00:00:08,000 --> 00:00:13,000
If so, our destination state can be obtained by just looking up

5
00:00:13,000 --> 00:00:15,000
the tuple (current, letter) in edges.

6
00:00:15,000 --> 00:00:19,000
We've already processed letter, the 0th element of string,

7
00:00:19,000 --> 00:00:24,000
so we want to peel off the 0th character, retaining only the rest of them.

8
00:00:24,000 --> 00:00:29,000
For example, if the input was "aaa111", we've used the "a",

9
00:00:29,000 --> 00:00:31,000
so now we want it to be just "aa111".

10
00:00:31,000 --> 00:00:36,000
Now we just call ourselves recursively, call finite state machine simulation

11
00:00:36,000 --> 00:00:39,000
on the remaining string, starting from the destination node,

12
00:00:39,000 --> 00:00:42,000
and the edges and accepting states are unchanged.

13
00:00:42,000 --> 00:00:45,000
Otherwise, we fall off the finite state machine and return false.

14
00:00:45,000 --> 00:00:48,000
Alright. The moment of truth.

15
00:00:48,000 --> 00:00:50,000
We want to print out this answer.

16
00:00:50,000 --> 00:00:56,000
Oh! Just as we expected, "aaa111" is accepted by this string.

17
00:00:56,000 --> 00:00:59,000
What if I try to mix it up and make it something like "a1a1a1"?

18
00:00:59,000 --> 00:01:02,000
This should not be accepted by our finite state machine,

19
00:01:02,000 --> 00:01:05,000
and it is not. The output changes to false.

20
00:01:05,000 --> 00:01:07,000
How about the empty string? Is that accepted?

21
00:01:07,000 --> 00:01:11,000
It's not because we're looking for "a+1+" so this should also be false.

22
00:01:11,000 --> 00:01:15,000
And it is, but how about the smallest string we do accept, "a1"?

23
00:01:15,000 --> 00:01:18,000
That one is accepted. Great!

24
00:01:18,000 --> 00:01:22,000
So we can check any finite state machine to see if it accepts a string.

25
00:01:22,000 --> 00:01:24,000
You may have noticed as we were going through it,

26
00:01:24,000 --> 00:01:26,000
that edges and accepting never change.

27
00:01:26,000 --> 00:01:28,000
I defined them once at the beginning of the file.

28
00:01:28,000 --> 00:01:35,000
So our finite state machine simulator is really just recursive in the input and the current state,

29
00:01:35,000 --> 00:01:38,000
and that matches our intuition because those are the 2 fingers I was using

30
00:01:38,000 --> 99:59:59,999
to work it out on paper.
