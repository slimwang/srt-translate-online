1
00:00:00,410 --> 00:00:03,440
A Monolithic structure definitely gives you protection,

2
00:00:03,440 --> 00:00:06,220
no questions about that. And we also

3
00:00:06,220 --> 00:00:10,490
argued that it's performant because of the

4
00:00:10,490 --> 00:00:14,720
fact that border crossings are minimized and loss

5
00:00:14,720 --> 00:00:18,060
of locality is minimized. And, and sources

6
00:00:18,060 --> 00:00:21,000
of copying overhead are minimized. All of that

7
00:00:21,000 --> 00:00:22,570
add up to giving good performance for

8
00:00:22,570 --> 00:00:25,680
the Monolithic structure. On the other hand It's

9
00:00:25,680 --> 00:00:29,290
not easily extensible. Any change to

10
00:00:29,290 --> 00:00:32,670
the operating system would require rebuilding

11
00:00:32,670 --> 00:00:36,200
the monolithic structure with the changed

12
00:00:36,200 --> 00:00:39,300
characteristic of the system service. So, one

13
00:00:39,300 --> 00:00:45,796
size fits all is what you get with a monolithic structure. A DOS-like structure

14
00:00:45,796 --> 00:00:52,260
is performant because there is no separation between the application and

15
00:00:52,260 --> 00:00:56,090
the operating system and, therefore, an application

16
00:00:56,090 --> 00:00:59,410
can execute system services at the same speed

17
00:00:59,410 --> 00:01:02,490
as it would execute a procedure call that

18
00:01:02,490 --> 00:01:05,190
is part of that application itself. And it's

19
00:01:05,190 --> 00:01:09,140
also easily extensible because you can build

20
00:01:09,140 --> 00:01:11,960
new versions of system service. To cater to

21
00:01:11,960 --> 00:01:14,700
the needs of specific applications. But on the

22
00:01:14,700 --> 00:01:18,510
other hand, it fails on the safety attribute.

23
00:01:18,510 --> 00:01:21,560
Because there is no boundary separating the

24
00:01:21,560 --> 00:01:24,780
kernel from the user space. A micro-kernel

25
00:01:24,780 --> 00:01:28,040
based operating system also. Pays attention to

26
00:01:28,040 --> 00:01:31,850
protection because it makes sure that the applications

27
00:01:31,850 --> 00:01:34,600
and the servers are in distinct hardware

28
00:01:34,600 --> 00:01:37,730
address spaces separated from the microkernel itself

29
00:01:37,730 --> 00:01:40,420
and it is also easily extensible because

30
00:01:40,420 --> 00:01:43,860
you can have different servers that provide the

31
00:01:43,860 --> 00:01:50,600
same service. But differently to cater to the needs of the application but it

32
00:01:50,600 --> 00:01:54,390
may have performance flaws because of the

33
00:01:54,390 --> 00:01:57,170
need for so many border crossing that might

34
00:01:57,170 --> 00:02:03,350
be needed to go between applications and the server processes. Having said that

35
00:02:03,350 --> 00:02:08,930
I want to give a note of caution, on the surface it may appear That the

36
00:02:08,930 --> 00:02:14,400
microkernel based approach may not be performant because of the potential for

37
00:02:14,400 --> 00:02:19,940
frequent border crossings. I'll have a surprise for you on this aspect when we

38
00:02:19,940 --> 00:02:26,230
discuss the L3 microkernel later on in this course module where it is shown that

39
00:02:26,230 --> 00:02:33,860
a microkernel. Can be made performant by careful implementation, that's the key.

40
00:02:33,860 --> 00:02:36,720
I'll leave you with that thought, but we'll come back

41
00:02:36,720 --> 00:02:39,970
to a micro kernal base design using L3 later on.
