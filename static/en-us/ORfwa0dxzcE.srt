1
00:00:00,450 --> 00:00:04,250
As operating system designers, the natural question

2
00:00:04,250 --> 00:00:07,010
that comes up is, okay, all this sounds

3
00:00:07,010 --> 00:00:09,050
good. But do I lose out on

4
00:00:09,050 --> 00:00:13,570
performance for the convenience of component-based design? This

5
00:00:13,570 --> 00:00:18,630
is the same question that came up when we wanted to go for a microkernel-based

6
00:00:18,630 --> 00:00:21,920
design, away from a monolithic design of

7
00:00:21,920 --> 00:00:25,520
an operating system. The Cornell experiment takes it

8
00:00:25,520 --> 00:00:28,880
one step further and argues for

9
00:00:28,880 --> 00:00:32,910
synthesizing individual subsystems of an operating system

10
00:00:32,910 --> 00:00:35,920
from modular components. Just like putting

11
00:00:35,920 --> 00:00:38,440
together lego blocks to get the desired

12
00:00:38,440 --> 00:00:44,580
functionality. I encourage you to read the paper from Cornell in full. That

13
00:00:44,580 --> 00:00:46,860
shows that this methodology, applied to

14
00:00:46,860 --> 00:00:50,820
one specific subsystem, results in a performance

15
00:00:50,820 --> 00:00:53,670
competitive implementation of the protocol

16
00:00:53,670 --> 00:00:56,920
stack, compared to a monolithic implementation.
