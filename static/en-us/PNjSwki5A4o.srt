1
00:00:00,000 --> 00:00:02,000
Let's move on a little bit.

2
00:00:02,000 --> 00:00:04,000
We now know how to make basic requests with urlLib.

3
00:00:04,000 --> 00:00:07,000
You guys are going to become very friendly with that module.

4
00:00:07,000 --> 00:00:11,000
I'd like to talk a little bit now is what we actually send over the wire between two computers.

5
00:00:11,000 --> 00:00:14,000
We could have our servers--in this case we'll use the Hipmunk example.

6
00:00:14,000 --> 00:00:17,000
We could have our servers make our request to Amtrak

7
00:00:17,000 --> 00:00:20,000
and receive HTML back from them.

8
00:00:20,000 --> 00:00:23,000
Then we can actually look into that HTML on Hipmunk servers.

9
00:00:23,000 --> 00:00:27,000
That's actually what we do, but this is suboptimal.

10
00:00:27,000 --> 00:00:30,000
Let me show you why. You've written some HTML at this point.

11
00:00:30,000 --> 00:00:33,000
You know that it's somewhat complex.

12
00:00:33,000 --> 00:00:35,000
It's not very regular.

13
00:00:35,000 --> 00:00:38,000
You've got things like--browsers are very forgiving.

14
00:00:38,000 --> 00:00:42,000
You can write HTML to look something like this where you have an opening tag,

15
00:00:42,000 --> 00:00:45,000
and you have an opening <b>tag to make some text bold,</b>

16
00:00:45,000 --> 00:00:48,000
and you can forget to put the closing tag, put your closing tag,

17
00:00:48,000 --> 00:00:52,000
and the browser will actually probably render it appropriately. At least some browsers will.

18
00:00:52,000 --> 00:00:58,000
If you were a computer trying to parse this, you're expecting a <b>tag to have a</b> tag.

19
00:00:58,000 --> 00:01:01,000
All of a sudden you can get lost in this loop.

20
00:01:01,000 --> 00:01:04,000
Depending on how complicated you want to make your parser,

21
00:01:04,000 --> 00:01:08,000
maybe you can recover from this like browsers do or maybe not.

22
00:01:08,000 --> 00:01:13,000
But HTML is not an ideal language for computer-to-computer communication.

23
00:01:13,000 --> 00:01:17,000
It turns on Amtrak, we actually get their HTML, and I'm going to show you some

24
00:01:17,000 --> 00:01:20,000
of the heartache we have to go through to actually parse this HTML.

25
00:01:20,000 --> 00:01:24,000
Remember I gave you some regular expressions during homework 2

26
00:01:24,000 --> 00:01:29,000
to verify your quiz answers--to verify a username and an email.

27
00:01:29,000 --> 00:01:32,000
These are a bunch of regular expressions that we actually use on Hipmunk

28
00:01:32,000 --> 00:01:34,000
to parse Amtrak's HTML.

29
00:01:34,000 --> 00:01:36,000
As you can see, this is just a wall of text.

30
00:01:36,000 --> 00:01:39,000
This is extremely error-prone,

31
00:01:39,000 --> 00:01:44,000
and you can see like we're actually looking for div with class availability.

32
00:01:44,000 --> 00:01:48,000
We're going to look for the span whose ID is service_span.

33
00:01:48,000 --> 00:01:51,000
This is what a time looks like. This is really nutso.

34
00:01:51,000 --> 00:01:53,000
This is not the ideal way of doing things.

35
00:01:53,000 --> 00:01:56,000
In a perfect world, we wouldn't have to hit Amtrak's webpage.

36
00:01:56,000 --> 00:02:01,000
We would instead use an API that speaks a language more appropriate for this task.

37
00:02:01,000 --> 00:02:05,000
Suck a language, if language is the correct word, might be XML.

38
00:02:05,000 --> 00:02:11,000
XML is what actually invented in the late '90s specifically for this purpose--

39
00:02:11,000 --> 00:02:16,000
to have a regular way of expression data between computer systems.

40
00:02:16,000 --> 00:02:21,000
I can't claim to be the biggest fan of XML, but it is fairly easy to parse.

41
00:02:21,000 --> 00:02:23,000
In fact, you've seen a lot of it.

42
00:02:23,000 --> 00:02:25,000
So this is what some XML might look like.

43
00:02:25,000 --> 00:02:29,000
If you're thinking this looks an awful lot like HTML, you are correct.

44
00:02:29,000 --> 00:02:33,000
We have our first line, which is basically the document type.

45
00:02:33,000 --> 00:02:35,000
We have the same thing in HTML.

46
00:02:35,000 --> 00:02:39,000
Remember we've been using HTML5, so our doc type looks something like this.

47
00:02:39,000 --> 00:02:42,000
It's just the first sign that says what format the rest of the document is.

48
00:02:42,000 --> 00:02:47,000
Now, the reason both HTML and XML have doc types and this tag structure

49
00:02:47,000 --> 00:02:51,000
is because they actually share a common ancestor in SGML,

50
00:02:51,000 --> 00:02:53,000
which was invented in the '80s.

51
00:02:53,000 --> 00:02:58,000
Now, the main difference between XML and HTML is in XML every tag

52
00:02:58,000 --> 00:03:00,000
has to have a closing tag.

53
00:03:00,000 --> 00:03:02,000
We've got opening , closing .

54
00:03:02,000 --> 00:03:04,000
The tag format is the same.

55
00:03:04,000 --> 00:03:10,000
We've still got out less thans and our greater thans and our slashes to indicate a closing tag.

56
00:03:10,000 --> 00:03:13,000
But we have no void tags in XML.

57
00:03:13,000 --> 00:03:16,000
Remember in HTML we could have the tag for putting in a line break,

58
00:03:16,000 --> 00:03:20,000
and we never had a closing tag.

59
00:03:20,000 --> 00:03:24,000
That's because HTML doesn't require all tags to close.

60
00:03:24,000 --> 00:03:29,000
We have this notion of a void tag. The line break was an example of one of those.

61
00:03:29,000 --> 00:03:32,000
It's just a opening tag. XML has nothing like that .

62
00:03:32,000 --> 00:03:35,000
Now, if you want a tag that has no content in XML,

63
00:03:35,000 --> 00:03:37,000
you could do something like this.

64
00:03:37,000 --> 00:03:43,000
You could include a closing slash before you're greater than symbol.

65
00:03:43,000 --> 00:03:49,000
In fact, there is actually a doc type for HMTL called "XHTML,"

66
00:03:49,000 --> 00:03:54,000
which basically says my HTML document is actually going to be valid XML.

67
00:03:54,000 --> 00:03:58,000
Instead of doing void tags with no closing slash,

68
00:03:58,000 --> 00:04:01,000
you include the closing slash before the greater than.

69
00:04:01,000 --> 00:04:03,000
You'll see that a lot in XML.

70
00:04:03,000 --> 00:04:06,000
The whole point of what I'm trying to say is that XML is very similar to HTML,

71
00:04:06,000 --> 00:04:13,000
but it's more rigorous. It's similar because they share the same ancestor.

72
00:04:13,000 --> 00:04:16,000
Now, I'm not going to spend a whole lot more time on the structure of XML,

73
00:04:16,000 --> 00:04:19,000
because we spent so much time on HTML already.

74
00:04:19,000 --> 00:04:22,297
Just keep in mind that it's similar to HTML, but a little bit more consistent.
