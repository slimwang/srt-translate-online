1
00:00:00,360 --> 00:00:03,540
So the iron law of performance can easily

2
00:00:03,540 --> 00:00:07,080
be applied when we spend a constant number of

3
00:00:07,080 --> 00:00:10,010
cycles for each instruction. But how about unequal

4
00:00:10,010 --> 00:00:12,970
instruction execution times? Meaning we spend different numbers of

5
00:00:12,970 --> 00:00:16,120
cycles for different instructions. So this is our

6
00:00:16,120 --> 00:00:19,366
original item law of performance. The number of instructions

7
00:00:19,366 --> 00:00:21,966
per program, times the number of cycles per instruction,

8
00:00:21,966 --> 00:00:25,504
times the clock cycle time. If we have different

9
00:00:25,504 --> 00:00:29,736
clock cycles per instruction, this part becomes a sum

10
00:00:29,736 --> 00:00:33,855
for all types of instructions. The instruction count of that

11
00:00:33,855 --> 00:00:36,295
type that we have to execute times the cycles per

12
00:00:36,295 --> 00:00:39,650
instruction for that type of instruction. Note that, in the

13
00:00:39,650 --> 00:00:42,530
original iron log performance, this was really how many

14
00:00:42,530 --> 00:00:45,450
cycles we need to execute the program. This is how

15
00:00:45,450 --> 00:00:48,556
many cycles we need for each type of instructions. All

16
00:00:48,556 --> 00:00:50,602
of them in a program, and the sum here is

17
00:00:50,602 --> 00:00:53,280
simply summing up over all types of instructions.

18
00:00:53,280 --> 00:00:55,090
So this is still the number of cycles we

19
00:00:55,090 --> 00:00:57,760
execute in a program. And we still have the

20
00:00:57,760 --> 00:01:00,530
clock cycle time here. So the new CPU time

21
00:01:00,530 --> 00:01:02,740
here is like this. So if we have

22
00:01:02,740 --> 00:01:06,770
different CPI, meaning different cycles per instruction for different

23
00:01:06,770 --> 00:01:09,435
types of instructions, then we need to do this,

24
00:01:09,435 --> 00:01:12,220
and just multiply that with the clock cycle time.
