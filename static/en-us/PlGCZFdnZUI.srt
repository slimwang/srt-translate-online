1
00:00:00,000 --> 00:00:03,000
Well, let's go write out the answer together in the interpreter.

2
00:00:03,000 --> 00:00:06,000
I'm going to start by defining my function small_words,

3
00:00:06,000 --> 00:00:08,000
and it takes a list of words as input.

4
00:00:08,000 --> 00:00:10,000
I definitely want to iterate over each one.

5
00:00:10,000 --> 00:00:14,000
The problem definition said that we want those involving at most 3 letters,

6
00:00:14,000 --> 00:00:16,000
so those are the small words that we yield.

7
00:00:16,000 --> 00:00:19,000
Now I'm going to add some debugging to see if I've gotten the right answer.

8
00:00:19,000 --> 00:00:22,000
I'm going to use one of these list comprehensions because I love them so much.

9
00:00:22,000 --> 00:00:26,000
I'm going to print out each word that's in small_words

10
00:00:26,000 --> 00:00:28,000
applied to "The quick brown fox."

11
00:00:28,000 --> 00:00:30,000
I'm just sort of eyeballing it.

12
00:00:30,000 --> 00:00:35,000
"The" and "fox" are at most 3 letters, so I hope to see these 2 in the answer,

13
00:00:35,000 --> 00:00:37,000
but "quick" and "brown" are too big to make the final cut,

14
00:00:37,000 --> 00:00:40,000
and that's exactly what we got out.

15
00:00:40,000 --> 00:00:44,000
Recall that our goal was to enumerate all the strings in a grammar.

16
00:00:44,000 --> 00:00:47,000
That was our super slow approach to check and see

17
00:00:47,000 --> 00:00:49,000
if HTML or JavaScript was valid.

18
00:00:49,000 --> 00:00:52,000
Well, unsurprisingly, these generators

19
00:00:52,000 --> 00:00:55,000
are the trick we're going to use to enumerate a lot of strings

20
00:00:55,000 --> 99:59:59,999
in a concise manner.
