1
00:00:00,300 --> 00:00:03,927
So after the initial warm-up period, we have seen,

2
00:00:03,927 --> 00:00:08,362
that the 2-bit history predictor will start predicting this,

3
00:00:08,362 --> 00:00:13,750
with 100% accuracy. We also see, that this predictor is really wasting

4
00:00:13,750 --> 00:00:18,540
one of its four 2-bit counters because, it's only using three of the four,

5
00:00:18,540 --> 00:00:23,110
to predict this pattern. And the fourth one simply never gets used. So

6
00:00:23,110 --> 00:00:25,930
we have it in the entry, but we really didn't need it.

7
00:00:25,930 --> 00:00:29,940
Now let's see what happens if this same 2-bit history predictor is trying to

8
00:00:29,940 --> 00:00:35,300
predict, the alternating pattern, the not taken taken, not taken taken, and so

9
00:00:35,300 --> 00:00:41,080
on. For that pattern, when we are trying to predict this non-taken here,

10
00:00:41,080 --> 00:00:47,890
we're seeing a history of 01. That means the counter 1, will be counting down.

11
00:00:47,890 --> 00:00:52,030
When we are trying to predict this, we have a history of 10, and

12
00:00:52,030 --> 00:00:57,180
when we have 10, that means counter 2. Is counting up. For this,

13
00:00:57,180 --> 00:01:02,670
we again have a history of 01. So, counter 1 counts down. And

14
00:01:02,670 --> 00:01:07,423
when we try to predict this, we have 10, in history. So counter 2,

15
00:01:07,423 --> 00:01:12,213
is counting up. As you can see, for this pattern, counter 1 and

16
00:01:12,213 --> 00:01:16,150
counter 2 will very soon start predicting correctly. And there are really,

17
00:01:16,150 --> 00:01:20,430
only two of these counters used. One because the history can be 01, and

18
00:01:20,430 --> 00:01:25,540
one because the history can be 10. We never can see the history of 00,

19
00:01:25,540 --> 00:01:30,690
or 11, which means, after the initial warm-up period, this predictor will also

20
00:01:30,690 --> 00:01:34,240
predict this with 100% accuracy. We have already seen that the 1-bit

21
00:01:34,240 --> 00:01:39,040
history predictor can predict this with a 100% accuracy, which is good.

22
00:01:39,040 --> 00:01:44,590
But, this predictor is not using half of its 2-bit predictor entries. So

23
00:01:44,590 --> 00:01:47,668
basically, in the entry that corresponds to this branch, we are really

24
00:01:47,668 --> 00:01:52,800
using only two of the four 2-bit counters, so the waste is larger. In general,

25
00:01:52,800 --> 00:01:57,930
an N-bit history predictor, will correctly predict all patterns of length.

26
00:01:57,930 --> 00:02:02,220
Less than, or equal to, N plus 1. We have seen that a single bit predictor,

27
00:02:02,220 --> 00:02:08,030
can predict correctly the pattern that is of line two. A 2-bit predictor

28
00:02:08,030 --> 00:02:11,700
can predict correctly a pattern of length three and also of length two.

29
00:02:11,700 --> 00:02:15,450
Both of them, of course, can predict a pattern of length one, which amounts to

30
00:02:15,450 --> 00:02:20,310
always taken, or always not taken. In general, an N-bit history predictor,

31
00:02:20,310 --> 00:02:25,580
will predict all patterns of length, its history size, plus one, or

32
00:02:25,580 --> 00:02:31,023
less than that. However, the N-bit history predictor, will cost us,

33
00:02:31,023 --> 00:02:37,850
the N-bit of history plus, 2 to the Nth, 2-bit counters. Per entry.

34
00:02:37,850 --> 00:02:43,580
Each branch will have an entry that we index into that will be of this size.

35
00:02:43,580 --> 00:02:45,900
So the entries become very large. For example,

36
00:02:45,900 --> 00:02:51,240
if it's a 10-bit history we're talking about several kilobits worth of stuff,

37
00:02:51,240 --> 00:02:55,250
for a single branch to be predicted. If we have, for example,

38
00:02:55,250 --> 00:03:00,210
a loop that has something like a. Loop out branch and a loop back branch.

39
00:03:00,210 --> 00:03:05,330
That will spend two of these entries. And, how about the waste? Most of

40
00:03:05,330 --> 00:03:11,160
the 2-bit counters that we have in our entry will be wasted. Why? Well because,

41
00:03:11,160 --> 00:03:17,950
if we have for example,. A 10-bit history, there are 1,024 entries.

42
00:03:17,950 --> 00:03:22,710
We can only predict patterns that are up to 11th in length, and

43
00:03:22,710 --> 00:03:28,140
a pattern of length 11, will have 11 possible histories at most. So

44
00:03:28,140 --> 00:03:32,963
of the more than a thousand histories, we will really be using. Only up to 11 of

45
00:03:32,963 --> 00:03:38,740
them, for accurate prediction. The rest of the histories are mainly, waste. So

46
00:03:38,740 --> 00:03:43,090
as as we can see, by increasing the N here which is the length of the history,

47
00:03:44,170 --> 00:03:47,990
we're improving, our ability to predict longer and

48
00:03:47,990 --> 00:03:52,410
longer patterns. But, our predictor becomes very expensive,

49
00:03:52,410 --> 00:03:57,490
very quickly and much of the cost that we are adding is waste. So

50
00:03:57,490 --> 00:04:02,330
the question is, why would we want to have N large? Why not just settle for

51
00:04:02,330 --> 00:04:06,050
something like, patterns of length three? Well it turns out,

52
00:04:06,050 --> 00:04:11,420
that a very common type of a pattern, is a loop, where we have something like,

53
00:04:11,420 --> 00:04:15,620
this would be. Don't exit the loop, don't exit the loop, exit the loop.

54
00:04:15,620 --> 00:04:20,019
So it's a tri-iteration loop, and then we repeat that loop many times. So for

55
00:04:20,019 --> 00:04:23,150
example, in order to do something like a eight iteration loop,

56
00:04:23,150 --> 00:04:28,550
we have to have a pattern, of eight or nine length. Which means we need,

57
00:04:28,550 --> 00:04:33,260
an 7 or 8-bit history in order to predict that successfully. So

58
00:04:33,260 --> 00:04:37,550
we do want to have a long history, but we'd rather have it,

59
00:04:37,550 --> 00:04:43,760
without this huge cost and without the huge waste that the cost comes with.
