1
00:00:00,150 --> 00:00:03,520
So far in this final exam we've written a lexer, a

2
00:00:03,520 --> 00:00:06,500
parser and now in this problem we're going to write an

3
00:00:06,500 --> 00:00:09,330
interpreter. However, we're mixing it up a bit and we're not

4
00:00:09,330 --> 00:00:12,410
going to write an interpreter for a programming language per se,

5
00:00:12,410 --> 00:00:15,630
but rather for a market. We're going to be given a

6
00:00:15,630 --> 00:00:19,230
list of how much money people have, things that they want

7
00:00:19,230 --> 00:00:21,660
to buy, and things they're willing to sell. And we're going

8
00:00:21,660 --> 00:00:25,560
to simulate the market and the result is going to be

9
00:00:25,560 --> 00:00:27,790
the amount of money that people have left over. So

10
00:00:27,790 --> 00:00:30,580
let's take a look at an example input into our interpreter.

11
00:00:30,580 --> 00:00:32,830
So here I have our abstract syntax tree for our

12
00:00:32,830 --> 00:00:37,610
market. At the beginning we declare how much money Klaus and

13
00:00:37,610 --> 00:00:41,170
Andreas, are two participants in the marketplace, have. And then

14
00:00:41,170 --> 00:00:43,630
we talk about what are they willing to buy and sell.

15
00:00:43,630 --> 00:00:47,300
Within each element, we generally say, who is the person

16
00:00:47,300 --> 00:00:50,660
that this element applies to. The what, this element is dealing

17
00:00:50,660 --> 00:00:53,570
with, and then some amount of money. So for the

18
00:00:53,570 --> 00:00:59,530
has elements, we're saying Klaus has 100 coins. And we're saying

19
00:00:59,530 --> 00:01:03,386
Andreas has 50 coins. Down here we're saying Klaus wants

20
00:01:03,386 --> 00:01:04,690
to buy a sheep for 50. He also wants to buy

21
00:01:09,150 --> 00:01:12,470
another sheep for 50, you can have more than 1. Andreas

22
00:01:12,470 --> 00:01:15,360
wants to sell a sheep for 50, and he wants to sell

23
00:01:15,360 --> 00:01:18,310
another sheep for 50. So Klaus wants to buy two sheep, each

24
00:01:18,310 --> 00:01:21,670
for 50. Andreas wants to sell two sheep, each for 50. We

25
00:01:21,670 --> 00:01:23,470
should probably be able to make a deal here. Note that

26
00:01:23,470 --> 00:01:27,010
after the has elements, the buys and sells can be in any

27
00:01:27,010 --> 00:01:30,610
order. So let's step through this by hand and see if we

28
00:01:30,610 --> 00:01:34,460
can come up with an algorithm for which to write our interpreter.

29
00:01:34,460 --> 00:01:38,010
So here we're saying Klaus has 100 coins. We should probably

30
00:01:38,010 --> 00:01:40,960
keep track of that since the output of the entire interpretation

31
00:01:40,960 --> 00:01:44,460
is going to be a list, of how much money each

32
00:01:44,460 --> 00:01:47,440
person has. Or actually, we're going to store it as a dictionary, but,

33
00:01:47,440 --> 00:01:50,700
so let's do that. I just wrote Klaus for short. So,

34
00:01:50,700 --> 00:01:53,250
we say Klaus has 100, okay. We are done with this,

35
00:01:53,250 --> 00:01:56,480
we don't need it anymore. This next line says Andreas has

36
00:01:56,480 --> 00:02:00,380
50, so let's update our dictionary. All right, we're done with this.

37
00:02:00,380 --> 00:02:04,500
Now that we see Klaus wants to buy a sheep for 50.

38
00:02:04,500 --> 00:02:07,320
Let's see if anyone is willing to sell a sheep. So, let's

39
00:02:07,320 --> 00:02:10,160
go through the rest of them one by one. So we, in

40
00:02:10,160 --> 00:02:13,350
this next line it's about Klaus buying. We don't really care about

41
00:02:13,350 --> 00:02:16,150
buying, we're looking for selling. Okay, here we have a sell, it

42
00:02:16,150 --> 00:02:18,800
happens to be for a sheep, and it also happens to be

43
00:02:18,800 --> 00:02:22,490
for the exact amount that we want. So, these three elements match

44
00:02:22,490 --> 00:02:25,380
perfectly for what we're looking for. One more thing that we have

45
00:02:25,380 --> 00:02:28,580
to check is to make sure that Klaus has at least

46
00:02:28,580 --> 00:02:31,690
50 coins to make the transaction. So, we look up here,

47
00:02:31,690 --> 00:02:35,010
Klaus has 100, that's more than 50, he's able to afford

48
00:02:35,010 --> 00:02:37,890
it. So, now we do the transaction, Klaus now only has

49
00:02:37,890 --> 00:02:42,960
50 and Andreas now has 100. We should cross off the

50
00:02:42,960 --> 00:02:45,870
elements that we used. Now let's continue the process from the

51
00:02:45,870 --> 00:02:48,470
top again. So, we only have two things left. So, the

52
00:02:48,470 --> 00:02:51,540
next one is Klaus wants to buy a sheep for 50.

53
00:02:51,540 --> 00:02:52,990
We do the same look up, go to the

54
00:02:52,990 --> 00:02:57,150
next element, see sell sheep 50. Yay. Klaus has

55
00:02:57,150 --> 00:03:00,630
at least 50, we're all good. Let's make the

56
00:03:00,630 --> 00:03:03,814
transaction. Okay. We've gone through everything in our parse

57
00:03:03,814 --> 00:03:07,020
tree. There's nothing left to do because there's nothing

58
00:03:07,020 --> 00:03:09,780
left. So, our output is just going to be

59
00:03:09,780 --> 00:03:13,700
this dictionary. So, we went through that algorithm, it's

60
00:03:13,700 --> 00:03:16,760
pretty straightforward, it's a matter of just stepping through what

61
00:03:16,760 --> 00:03:18,970
is available, and doing what we can until there's

62
00:03:18,970 --> 00:03:22,105
nothing left. So, now you're probably thinking, where's the code?

63
00:03:22,105 --> 00:03:24,190
Well, let me show you. So here I have the

64
00:03:24,190 --> 00:03:27,830
solution. It may look a bit messy, but it's actually

65
00:03:27,830 --> 00:03:31,200
pretty straightforward. The first thing we do, is declare the

66
00:03:31,200 --> 00:03:34,180
dictionary that we store how much money that each person

67
00:03:34,180 --> 00:03:38,010
has. And the basic strategy like I went over is

68
00:03:38,010 --> 00:03:42,460
to continue going through elements in the parse tree until

69
00:03:42,460 --> 00:03:44,690
there's nothing left to do, until we didn't do anything and

70
00:03:44,690 --> 00:03:48,330
so nothing's changed and we should just stop. In the case

71
00:03:48,330 --> 00:03:51,570
of the example that I went over, that just meant that

72
00:03:51,570 --> 00:03:53,380
we were out of elements, but it could also be the

73
00:03:53,380 --> 00:03:56,090
case that no one can afford to buy anything, so we

74
00:03:56,090 --> 00:03:59,570
should just stop. So let's assume that there's nothing left to

75
00:03:59,570 --> 00:04:03,700
do, and then only change it once we do something. We're

76
00:04:03,700 --> 00:04:07,870
going to go through each element in our abstract syntax tree.

77
00:04:07,870 --> 00:04:10,270
We're going to pull out who is involved in

78
00:04:10,270 --> 00:04:14,300
the element. That's always the zero index, the first element

79
00:04:14,300 --> 00:04:20,230
in the tuple. We're going to do what kind of type it is, okay. If it's a has. So

80
00:04:20,230 --> 00:04:22,290
those are going to go first. We're going to

81
00:04:22,290 --> 00:04:25,510
put that person in our environment. And then what I'm

82
00:04:25,510 --> 00:04:29,650
doing right here, is we're just marking off it

83
00:04:29,650 --> 00:04:33,090
as skip. We're changing the type to skip. Skip isn't

84
00:04:33,090 --> 00:04:35,350
has, buy or sell, so we're just going to ignore

85
00:04:35,350 --> 00:04:39,290
it. This is equivalent to me crossing it off. An alternative

86
00:04:39,290 --> 00:04:43,440
way of doing a similar process would be, to recursing onto

87
00:04:43,440 --> 00:04:46,360
the parse tree and removing parse tree elements, as we use

88
00:04:46,360 --> 00:04:49,480
them. But this is, just as easy. If we're in

89
00:04:49,480 --> 00:04:52,740
a buy scenario, if we find an element for which we

90
00:04:52,740 --> 00:04:55,520
want to buy, we're going to take out what we want

91
00:04:55,520 --> 00:04:58,160
to buy and how much it's for. And then we're going to

92
00:04:58,160 --> 00:05:00,430
go through the abstract syntax tree again. If

93
00:05:00,430 --> 00:05:04,110
we find an element in the abstract syntax tree

94
00:05:04,110 --> 00:05:06,990
that is a sell, it's what we're looking for.

95
00:05:06,990 --> 00:05:09,430
I can afford it for that price, and it's

96
00:05:09,430 --> 00:05:10,860
the price that I want to pay for

97
00:05:10,860 --> 00:05:15,460
it. We're going to do the transaction. This involves skipping,

98
00:05:15,460 --> 00:05:18,680
crossing off. Both elements in the parse tree that

99
00:05:18,680 --> 00:05:23,460
are involved in the transaction. Subtracting off the new

100
00:05:23,460 --> 00:05:27,410
cost, and adding that amount of money to the person that sold

101
00:05:27,410 --> 00:05:31,340
it. And we're also here putting finished equals false, because we did

102
00:05:31,340 --> 00:05:35,280
something. The state has changed and we should do another pass. And

103
00:05:35,280 --> 00:05:38,950
once we're done, we just return the dictionary that we started with.
