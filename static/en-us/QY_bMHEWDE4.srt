1
00:00:00,330 --> 00:00:04,158
Okay let's see out memory ordering quiz solution,

2
00:00:04,158 --> 00:00:06,681
this load is still sent to memory in

3
00:00:06,681 --> 00:00:09,378
cycle 1, and will come back in cycle

4
00:00:09,378 --> 00:00:13,452
41. The store, however, cannot proceed fully because we

5
00:00:13,452 --> 00:00:18,919
don't know what the value is until cycle 42 ,So in cycle 42, this store finally

6
00:00:18,919 --> 00:00:21,614
figures out what the address and the value

7
00:00:21,614 --> 00:00:25,330
are, so now this load can be considered done.

8
00:00:25,330 --> 00:00:30,310
Because we need to do things in order, that means that only cycle 43,

9
00:00:30,310 --> 00:00:35,373
this load can start going to memory, It's going to take 40 cycles to come

10
00:00:35,373 --> 00:00:41,020
back, so in cycle 83 the value comes back from memory; at that point.

11
00:00:41,020 --> 00:00:45,942
This store can finish at cycle 84, inside cycle 85

12
00:00:45,942 --> 00:00:50,650
that means that only then this load can go to memory,

13
00:00:50,650 --> 00:00:54,502
It's going to be cycle 125 by the time, it

14
00:00:54,502 --> 00:00:58,354
come back and finally the final store can be

15
00:00:58,354 --> 00:01:02,160
done in cycle 126. As you can see, it

16
00:01:02,160 --> 00:01:04,840
took almost three times as long in this case

17
00:01:04,840 --> 00:01:09,870
to do this as it did when we were trying to do things out of order. So there

18
00:01:09,870 --> 00:01:12,960
is a huge advantage in trying to reorder load

19
00:01:12,960 --> 00:01:15,820
store instructions, but it caries a risk of having

20
00:01:15,820 --> 00:01:19,020
to recover from basically loading the wrong value from memory

21
00:01:19,020 --> 00:01:20,930
because we should have loaded the value from the store.
