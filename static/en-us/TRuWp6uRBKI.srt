1
00:00:00,090 --> 00:00:03,370
So the answer is, only the second and the third

2
00:00:03,370 --> 00:00:06,360
are equivalent. This is a little surprising. This was kind

3
00:00:06,360 --> 00:00:09,646
of a tricky question. So the reason the first one

4
00:00:09,646 --> 00:00:13,430
is not, if x is seven or greater, well, then seven

5
00:00:13,430 --> 00:00:16,750
mod seven has the value zero. That's not the same

6
00:00:16,750 --> 00:00:19,580
as the x that we started with. And that's the

7
00:00:19,580 --> 00:00:22,469
case also if we have eight. Eight module seven has

8
00:00:22,469 --> 00:00:25,300
the value one. Which is different from what we started with.

9
00:00:26,460 --> 00:00:29,190
When the modulo is greater than the possible value of

10
00:00:29,190 --> 00:00:31,840
x, and we said, x could be only between zero and

11
00:00:31,840 --> 00:00:34,300
10, well, then, the result is always the same as

12
00:00:34,300 --> 00:00:39,590
x. The third question, when we map x to its character

13
00:00:39,590 --> 00:00:41,810
value, and then we take the order of that, we'll

14
00:00:41,810 --> 00:00:46,020
char an order inverses, so that's equivalent. You would think that

15
00:00:46,020 --> 00:00:48,570
would in the other direction and the reason it doesn't is

16
00:00:48,570 --> 00:00:52,200
because the input to ord must be a one letter string.

17
00:00:52,200 --> 00:00:55,210
If the input's not a single character, then ord produces

18
00:00:55,210 --> 00:00:58,410
an error. So let's see that in the Python interpreter, if

19
00:00:58,410 --> 00:01:02,500
we print the result of ord where the input is a

20
00:01:02,500 --> 00:01:04,980
number and we said x was a number between zero and

21
00:01:04,980 --> 00:01:07,840
three. Well, that gives us an error. And it gives an

22
00:01:07,840 --> 00:01:10,280
error, because ord expects a string of length one, but the

23
00:01:10,280 --> 00:01:13,440
input was an integer. There is a function that allows us

24
00:01:13,440 --> 00:01:17,390
to turn numbers into strings. And that's the str function that

25
00:01:17,390 --> 00:01:21,260
takes a number and gives us a string corresponding

26
00:01:21,260 --> 00:01:24,460
to that number. So let's see what str of three

27
00:01:24,460 --> 00:01:26,820
gives us, that will give us the string three,

28
00:01:26,820 --> 00:01:28,720
we can't see in output here that it is actually

29
00:01:28,720 --> 00:01:31,230
a string, but it is a string, and we

30
00:01:31,230 --> 00:01:35,070
can actually use order on the result there. When we

31
00:01:35,070 --> 00:01:39,430
run this, what we get is 51, not the

32
00:01:39,430 --> 00:01:43,070
three that we passed in and that's because the ord

33
00:01:43,070 --> 00:01:46,945
of the character three is 51.
