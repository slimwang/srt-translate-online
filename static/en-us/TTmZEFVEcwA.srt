1
00:00:00,370 --> 00:00:04,150
One reason that we use four by four matrices to store transforms is that a

2
00:00:04,150 --> 00:00:08,590
single matrix can hold any number of transforms at once. As an example, consider

3
00:00:08,590 --> 00:00:12,572
object three D's rotation paratmeter. Here is a snipet of code from the oil

4
00:00:12,572 --> 00:00:17,830
angler demo. The airplane's three rotation axis are already set. This means that

5
00:00:17,830 --> 00:00:22,520
the airplane is first rotated around its z axis then its y axis, then x.

6
00:00:22,520 --> 00:00:26,556
Internally a transform matrix is made for each rotation. Then these are

7
00:00:26,556 --> 00:00:31,629
multiplied together. Matrix multiplication works like this. For each location in

8
00:00:31,629 --> 00:00:35,212
the resulting matrix, you take the corresponding row of the first matrix.

9
00:00:35,212 --> 00:00:38,821
[inaudible] And the column of the second matrix, and perform a dot product

10
00:00:38,821 --> 00:00:43,330
between these two. For example, to compute element n two four, I compute the dot

11
00:00:43,330 --> 00:00:47,600
product of the fourth row of the first matrix, and the second column of the

12
00:00:47,600 --> 00:00:51,890
second matrix. This gives this set of terms here, added together gives n two

13
00:00:51,890 --> 00:00:56,020
four, 16 dot products later and you have the resulting matrix. To multiply

14
00:00:56,020 --> 00:01:01,924
together our three rotation matrices. We can start at either end. Multiplying Rx

15
00:01:01,924 --> 00:01:06,730
by Ry or Ry by Rz. I've decided to start with Ry and Rz. Multiplying these

16
00:01:06,730 --> 00:01:10,676
together we get some temporary matrix U. We can then multiply together the X

17
00:01:10,676 --> 00:01:15,775
rotation matrix by this temporary matrix. This gives us another matrix call it Q

18
00:01:15,775 --> 00:01:19,858
which consists of all three rotation matrices multiplied together. This

19
00:01:19,858 --> 00:01:23,764
resulting matrix Q can then be used to transform coordinates when an object

20
00:01:23,764 --> 00:01:27,608
coordinate is transformed by this single matrix the coordinate in fact is

21
00:01:27,608 --> 00:01:31,638
rotated by the three rotation matrices in turn it's clearly more efficient to

22
00:01:31,638 --> 00:01:36,238
use a single matrix than three. The scale and translation parameters in the

23
00:01:36,238 --> 00:01:40,240
object 3-d class do the same thing. They create matrices and these all get

24
00:01:40,240 --> 00:01:44,592
multiplied together. Here's the full sequence of transforms that happen for an

25
00:01:44,592 --> 00:01:48,835
object 3-d when using its parameters: scale, the 3 rotations, and translate.

26
00:01:48,836 --> 00:01:52,563
Internally, these matrices are all multiplied together to give a single

27
00:01:52,563 --> 00:01:57,430
resulting matrix m. The parameter in the object 3D class, is, in fact, called

28
00:01:57,430 --> 00:02:01,550
matrix. You can now see why I've been listing the order of matrices as from

29
00:02:01,550 --> 00:02:04,956
right to left. As this is the order we use for multiplying them together.

30
00:02:04,956 --> 00:02:09,363
Multiplying matrices together like this is called concatenation.
