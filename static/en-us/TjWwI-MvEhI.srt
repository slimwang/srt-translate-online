1
00:00:00,160 --> 00:00:02,130
So let's test our new hash function. See if it does

2
00:00:02,130 --> 00:00:05,300
better than the bad string hash function we defined earlier. We're going

3
00:00:05,300 --> 00:00:08,200
to use the same test hash function we defined before, that

4
00:00:08,200 --> 00:00:11,430
takes the function as input. So we can pass in either the

5
00:00:11,430 --> 00:00:16,239
original bad string hash function, or the new hash string function

6
00:00:16,239 --> 00:00:19,110
that we hope will work better. A list of keys, and the

7
00:00:19,110 --> 00:00:22,620
size, computing the hash size value for each key. And, records

8
00:00:22,620 --> 00:00:25,170
how many end up in each position. So let's try that again,

9
00:00:25,170 --> 00:00:28,390
we'll use the same example we had before using

10
00:00:28,390 --> 00:00:31,950
the words from Sherlock Holmes. And so we'll initialize

11
00:00:31,950 --> 00:00:34,830
words, as all with words in the page that

12
00:00:34,830 --> 00:00:37,020
is the Adventures of Sherlock Holmes, that we load

13
00:00:37,020 --> 00:00:39,880
from the Web. So, first we'll try this again

14
00:00:39,880 --> 00:00:43,450
with the old hash function, bad string hash, and

15
00:00:43,450 --> 00:00:47,040
obtain the counts, and let's print those out, remember

16
00:00:47,040 --> 00:00:50,580
what those look like. So it's a pretty bad distribution,

17
00:00:50,580 --> 00:00:56,580
as we saw before, ranging from 725 all the way up to over 2,000, in one

18
00:00:56,580 --> 00:00:59,348
bucket. Now, let's try it with the new

19
00:00:59,348 --> 00:01:05,040
hash function, instead of bad_hash_string. We'll path in

20
00:01:05,040 --> 00:01:07,760
plain hash string. We're using the same words,

21
00:01:07,760 --> 00:01:10,070
the same number of buckets. And we'll see

22
00:01:10,070 --> 00:01:12,720
the distribution now. It looks a lot better,

23
00:01:12,720 --> 00:01:15,450
right. There's no values under a thousand now,

24
00:01:15,450 --> 00:01:19,960
there's now values over the highest one would be 1,363

25
00:01:19,960 --> 00:01:23,740
in the first bucket. So, lets look at that graphically.

26
00:01:23,740 --> 00:01:26,590
Here's what we had before. With a bad hash string

27
00:01:26,590 --> 00:01:29,090
function we can see the size of the buckets varies a

28
00:01:29,090 --> 00:01:30,970
great deal. And we have the red and blue bars

29
00:01:30,970 --> 00:01:34,250
showing some that are too popular, some that are not popular

30
00:01:34,250 --> 00:01:37,950
enough. With the new hash function we have much less

31
00:01:37,950 --> 00:01:40,990
variance. Still not perfect. We'd like to have all the bars

32
00:01:40,990 --> 00:01:44,230
really be as close to the same as possible, but it's really

33
00:01:44,230 --> 00:01:47,550
close. So this is working pretty well. The other thing we can

34
00:01:47,550 --> 00:01:49,900
try is having more buckets. So lets try this one, we are

35
00:01:49,900 --> 00:01:52,570
doing the same thing but this time with a 100 buckets instead of

36
00:01:52,570 --> 00:01:55,990
12 buckets. And we can print that out, and so we see

37
00:01:55,990 --> 00:01:59,910
the results when we have 100 buckets, are pretty good, but certainly

38
00:01:59,910 --> 00:02:03,306
not perfect. We have buckets as small as this one, that has

39
00:02:03,306 --> 00:02:06,890
a 104, and as larger, this one that has a 197. So almost

40
00:02:06,890 --> 00:02:10,008
twice the size of the smallest bucket. It's certainly a hard

41
00:02:10,008 --> 00:02:13,750
problem to build a better hash function. People put a lot of

42
00:02:13,750 --> 00:02:17,670
effort into building good hash functions. As your tables get larger,

43
00:02:17,670 --> 00:02:21,410
it's very important to both have the hash function be efficient. Our

44
00:02:21,410 --> 00:02:23,580
hash string function is not that great, because it does take

45
00:02:23,580 --> 00:02:26,740
a long time to execute. If the string gets longer we have

46
00:02:26,740 --> 00:02:29,510
to go through that loop once for each character. And so there

47
00:02:29,510 --> 00:02:31,940
are better hash functions available. We're not going to look at those

48
00:02:31,940 --> 00:02:36,010
in more detail now. But there'll be some links on the website to documents about

49
00:02:36,010 --> 00:02:38,330
more interesting hash functions. This is going to

50
00:02:38,330 --> 00:02:40,800
work well enough for us though. So before

51
00:02:40,800 --> 00:02:44,360
we go on to actually implementing in a hash table. We're going to have one quiz

52
00:02:44,360 --> 00:02:46,640
to make sure that you understand, why this

53
00:02:46,640 --> 00:02:48,790
is so much better than the original index.
