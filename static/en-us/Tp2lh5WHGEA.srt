1
00:00:00,400 --> 00:00:03,870
Because Quicksilver is a distributed operating system,

2
00:00:03,870 --> 00:00:07,160
IPC both within, and on the local data

3
00:00:07,160 --> 00:00:11,050
network is a crucial component of Quicksilver. And

4
00:00:11,050 --> 00:00:13,770
this picture shows the semantics of the IPC

5
00:00:13,770 --> 00:00:16,750
call. In the kernel, there is a

6
00:00:16,750 --> 00:00:20,166
data structure called service queue. Which is created

7
00:00:20,166 --> 00:00:23,247
by the server that wants the service, request

8
00:00:23,247 --> 00:00:26,054
from clients. And clients make a request, and

9
00:00:26,054 --> 00:00:28,230
the kernel does an upcall to the server to

10
00:00:28,230 --> 00:00:31,264
indicate that this is a client's request. The server

11
00:00:31,264 --> 00:00:35,467
executes the upcall associated with this particular request. When

12
00:00:35,467 --> 00:00:38,517
it completes the request, the completion, goes back into

13
00:00:38,517 --> 00:00:42,170
the service queue. And that is an indication for

14
00:00:42,170 --> 00:00:44,860
the kernel, to give a response back to the

15
00:00:44,860 --> 00:00:47,530
client. So then the synchronous client call where the

16
00:00:47,530 --> 00:00:51,080
client is waiting, til the request is actually serviced,

17
00:00:51,080 --> 00:00:53,230
and the completion response comes back to

18
00:00:53,230 --> 00:00:56,250
the client. And the service queue, is a

19
00:00:56,250 --> 00:00:59,930
global service queue, just like UNIX socket.

20
00:00:59,930 --> 00:01:03,320
So any process, anywhere in the network, which

21
00:01:03,320 --> 00:01:06,080
has knowledge about the service queue, can

22
00:01:06,080 --> 00:01:08,854
connect to it and make requests on the

23
00:01:08,854 --> 00:01:12,230
service queue. And so nearly any server process

24
00:01:12,230 --> 00:01:16,340
in the entire distributed system can service requests

25
00:01:16,340 --> 00:01:18,340
that are coming into the service queue. And

26
00:01:18,340 --> 00:01:21,170
there are some fundamental guarantees provided by Quicksilver

27
00:01:21,170 --> 00:01:25,710
for interprocess communication which includes no loss, or

28
00:01:25,710 --> 00:01:28,970
duplication of requests. So the request comes in,

29
00:01:28,970 --> 00:01:32,540
it will get done exactly once. And it

30
00:01:32,540 --> 00:01:35,952
also ensures that there's no duplication. It also

31
00:01:35,952 --> 00:01:37,895
ensures that there is no loss of the

32
00:01:37,895 --> 00:01:41,668
request. And Quicksilver also takes care of the liability

33
00:01:41,668 --> 00:01:46,365
of the data transfer that is inherent when the client and the server, are

34
00:01:46,365 --> 00:01:49,987
on remote machines. And because the service

35
00:01:49,987 --> 00:01:54,565
queue data structure is globally unique for every

36
00:01:54,565 --> 00:01:58,228
such service. There is location transparency, for

37
00:01:58,228 --> 00:02:01,240
client server interactions. Or in other words

38
00:02:01,240 --> 00:02:06,784
a client does not needs to know, where in the network its particular request is

39
00:02:06,784 --> 00:02:11,793
being serviced. For that is yet another feature of the IPC

40
00:02:11,793 --> 00:02:17,380
guarantee. Or the IPC call can also be asynchronous. What that means is,

41
00:02:17,380 --> 00:02:22,560
the client can make a request asynchronously. And continue with its

42
00:02:22,560 --> 00:02:24,730
own execution, whatever it wants to do, it

43
00:02:24,730 --> 00:02:26,830
doesn't have a block on this. The kernel is

44
00:02:26,830 --> 00:02:29,120
going to take the same action, and that is, if

45
00:02:29,120 --> 00:02:31,940
there is a server that is available, then the

46
00:02:31,940 --> 00:02:35,280
kernel is going to pass it to that server to execute

47
00:02:35,280 --> 00:02:39,410
that request. And, when the completion comes back in, it is

48
00:02:39,410 --> 00:02:42,070
buffered in the service queue by the kernel, waiting for

49
00:02:42,070 --> 00:02:45,230
the client to come back, and ask for the response. So

50
00:02:45,230 --> 00:02:47,840
the client, at some point, has to do a wait

51
00:02:47,840 --> 00:02:50,340
on the service queue to indicate that I'm ready to receive

52
00:02:50,340 --> 00:02:53,640
the response that may have come, back for the request

53
00:02:53,640 --> 00:02:56,980
that I made earlier. And when the client does the wait,

54
00:02:56,980 --> 00:02:59,620
if the original request has already been serviced by

55
00:02:59,620 --> 00:03:01,860
the server, and the response is sitting in the service

56
00:03:01,860 --> 00:03:05,100
queue, then the kernel, will deliver the response to

57
00:03:05,100 --> 00:03:08,950
the client. If not, the client will wait until the

58
00:03:08,950 --> 00:03:11,970
response comes back. So this is the asynchronous client

59
00:03:11,970 --> 00:03:15,460
call, but in either case, as I mentioned earlier. The

60
00:03:15,460 --> 00:03:18,810
IPC guarantees hold that there is no loss of

61
00:03:18,810 --> 00:03:22,145
the request, and there is no duplication of the request.

62
00:03:22,145 --> 00:03:23,780
As you can see from the semantics

63
00:03:23,780 --> 00:03:26,930
that I described just now, that Quicksilver IPC

64
00:03:26,930 --> 00:03:29,460
is very similar to remote procedure call.

65
00:03:29,460 --> 00:03:32,630
In fact, the remote procedure call paradigm was

66
00:03:32,630 --> 00:03:35,600
invented around the same time as the

67
00:03:35,600 --> 00:03:39,190
Quicksilver Operating System. And since all services are

68
00:03:39,190 --> 00:03:42,790
contained in several processes, IPC is fundamental

69
00:03:42,790 --> 00:03:47,463
to Quicksilver. The IPC semantic supported by Quicksilver

70
00:03:47,463 --> 00:03:51,912
allows, multiple servers to wait on a service queue.

71
00:03:51,912 --> 00:03:54,024
And the way they will do that is by making

72
00:03:54,024 --> 00:03:57,416
a call called offer which is essentially saying, I'm willing

73
00:03:57,416 --> 00:04:00,727
to offer my services for this particular service queue. Any

74
00:04:00,727 --> 00:04:03,311
number of servers can make this offer and that

75
00:04:03,311 --> 00:04:06,643
essentially means that if a request comes in, thatany one

76
00:04:06,643 --> 00:04:09,703
of these servers can be called by the kernel depending

77
00:04:09,703 --> 00:04:12,831
on the busyness of the servers with respect to handling

78
00:04:12,831 --> 00:04:15,551
requests that have come in for the service queue

79
00:04:15,551 --> 00:04:19,800
in the past. The client server relationship is interchangeable. For

80
00:04:19,800 --> 00:04:22,140
example, a client can make a call on a

81
00:04:22,140 --> 00:04:26,330
file system server and the file system server in turn

82
00:04:26,330 --> 00:04:29,350
makes a call. To a directory server and a

83
00:04:29,350 --> 00:04:32,070
call to a data server. So, in this case, the

84
00:04:32,070 --> 00:04:35,740
file system becomes the client to the directory server

85
00:04:35,740 --> 00:04:38,130
and the data server. So in that sense, the client

86
00:04:38,130 --> 00:04:41,580
server relationship is interchangeable. Now the only

87
00:04:41,580 --> 00:04:43,280
reason for me to spend some time

88
00:04:43,280 --> 00:04:47,300
describing the IPC semantics of Quicksilver. Is

89
00:04:47,300 --> 00:04:51,750
because the recovery mechanism is tied intimately with

90
00:04:51,750 --> 00:04:57,430
the IPC. And in fact, that's how you can have the cake and eat it too in

91
00:04:57,430 --> 00:05:03,862
Quicksilver. In other words, the client server interactions have to use IPC. So

92
00:05:03,862 --> 00:05:08,738
the recovery mechanism, using transactions, rides

93
00:05:08,738 --> 00:05:12,342
on top of the IPC, essentially bundling

94
00:05:12,342 --> 00:05:15,416
the recovery mechanism with ICP to

95
00:05:15,416 --> 00:05:18,370
get it cheaply. Another interesting footnote I

96
00:05:18,370 --> 00:05:23,668
wanted to mention. The Quicksilver system was first conceived in the early 80s,

97
00:05:23,668 --> 00:05:29,057
but the first paper that described it appeared in 1988. And this is certainly

98
00:05:29,057 --> 00:05:32,876
the difference between academic research and industrial research

99
00:05:32,876 --> 00:05:36,580
at least in the olden days. Academic research,

100
00:05:36,580 --> 00:05:41,020
we tend to shout often. I'm an academic myself, so I take part of the blame.

101
00:05:41,020 --> 00:05:44,300
At least in the olden days, industrial research

102
00:05:44,300 --> 00:05:47,180
used to take the approach of publishing, a

103
00:05:47,180 --> 00:05:50,700
paper, especially in systems designed, when it is

104
00:05:50,700 --> 00:05:54,749
fully cooked. Like I said, Quicksilver was designed and

105
00:05:54,749 --> 00:05:58,849
implemented in the early 80s, 1984 to 88, but the

106
00:05:58,849 --> 00:06:02,455
first paper came out in 1988. But nowadays I have to

107
00:06:02,455 --> 00:06:06,485
mention that everyone is shouting often, which explains the proliferation

108
00:06:06,485 --> 00:06:09,820
of conferences that you see around the country and the world.
