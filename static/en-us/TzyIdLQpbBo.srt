1
00:00:00,000 --> 00:00:02,000
Here's my read all function--this is the code I just took a few minutes to write,

2
00:00:02,000 --> 00:00:05,000
and what you can see is that I've included a couple of assertions.

3
00:00:05,000 --> 00:00:09,000
The first thing that I've asserted that the file descriptor passed 10 is greater than or equal to 0.

4
00:00:09,000 --> 00:00:12,000
These file descriptors are integers usually small ones and they have to be non-negative.

5
00:00:12,000 --> 00:00:17,000
The second thing we're going to assert is that buf that is to say pointing to the block of memory

6
00:00:17,000 --> 00:00:20,000
into which we're going to read data can't be the null pointer and just asserting buf like this

7
00:00:20,000 --> 00:00:24,000
is implicitly a test that the pointers not null in C.

8
00:00:24,000 --> 00:00:28,000
And the third thing we're going to assert is that the number of bytes to read is also non-negative.

9
00:00:28,000 --> 00:00:32,000
So, given that setup and we're just going little sanity checking here, we can get to the main logic.

10
00:00:32,000 --> 00:00:35,000
So the first thing we're going to do is initialize a left variable which is going to be the number of bytes

11
00:00:35,000 --> 00:00:38,000
left to read to initially be the total number of bytes to read.

12
00:00:38,000 --> 00:00:42,000
Now we're going to enter our while loop--the while loop is going to operate until either

13
00:00:42,000 --> 00:00:47,000
the read system call returns something less than 1 that is to say it returns 0

14
00:00:47,000 --> 00:00:50,000
indicating an end of file condition or -1 indicating an error.

15
00:00:50,000 --> 00:00:53,000
And if either of those things happens, we're just going to return that value to our caller.

16
00:00:53,000 --> 00:00:58,000
If read work that is to say it read some positive number of bytes, we're going to increment

17
00:00:58,000 --> 00:01:03,000
the buffer pointer by that number of bytes, reduce the amount of bytes left by that number of bytes,

18
00:01:03,000 --> 00:01:07,000
assert the number of bytes left hasn't gone negative due to some sort of a logic error,

19
00:01:07,000 --> 00:01:11,000
and now finally if there are no bytes left, we're going to return the number of bytes read

20
00:01:11,000 --> 00:01:14,000
which has to be just the original number of bytes but these asked to read.

21
00:01:14,000 --> 00:01:18,000
So this is pretty simple code and I would expect or at least I would hope to be able to get it right

22
00:01:18,000 --> 00:01:22,000
but I know from vast prior experience that I never get this stuffed right the first time,

23
00:01:22,000 --> 00:01:24,000
so what I want to do is be able to test it.

24
00:01:24,000 --> 00:01:29,000
So what I've done is written a little test runners, and so what the test runners does is opens a program

25
00:01:29,000 --> 00:01:32,000
and so here we're just using a splay tree from Python that happens to be in this directory

26
00:01:32,000 --> 00:01:35,000
and allocating a buffer and we don't need to worry about the details here

27
00:01:35,000 --> 00:01:40,000
and then what we're going to do is 100 different times we're going to issue the read all command

28
00:01:40,000 --> 00:01:43,000
to read the contents of the file into the buffer and then we're going to assert that

29
00:01:43,000 --> 00:01:47,000
read all--always read the full number of bytes we're trying to read and then

30
00:01:47,000 --> 00:01:51,000
we're also going to assert using a memory comparison function that

31
00:01:51,000 --> 00:01:53,000
the contents of that file are the contents that we expected.

32
00:01:53,000 --> 00:01:56,000
Its definitive variables initializes some code I didn't really talked about

33
00:01:56,000 --> 00:01:58,000
to contain the data from the file.

34
00:01:58,000 --> 00:02:01,000
And so what you're going to say if we do this 100 times, then our new read all call passes.

35
00:02:01,000 --> 00:02:05,000
And so let's look at what happens.
