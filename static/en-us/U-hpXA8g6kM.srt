1
00:00:00,570 --> 00:00:04,910
As the program runs, it will be building
up internal data stores for keeping

2
00:00:04,910 --> 00:00:09,420
track of all the variables that are
available to different function objects.

3
00:00:09,420 --> 00:00:12,330
And I'm going to picture that
stuff over here on the right.

4
00:00:12,330 --> 00:00:16,250
This will be a diagram or
a picture of our in-memory system.

5
00:00:16,250 --> 00:00:18,940
Since each new run of
a function is supposed

6
00:00:18,940 --> 00:00:22,540
to operate in complete isolation
from all the previous runs,

7
00:00:22,540 --> 00:00:26,250
a new execution context should be
created every time you run a function.

8
00:00:26,250 --> 00:00:29,725
Thus, for each lexical scope
there may be many in-memory

9
00:00:29,725 --> 00:00:33,095
scopes created during execution,
or there may be none.

10
00:00:33,095 --> 00:00:36,915
It all depends on how many times you
run a given function in your code.

11
00:00:36,915 --> 00:00:40,895
To examine execution contexts,
we'll need to actually run this program.

12
00:00:40,895 --> 00:00:42,827
So let's simulate that here.

13
00:00:42,827 --> 00:00:45,597
The yellow arrow will point
to the position in the code

14
00:00:45,597 --> 00:00:49,567
where our simulated interpreter has
reached, sort of like a debugger.

15
00:00:49,567 --> 00:00:53,147
Before this first line of code even
runs, the interpreter will start out

16
00:00:53,147 --> 00:00:55,940
by setting up an execution
environment for you.

17
00:00:55,940 --> 00:01:00,140
The first step will be to create
an in-memory global scope context

18
00:01:00,140 --> 00:01:02,310
to hold all of the global variables.

19
00:01:02,310 --> 00:01:06,110
So let's visualize that
execution context data store

20
00:01:06,110 --> 00:01:07,260
off to the right here.

21
00:01:07,260 --> 00:01:11,270
We'll use a similar color as the lexical
scope region that it relates to.

22
00:01:11,270 --> 00:01:15,230
Here, our interpreter is building up
a storage system for the global scope.

23
00:01:15,230 --> 00:01:19,720
The yellow border is around the
interpreter's current execution context.

24
00:01:19,720 --> 00:01:20,690
That is to say,

25
00:01:20,690 --> 00:01:24,460
whichever one the interpreter
starts its variable lookups in.

26
00:01:24,460 --> 00:01:27,600
So far, the global context
is the only one that exists.

27
00:01:27,600 --> 00:01:30,140
So of course, it's the current scope.

28
00:01:30,140 --> 00:01:32,080
As the first line of code runs,

29
00:01:32,080 --> 00:01:36,730
the interpreter builds up a new key
value mapping inside of the execution

30
00:01:36,730 --> 00:01:41,290
context, in order to keep track of the
value that is bound to the name, hero.

31
00:01:41,290 --> 00:01:45,250
The aHero function randomly
generated the value Gal,

32
00:01:45,250 --> 00:01:47,560
which will be stored
in the hero variable.

33
00:01:47,560 --> 00:01:51,970
Like the line above it, this line
implies a simple assignment operation.

34
00:01:51,970 --> 00:01:56,020
Now the value being assigned is
a function that spans several lines.

35
00:01:56,020 --> 00:01:59,510
But the interpreter's going to ignore
all the red and the blue code for now.

36
00:01:59,510 --> 00:02:02,470
They will only get run when
the function is actually called.

37
00:02:02,470 --> 00:02:05,900
So, that line of code has the effect
of adding a new key value pair

38
00:02:05,900 --> 00:02:07,880
to our global scope context.
