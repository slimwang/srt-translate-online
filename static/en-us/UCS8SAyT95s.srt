1
00:00:00,111 --> 00:00:03,869
In CUDA this discussion focuses on the concept of a warp.

2
00:00:03,869 --> 00:00:07,109
Now remember that a warp is a set of threads that operate in lock step,

3
00:00:07,109 --> 00:00:11,516
all executing the same instruction at the same time on whatever data they happen to be processing.

4
00:00:11,516 --> 00:00:16,452
And it's general technique is called SIMD, that stands for Single Instruction, Multiple Data.

5
00:00:16,452 --> 00:00:18,987
This is a term you'll hear a lot in parallel computing.

6
00:00:18,987 --> 00:00:21,956
Computer architects have been building SIMD processors for decades.

7
00:00:21,956 --> 00:00:26,697
It saves a lot of transistors and a lot of power if you can amortize the work used to

8
00:00:26,697 --> 00:00:32,931
decode and fetch and perform a single instruction against multiple pieces of data at once.

9
00:00:32,931 --> 00:00:38,676
All modern CPUs use vector instructions, and the most typical ones

10
00:00:38,676 --> 00:00:42,177
on Intel CPUs are called SSE or AVX instruction sets,

11
00:00:42,177 --> 00:00:47,325
and these are ways that the CPU can execute the same instruction on multiple pieces of data at once.

12
00:00:47,325 --> 00:00:50,253
Going back to a point I made at the very beginning of this lecture,

13
00:00:50,253 --> 00:00:55,426
on a CPU, if you're performing an SSE instruction in a single clock cycle,

14
00:00:55,426 --> 00:00:59,802
you're affecting 4 pieces of data. On AVX you could be affecting 8 pieces of data.

15
00:00:59,802 --> 00:01:03,975
These vector registers represent a huge amount of the computational horsepower,

16
00:01:03,975 --> 00:01:08,440
and if you're not using them on the CPU, then you're missing most of the power of your processor.

17
00:01:08,440 --> 00:01:11,640
Another term you'll see a lot is SIMT.

18
00:01:11,640 --> 00:01:16,844
This is a term coined by Nvidia to stand for Single Instruction, Multiple Threads,

19
00:01:16,844 --> 00:01:22,224
and this is a subtle distinction that has to do with what happens when there is thread divergence.

20
00:01:22,224 --> 00:01:26,791
Let me explain what that means. It all comes down to what happens at a branch in the code.

21
00:01:26,791 --> 00:01:29,627
Here's some code with an if L statement,

22
00:01:29,627 --> 00:01:34,335
and I'll color the instruction stream black for instructions that all the threads are going to execute,

23
00:01:34,335 --> 00:01:39,937
red for instructions that only threads that take this branch in the if statement will execute,

24
00:01:39,937 --> 00:01:45,839
blue for instructions that only threads that take the else branch will execute, and black again.
