1
00:00:00,000 --> 00:00:03,000
Alright, how about this? We've seen just INT.

2
00:00:03,000 --> 00:00:06,000
One of our grammar rules is A goes to INT + string--

3
00:00:06,000 --> 00:00:11,000
INT + string--and I've put the dot right here, so we've already seen an INT,

4
00:00:11,000 --> 00:00:13,000
and we're expecting to see 2 more things.

5
00:00:13,000 --> 00:00:16,000
This is consistent with the world that we've been presented.

6
00:00:16,000 --> 00:00:20,000
We know that eventually this won't work because the full input is INT + INT,

7
00:00:20,000 --> 00:00:23,000
but we haven't seen that much yet, so we can't rule it out.

8
00:00:23,000 --> 00:00:25,000
Right now we think this state is okay.

9
00:00:25,000 --> 00:00:28,000
In the future, we'll give up on it.

10
00:00:28,000 --> 00:00:31,000
Similarly, one of the rules in our grammar is A goes to INT.

11
00:00:31,000 --> 00:00:35,000
We've only seen an INT, so we could be in this state.

12
00:00:35,000 --> 00:00:37,000
The INT is behind us. There's nothing in our future.

13
00:00:37,000 --> 00:00:40,000
We're really hoping the input ends now.

14
00:00:40,000 --> 00:00:41,000
The input doesn't end now.

15
00:00:41,000 --> 00:00:43,000
You and I know that there are 2 more tokens coming,

16
00:00:43,000 --> 00:00:47,000
but our parser doesn't know that yet. It's only seen 1 token.

17
00:00:47,000 --> 00:00:50,000
In the next step, the next iteration, the next recursive call,

18
00:00:50,000 --> 00:00:53,000
it will know and throw away this information.

19
00:00:53,000 --> 00:00:55,000
But for now, we're keeping it.

20
00:00:55,000 --> 00:00:56,000
Alright, how about this?

21
00:00:56,000 --> 00:01:01,000
A goes to INT +--this requires us to have 2 tokens in the past,

22
00:01:01,000 --> 00:01:03,000
and we've only seen 1 token of the input.

23
00:01:03,000 --> 00:01:05,000
That can't be true.

24
00:01:05,000 --> 00:01:09,000
Similarly over here, there's nothing in the past, and there's 1 token to the right.

25
00:01:09,000 --> 00:01:12,000
Looking at our grammar. There's really no way this could play out.

26
00:01:12,000 --> 00:01:15,000
We've seen 1 token, and this assumes we've seen 0.

27
00:01:15,000 --> 00:01:22,000
Over here, similarly, INT + string--this parsing state only works if we've seen 0 tokens,

28
00:01:22,000 --> 00:01:26,000
and we've already seen 1. So that doesn't match.

29
00:01:26,000 --> 00:01:30,000
And in fact, similarly here, S goes to A. S goes to A is a rule in our grammar.

30
00:01:30,000 --> 00:01:34,000
That's a good sign, but this version requires us to have seen nothing,

31
00:01:34,000 --> 00:01:36,000
and we've seen 1 token.

32
00:01:36,000 --> 00:01:39,000
S goes to A, and here we are.

33
00:01:39,000 --> 00:01:40,000
Actually this could totally work.

34
00:01:40,000 --> 00:01:45,000
If I've only seen just INT from the input, then I could be finishing off--

35
00:01:45,000 --> 00:01:50,000
I could be accepting the string based on S goes to A and A goes to INT.

36
00:01:50,000 --> 00:01:54,000
So I've already seen a full A. A goes to INT--and now I'm done with S.

37
00:01:54,000 --> 00:01:56,000
Yeah! That's where I could be.

38
00:01:56,000 --> 00:01:59,000
Now again, we're going to rule this out as soon as we see the next token in the input--

39
00:01:59,000 --> 00:02:03,000
that it's not the end of the string, but for now, it looks very promising.

40
00:02:03,000 --> 00:02:08,000
This is the big trick with parsing, I said earlier, we'd have to keep our fingers in many spots

41
00:02:08,000 --> 99:59:59,999
because until we see the whole input, we're not sure what the picture is.
