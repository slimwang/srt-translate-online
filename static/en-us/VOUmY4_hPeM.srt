1
00:00:00,220 --> 00:00:02,300
So why is building software matter?

2
00:00:02,300 --> 00:00:04,850
Historically, it used to be that
building was just compiling and

3
00:00:04,850 --> 00:00:06,170
packing your source code.

4
00:00:06,170 --> 00:00:08,900
Today, builds are responsible for
so much more.

5
00:00:08,900 --> 00:00:12,170
They run our tests, can buy coded
resources from multiple sources,

6
00:00:12,170 --> 00:00:14,980
generate documentation,
create multiple build variance,

7
00:00:14,980 --> 00:00:17,640
publish our applications,
and manage dependencies.

8
00:00:17,640 --> 00:00:20,750
Because of this, the build has
become the software factory,

9
00:00:20,750 --> 00:00:24,270
in which we can continually change,
test, and release our apps.

10
00:00:24,270 --> 00:00:26,680
Think of Gradle as the one stop shop for
defining and

11
00:00:26,680 --> 00:00:29,700
integrating all the parts of
your software delivery process.

12
00:00:29,700 --> 00:00:33,580
For example, for Gradle users, the
process that executes the modern IDs,

13
00:00:33,580 --> 00:00:35,220
like Android studio, or

14
00:00:35,220 --> 00:00:39,100
CI front end products like Jenkins,
is all defining Gradle.

15
00:00:39,100 --> 00:00:41,900
In this day and age,
an app store Android developer unable to

16
00:00:41,900 --> 00:00:46,610
ship changes into production faster and
faster will fail behind the competition,

17
00:00:46,610 --> 00:00:50,200
in the end automation is
the key to making this happen.

18
00:00:50,200 --> 00:00:52,070
So why Gradle?

19
00:00:52,070 --> 00:00:55,820
The biggest reason is that Google has
selected Gradle as the build system for

20
00:00:55,820 --> 00:00:57,250
Android Studio.

21
00:00:57,250 --> 00:01:00,110
In fact, Android Studio
delegates the entire process of

22
00:01:00,110 --> 00:01:02,130
building Android Apps to Gradle.

23
00:01:02,130 --> 00:01:05,410
When I hit the run button, Android
Studio just sets Gradle in motion and

24
00:01:05,410 --> 00:01:06,980
sits back to watch.

25
00:01:06,980 --> 00:01:09,930
By learning about Gradle,
we can extend this default behavior

26
00:01:09,930 --> 00:01:13,070
to build even more and more capable and
well tested Android apps.

27
00:01:14,200 --> 00:01:16,810
Obviously, Google is full
of very smart engineers.

28
00:01:16,810 --> 00:01:19,400
And one measure of their smarts is
that they felt they didn't need to

29
00:01:19,400 --> 00:01:21,580
reinvent the wheel with build systems.

30
00:01:22,730 --> 00:01:26,370
Gradle solves some the most hard
problems faced by Android developers.

31
00:01:26,370 --> 00:01:30,280
How to automate building and testing
apps to achieve rapid productivity.

32
00:01:30,280 --> 00:01:32,020
And how to manage dependencies and

33
00:01:32,020 --> 00:01:34,960
variations that allow professional
developers to pump out

34
00:01:34,960 --> 00:01:39,570
dozens of variances of their apps with
one click, or build a suite of apps and

35
00:01:39,570 --> 00:01:42,510
deal officially with
apps that are very large.

36
00:01:42,510 --> 00:01:45,390
Another key insight is that
many Android developers work in

37
00:01:45,390 --> 00:01:46,950
header genius environments.

38
00:01:46,950 --> 00:01:49,873
With differing and
complex technology stacks,

39
00:01:49,873 --> 00:01:53,100
Gradle is the dominant multi
platform build system.

40
00:01:53,100 --> 00:01:55,130
Other strengths of Gradle
include the compact and

41
00:01:55,130 --> 00:01:57,870
powerful build language used
to write its build scripts and

42
00:01:57,870 --> 00:02:00,920
the rich domain model that allows
Gradle to reason about your build.
