1
00:00:00,200 --> 00:00:04,334
Recall that our original purpose was the
find a transformation of the formula,

2
00:00:04,334 --> 00:00:07,482
such that a truth assignment
satisfied the original, if and

3
00:00:07,482 --> 00:00:10,461
only if it could be extended
to the transformed formula.

4
00:00:10,461 --> 00:00:13,880
And we've seen how to do this
transformation for a single clause.

5
00:00:13,880 --> 00:00:15,750
But actually, this is enough.

6
00:00:15,750 --> 00:00:18,500
We can just transform
each clause individually.

7
00:00:18,500 --> 00:00:21,150
Introducing a new set of variables for
each.

8
00:00:21,150 --> 00:00:23,020
All the same arguments
about extending or

9
00:00:23,020 --> 00:00:25,250
restricting the truth
assignment will hold.

10
00:00:25,250 --> 00:00:28,260
Let's illustrate what a transformation
of a multi clause formula

11
00:00:28,260 --> 00:00:29,500
looks like with an example.

12
00:00:30,670 --> 00:00:32,330
Consider this formula here,

13
00:00:32,330 --> 00:00:35,960
where I've indexed the literal
Z with two indices now.

14
00:00:35,960 --> 00:00:37,880
The first,
referring to the clause it's in,

15
00:00:37,880 --> 00:00:42,230
and the second being it's
enumeration within the clause.

16
00:00:42,230 --> 00:00:44,320
The first clause only has two literals.

17
00:00:44,320 --> 00:00:48,362
So we transform it into these
two clauses with three literals

18
00:00:48,362 --> 00:00:51,068
by introducing a new variable, y11.

19
00:00:51,068 --> 00:00:54,990
It gets the first one because it
was generated by the first clause.

20
00:00:54,990 --> 00:01:00,732
We transform the second clause with
five literals into these three clauses,

21
00:01:00,732 --> 00:01:04,546
introducing two new variables y21,
and y22.

22
00:01:04,546 --> 00:01:08,295
Note that these are different from the
variables used in the clauses generated

23
00:01:08,295 --> 00:01:09,780
by the first original clause.

24
00:01:10,910 --> 00:01:13,130
Since all these sets of
variables are disjoint,

25
00:01:13,130 --> 00:01:15,430
we can assign them
independently of each other and

26
00:01:15,430 --> 00:01:18,970
apply all the same arguments as
we did to individual clauses.

27
00:01:18,970 --> 00:01:22,462
That's how CNF can be reduced to 3-CNF.

28
00:01:22,462 --> 00:01:25,284
And of course, this transformation
runs in polynomial time,

29
00:01:25,284 --> 00:01:27,460
making the reduction polynomial.

30
00:01:27,460 --> 00:01:30,710
We just reduced the problem of
finding a satisfying assignment to

31
00:01:30,710 --> 00:01:31,892
a general CNF formula,

32
00:01:31,892 --> 00:01:35,511
to the problem of finding a satisfying
assignment to a 3-CNF formula.

33
00:01:35,511 --> 00:01:39,000
At this point, it's natural to ask,
can we go any further?

34
00:01:39,000 --> 00:01:41,690
Can we reduce this problem to a 2-CNF?

35
00:01:41,690 --> 00:01:44,283
Well, no, not unless p is equal to np.

36
00:01:44,283 --> 00:01:46,121
There is a polynomial time algorithm for

37
00:01:46,121 --> 00:01:48,664
finding a satisfying
assignment to a 2-CNF formula,

38
00:01:48,664 --> 00:01:51,430
based of finding strongly
connected components in a graph.

39
00:01:52,550 --> 00:01:56,910
Therefore, if we could reduce 3-CNF to
2-CNF, then p would be equal to np.

40
00:01:57,990 --> 00:02:01,680
So, 3-CNF is as simple as
the satisfiability question gets.

41
00:02:01,680 --> 00:02:04,810
And it admits some very clean and
easy to visualize reductions

42
00:02:04,810 --> 00:02:06,990
that allow us to show that
other problems are np complete.

43
00:02:08,080 --> 00:02:09,370
We'll go over two of these.

44
00:02:09,370 --> 00:02:13,640
First, the reduction to independent set,
or clique, and then to subset sum.
