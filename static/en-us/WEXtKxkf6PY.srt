1
00:00:00,150 --> 00:00:03,170
The last thing is but, but, how do we know

2
00:00:03,170 --> 00:00:06,820
it's the right instruction? Remember we need to make our prediction

3
00:00:06,820 --> 00:00:09,439
while we're fetching the instruction. So if this is a

4
00:00:09,439 --> 00:00:12,920
return instruction, we need to use the return address stack, before

5
00:00:12,920 --> 00:00:16,198
we even determine that it is a return instruction. We

6
00:00:16,198 --> 00:00:19,846
cannot just keep pushing and popping things from the return address

7
00:00:19,846 --> 00:00:23,477
stack, before we know it's a return. Because, for example,

8
00:00:23,477 --> 00:00:25,415
if there is an ad and we pop from the return

9
00:00:25,415 --> 00:00:28,880
address stack, then it's not going to work correctly. We actually need

10
00:00:28,880 --> 00:00:32,509
to figure out, or at least very accurately predict, what's our

11
00:00:32,509 --> 00:00:36,610
return instruction so that we can use the RATs appropriately. So

12
00:00:36,610 --> 00:00:39,370
the problem is that we are using the RAT while fetching

13
00:00:39,370 --> 00:00:42,280
the instruction. It's not been decoded yet, so we don't know

14
00:00:42,280 --> 00:00:45,190
it's a return instruction yet. So how do we do it?

15
00:00:45,190 --> 00:00:47,486
One way is to just use a very simple predictor that

16
00:00:47,486 --> 00:00:50,566
will be trained on whether the instruction we're fetching is the

17
00:00:50,566 --> 00:00:53,606
right or not. Simply, trying to predict or one

18
00:00:53,606 --> 00:00:56,270
way or the other depending on whether it's a

19
00:00:56,270 --> 00:00:58,862
rat or not and then make that predictor tell

20
00:00:58,862 --> 00:01:01,940
us whether to use a [UNKNOWN] or not. This

21
00:01:01,940 --> 00:01:05,030
would be a very likely accurate predictor. If, at

22
00:01:05,030 --> 00:01:08,810
the particular PC, we have seen a RET instruction

23
00:01:08,810 --> 00:01:12,050
previously then it is very likely that if we

24
00:01:12,050 --> 00:01:16,830
see the same PC we still have a return instruction.

25
00:01:16,830 --> 00:01:19,280
So we can use a single bit predictor

26
00:01:19,280 --> 00:01:23,048
very easily here. Another approach, is to use

27
00:01:23,048 --> 00:01:27,960
a so-called predecoding. We will soon see that

28
00:01:27,960 --> 00:01:31,540
the processor really contains a cache that stores

29
00:01:31,540 --> 00:01:34,230
instructions that have been fetched from memory. And

30
00:01:34,230 --> 00:01:36,500
its fetching instructions from the cache, and only

31
00:01:36,500 --> 00:01:38,620
if the cache doesn't already contain the instruction

32
00:01:38,620 --> 00:01:41,995
it goes from memory. So the predecoding works by,

33
00:01:41,995 --> 00:01:44,760
when I'm fetching from memory, I decode

34
00:01:44,760 --> 00:01:47,683
enough of the instruction to know that it's

35
00:01:47,683 --> 00:01:49,816
a return or not, and I store that

36
00:01:49,816 --> 00:01:53,371
information along with the actual instruction in the

37
00:01:53,371 --> 00:01:55,960
cache. So pretty much my memory will, for

38
00:01:55,960 --> 00:02:00,510
example, have 32-bit instructions. In my cache I

39
00:02:00,510 --> 00:02:04,270
will store 33 bits per instruction, 32 bits

40
00:02:04,270 --> 00:02:07,030
of the actual instruction. And 1 bit that

41
00:02:07,030 --> 00:02:09,258
tells me whether the instruction is a return or

42
00:02:09,258 --> 00:02:12,400
not. So the idea is that as the instruction is

43
00:02:12,400 --> 00:02:15,270
coming from memory, and we put it to cache.

44
00:02:15,270 --> 00:02:19,920
We can pre-decoding instructions, keeping some additional bits in the

45
00:02:19,920 --> 00:02:22,830
cache about the pre-decoding of the instruction. So that

46
00:02:22,830 --> 00:02:26,600
when we fetch, we already know that information. The alternative

47
00:02:26,600 --> 00:02:28,990
to this would have been to just fetch the

48
00:02:28,990 --> 00:02:32,270
instructions from memory to cache as they are, and then

49
00:02:32,270 --> 00:02:34,870
every time we fetch we have to figure out

50
00:02:34,870 --> 00:02:38,960
what this instruction is. Because it's also more power-efficient

51
00:02:38,960 --> 00:02:41,220
to do this once and then fetch instruction many

52
00:02:41,220 --> 00:02:45,820
times rather than redo it every single time, pre-decoding

53
00:02:45,820 --> 00:02:49,240
is a very popular approach. So pre-decoding is used

54
00:02:49,240 --> 00:02:52,460
for things like, Is it a return instruction? Is

55
00:02:52,460 --> 00:02:55,240
it a branch instruction at all? If we know

56
00:02:55,240 --> 00:02:57,580
it's not a branch, than we can completely omit

57
00:02:57,580 --> 00:03:00,330
the use of any branch vectors, thus saving a lot

58
00:03:00,330 --> 00:03:05,270
of power. If our instructions are of variable sizes, predicoding

59
00:03:05,270 --> 00:03:07,800
can also tell us, for example, how many bytes this

60
00:03:07,800 --> 00:03:10,780
instruction is long so that we can fetch the next instruction

61
00:03:10,780 --> 00:03:13,370
quickly and not. Rely on just the code in the

62
00:03:13,370 --> 00:03:15,780
instruction before we can fetch the next one, and so

63
00:03:15,780 --> 00:03:18,880
on. So there is a lot of things that modern

64
00:03:18,880 --> 00:03:22,660
processors do in this pre-decoding phase. In order to avoid doing

65
00:03:22,660 --> 00:03:27,040
it when we are on the clock, after we have fetched the instruction.
