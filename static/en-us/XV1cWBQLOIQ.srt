1
00:00:00,090 --> 00:00:02,320
All right, we've come nearly to the end of our course. What I'd

2
00:00:02,320 --> 00:00:05,040
like to do now is summarize what I think are the high points, that

3
00:00:05,040 --> 00:00:07,110
is the most important testing principles that

4
00:00:07,110 --> 00:00:08,600
I've tried to convey in this course,

5
00:00:08,600 --> 00:00:10,820
and put them all in one place. So, let's go through these. First of

6
00:00:10,820 --> 00:00:12,840
all, testers must want software to fail.

7
00:00:12,840 --> 00:00:14,590
Second, testers are like detectives who are

8
00:00:14,590 --> 00:00:19,180
hunting down bugs. And as detectives, testers will have to be observant to all

9
00:00:19,180 --> 00:00:21,050
sorts of suspicious behaviors and anomalies in

10
00:00:21,050 --> 00:00:22,490
the software of your test. My guess

11
00:00:22,490 --> 00:00:25,066
is that a number of really serious bugs that have occurred over the years.

12
00:00:25,066 --> 00:00:28,240
I think these had already been noticed by people and swept under the rug because

13
00:00:28,240 --> 00:00:30,720
people were busy or they just wanted to ship the product or maybe they were

14
00:00:30,720 --> 00:00:34,320
users who didn't know what the bugs meant. So regular users have the luxury of

15
00:00:34,320 --> 00:00:36,180
ignoring bugs, but testers don't, and so

16
00:00:36,180 --> 00:00:37,880
it's really important not to sweep things under

17
00:00:37,880 --> 00:00:41,760
the rug. All available test oracles should be used as a basis for testing. And

18
00:00:41,760 --> 00:00:44,250
so, you might be tempted to think from the language that I was using, that

19
00:00:44,250 --> 00:00:47,060
is, strong oracles versus weak ones, that if we had a couple of good strong

20
00:00:47,060 --> 00:00:48,770
oracles available, maybe we wouldn't need the

21
00:00:48,770 --> 00:00:50,080
weak ones, maybe we wouldn't just use them

22
00:00:50,080 --> 00:00:52,168
at all. And as I hope I've convinced you by now, that's not

23
00:00:52,168 --> 00:00:54,120
the case at all. All of the oracles should be used because they

24
00:00:54,120 --> 00:00:57,470
can all detect different kinds of faults, and even if they detect the

25
00:00:57,470 --> 00:01:00,560
same faults, weak oracles might be much cheaper to use. Test cases should

26
00:01:00,560 --> 00:01:04,150
contain values selected from the entire input domain, and if there's doubt about

27
00:01:04,150 --> 00:01:06,680
what exactly that domain is, this is something that will be good to

28
00:01:06,680 --> 00:01:10,090
hash out with the developers. Interfaces that cross a trust boundary need to

29
00:01:10,090 --> 00:01:13,070
be tested with all representable values, not

30
00:01:13,070 --> 00:01:15,200
just those from the ostensible input domain.

31
00:01:15,200 --> 00:01:17,540
If we recall some of the examples we've looked at, if we are writing

32
00:01:17,540 --> 00:01:19,080
a web server we might hope everybody

33
00:01:19,080 --> 00:01:21,080
submits data that's well-formatted, but as its

34
00:01:21,080 --> 00:01:23,590
most likely the case, they won't and the reason they won't is because they

35
00:01:23,590 --> 00:01:25,880
will be trying to break into our Web site. Server. So we need to test

36
00:01:25,880 --> 00:01:29,010
on that kind of data, to ensure that we can correctly reject it. Similarly,

37
00:01:29,010 --> 00:01:31,790
a piece of software like the Linux kernel has the trust boundary at the

38
00:01:31,790 --> 00:01:33,420
system call interface, that is to say

39
00:01:33,420 --> 00:01:36,280
the interface between user mode applications and

40
00:01:36,280 --> 00:01:38,180
the Linux kernel. Linux kernel like the

41
00:01:38,180 --> 00:01:40,310
web server, can't trust that its clients are

42
00:01:40,310 --> 00:01:42,450
going to make well formed requests all the time. It should expect

43
00:01:42,450 --> 00:01:46,120
that its clients if not actually hostile, are at least buggy,

44
00:01:46,120 --> 00:01:47,900
and are going to do all kinds of, it needs to

45
00:01:47,900 --> 00:01:51,610
catch that instead of crashing or violating its security policy. A little

46
00:01:51,610 --> 00:01:54,280
brute force goes a long ways when we're testing. And what

47
00:01:54,280 --> 00:01:57,640
I mean in particular is in certain restricted circumstances, we can

48
00:01:57,640 --> 00:02:01,430
do exhaustive testing and almost anything else can be randomly tested.

49
00:02:01,430 --> 00:02:05,430
Quality cannot be tested into bad software. We saw the Therac 25

50
00:02:05,430 --> 00:02:06,910
example, where the control software for

51
00:02:06,910 --> 00:02:08,880
the radiation therapy machine was probably

52
00:02:08,880 --> 00:02:11,880
so broken, that almost an, almost no amount of testing would have been

53
00:02:11,880 --> 00:02:14,190
sufficient to make it right. It needed to be thrown away I

54
00:02:14,190 --> 00:02:16,360
think I needed to start over. I'm sure we've all seen software that

55
00:02:16,360 --> 00:02:19,320
looked like that. So in contrast with examples like a fair at

56
00:02:19,320 --> 00:02:22,820
25, testable software has a few of the following qualities. No hidden coupling

57
00:02:22,820 --> 00:02:24,870
between modules and side channels where

58
00:02:24,870 --> 00:02:26,570
modules can share information without being

59
00:02:26,570 --> 00:02:28,230
visible to the system developers. A

60
00:02:28,230 --> 00:02:30,410
few variables but are shared between threads.

61
00:02:30,410 --> 00:02:33,700
Few global variables shared between modules. And no pointer soup,

62
00:02:33,700 --> 00:02:36,570
and that is to say, no huge data structures with pointers

63
00:02:36,570 --> 00:02:38,950
going everywhere where it can't possibly keep track of who's

64
00:02:38,950 --> 00:02:41,450
changing what and what's valid and what's not. Codes should be

65
00:02:41,450 --> 00:02:45,510
self checking whenever possible using plenty of assertions. However, these

66
00:02:45,510 --> 00:02:48,180
assertions are never used for error checking, rather they're used to

67
00:02:48,180 --> 00:02:51,480
check for logically impossible conditions. It implies some sort of an

68
00:02:51,480 --> 00:02:53,890
internal consistency violation. Assertions must

69
00:02:53,890 --> 00:02:55,450
never be side effecting, because if

70
00:02:55,450 --> 00:02:57,900
they are, and you turn them off, the system behavior will change,

71
00:02:57,900 --> 00:02:59,560
and this leads to madness among

72
00:02:59,560 --> 00:03:01,770
developers. Finally, these assertions should never

73
00:03:01,770 --> 00:03:04,460
be silly or trivial ones, because first of all, those serve no

74
00:03:04,460 --> 00:03:06,590
purpose, second, they clutter up code,

75
00:03:06,590 --> 00:03:08,320
third, they make things slower, and finally,

76
00:03:08,320 --> 00:03:11,050
they fail to communicate useful information to the next person who looks

77
00:03:11,050 --> 00:03:14,160
at the code When appropriate, all 3 sources of input to a piece

78
00:03:14,160 --> 00:03:16,970
of software under test should be used a a basis for testing.

79
00:03:16,970 --> 00:03:20,670
And those include the obvious API's, provided by the software on your test

80
00:03:20,670 --> 00:03:23,610
which can be tested directly. API's used by the software

81
00:03:23,610 --> 00:03:27,020
under test can be tested using fault injections techniques. So

82
00:03:27,020 --> 00:03:29,790
recall that these are things like substituting the library that

83
00:03:29,790 --> 00:03:33,040
provides these API's with a different library the inject faults, well

84
00:03:33,040 --> 00:03:35,935
perhaps just hacking the layer underneath to inject faults. Finally,

85
00:03:35,935 --> 00:03:39,980
non-functional inputs such as thread schedules need to be tested using

86
00:03:39,980 --> 00:03:42,180
whatever method you can get that will work to actually

87
00:03:42,180 --> 00:03:45,880
test these things. And finally, the last principle for testing is

88
00:03:45,880 --> 00:03:49,280
that failed code coverage do not provide a mandate to cover the failed

89
00:03:49,280 --> 00:03:53,270
items, no matter how tempting that might be, but rather, they give clues to

90
00:03:53,270 --> 00:03:56,470
ways in which the test we did is inadequate. So, blindly coding to

91
00:03:56,470 --> 00:03:59,170
the coverage metric is going to destroy those clues, but it's going to do it in

92
00:03:59,170 --> 00:04:01,450
such a way that doesn't improve the quality of the test suite very

93
00:04:01,450 --> 00:04:03,260
much. So taken together, this list of

94
00:04:03,260 --> 00:04:05,030
items I've just given you constitutes pretty

95
00:04:05,030 --> 00:04:08,350
much all that I know about testing. And the detailed version of these

96
00:04:08,350 --> 00:04:11,030
has been the content of this course. This is material that I have never

97
00:04:11,030 --> 00:04:13,870
taught before, so I hope it came out in sort of a fairly coherent

98
00:04:13,870 --> 00:04:16,899
fashion. It's stuff that's been brewing in my mind for a long time. I've

99
00:04:16,899 --> 00:04:19,690
wanted to teach it because I've noticed for years that we don't seem to

100
00:04:19,690 --> 00:04:23,480
be doing a very good job teaching CS students to test. What happens instead is

101
00:04:23,480 --> 00:04:25,295
they write small test cases in response

102
00:04:25,295 --> 00:04:27,330
to assignments, they debug them until they

103
00:04:27,330 --> 00:04:30,410
pass the test cases we give them, hand them in and never look at them

104
00:04:30,410 --> 00:04:32,952
again. And it's hard to think of anything less like the real world of

105
00:04:32,952 --> 00:04:34,842
software development than the environment we create

106
00:04:34,842 --> 00:04:36,105
in classes. So what I have tried to

107
00:04:36,105 --> 00:04:38,083
do is structure this course a bit little differently,

108
00:04:38,083 --> 00:04:39,459
tried to bring out thing that I feel are

109
00:04:39,459 --> 00:04:41,136
really important that we often don't do a very

110
00:04:41,136 --> 00:04:42,930
good job with. And this has been really enjoyable for

111
00:04:42,930 --> 00:04:44,270
me, it's been great to actually try and set

112
00:04:44,270 --> 00:04:46,270
this material down in a coherent fashion and I very

113
00:04:46,270 --> 00:04:47,930
much hope that this material has been useful for

114
00:04:47,930 --> 00:04:49,840
you and that the class has been enjoyable. Thank you.
