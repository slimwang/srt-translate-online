1
00:00:00,000 --> 00:00:04,000
So years ago, while I was working at a company that shall not be named,

2
00:00:04,000 --> 00:00:07,000
I was bored out of my mind, and one of the things that people at this company

3
00:00:07,000 --> 00:00:11,000
did to pass the time was playing Tetris.

4
00:00:11,000 --> 00:00:14,000
I ended up liking this Tetris game so much

5
00:00:14,000 --> 00:00:16,000
that I decided to try and write my own version of it,

6
00:00:16,000 --> 00:00:20,000
write a computer program to play Tetris, and if you haven't seen it before,

7
00:00:20,000 --> 00:00:24,000
Tetris is a Soviet falling blocks puzzle game

8
00:00:24,000 --> 00:00:30,000
with a number of different pieces, all of which are made up of 4 smaller blocks.

9
00:00:30,000 --> 00:00:34,000
I decided that I wanted to support not just the normal Tetris pieces,

10
00:00:34,000 --> 00:00:37,000
but because I'm a bit of a math person, the ability to have pieces

11
00:00:37,000 --> 00:00:40,000
that were 5 long as well.

12
00:00:40,000 --> 00:00:44,000
In order to do that, I ended up making a piece definition language,

13
00:00:44,000 --> 00:00:48,000
a way of writing out what a Tetris piece should look like

14
00:00:48,000 --> 00:00:50,000
that this Tetris program would then read in.

15
00:00:50,000 --> 00:00:53,000
Now, I didn't use all of the lexing and parsing techniques

16
00:00:53,000 --> 00:00:56,000
that you're going to learn in this class,

17
00:00:56,000 --> 00:00:59,000
but I did use the same sort of concepts, and the point I'm trying to get across here

18
00:00:59,000 --> 00:01:02,000
is that in some sense, learning how to create

19
00:01:02,000 --> 00:01:04,000
your own language is like learning how to read.

20
00:01:04,000 --> 00:01:07,000
It really opens up a world of possibilities.

21
00:01:07,000 --> 00:01:10,000
It's a new tool in your belt that will come up and help you

22
00:01:10,000 --> 99:59:59,999
when you least expect it.
