1
00:00:00,470 --> 00:00:01,615
Let's recap what you've done.

2
00:00:01,615 --> 00:00:05,895
You've replaced the conventional linked
list representation with one based on

3
00:00:05,895 --> 00:00:06,475
arrays.

4
00:00:07,550 --> 00:00:10,280
With that you're now
ready to go parallel.

5
00:00:10,280 --> 00:00:14,465
To help you do that, I'm going to give
you a handy primitive called a jump.

6
00:00:14,465 --> 00:00:15,940
Here's a picture of a jump.

7
00:00:15,940 --> 00:00:17,370
Oh wait, sorry, wrong picture.

8
00:00:17,370 --> 00:00:18,790
Let's try again.

9
00:00:18,790 --> 00:00:21,960
Suppose you're looking at
a specific linked list node.

10
00:00:21,960 --> 00:00:24,340
In a jump, you move the next pointer so

11
00:00:24,340 --> 00:00:26,910
that it points to
the neighbor's neighbor.

12
00:00:26,910 --> 00:00:29,710
So take this next pointer,
for example, and

13
00:00:29,710 --> 00:00:32,820
let's replace it with a pointer
to the neighbor's neighbor.

14
00:00:32,820 --> 00:00:34,620
Now, think about this for a second.

15
00:00:34,620 --> 00:00:35,420
What the!

16
00:00:35,420 --> 00:00:36,810
Bad billy goat!

17
00:00:36,810 --> 00:00:39,414
What would happen,
if at every node in the list,

18
00:00:39,414 --> 00:00:41,519
you did a jump at exactly the same time?

19
00:00:41,519 --> 00:00:43,290
Let's try it and see.

20
00:00:43,290 --> 00:00:44,590
So here's the list.

21
00:00:44,590 --> 00:00:46,800
At every node, do a jump.

22
00:00:46,800 --> 00:00:48,202
Notice what you've just done.

23
00:00:48,202 --> 00:00:51,920
You've effectively split
the list into two sub lists.

24
00:00:51,920 --> 00:00:55,610
As you can imagine, that's exactly what
you need to do divide and conquer.

25
00:00:55,610 --> 00:00:58,790
Now if you keep doing this, these sub
lists will get shorter and shorter and

26
00:00:58,790 --> 00:01:00,440
you'll get more and more of them.

27
00:01:00,440 --> 00:01:01,810
Jump.

28
00:01:01,810 --> 00:01:03,640
Given a set of next pointers as input,

29
00:01:03,640 --> 00:01:07,700
you can perform a jump in
parallel using this algorithm.

30
00:01:07,700 --> 00:01:12,390
And notice that the new algorithm puts
the jump pointers in a new output array

31
00:01:12,390 --> 00:01:13,450
called N sub out.

32
00:01:14,720 --> 00:01:17,940
So for each node i, we check to
see if the next pointer is nil and

33
00:01:17,940 --> 00:01:19,860
if it's not, we do a jump.

34
00:01:20,990 --> 00:01:25,520
By placing the output in a separate
output array, we avoid collisions and

35
00:01:25,520 --> 00:01:28,260
that's what makes it
safe to use parallel for.

36
00:01:28,260 --> 00:01:31,700
Okay, you're almost ready for
the parallel list ranking algorithm.

37
00:01:31,700 --> 00:01:34,320
So far you've seen three ideas.

38
00:01:34,320 --> 00:01:37,260
The first is to store
the list as an array pool.

39
00:01:37,260 --> 00:01:40,880
The second is to recognize the list
ranking is roughly an add scan.

40
00:01:40,880 --> 00:01:44,310
Of course you need to set
the right initial values.

41
00:01:44,310 --> 00:01:48,320
And finally if we have a jump operation,
we can do divide and conquer.

42
00:01:48,320 --> 00:01:50,420
Go ahead and put these ideas together.

43
00:01:50,420 --> 00:01:52,970
You've established that a linked
list has an equivalent array pool

44
00:01:52,970 --> 00:01:54,580
representation.

45
00:01:54,580 --> 00:01:57,825
So when I sketch the algorithm,
I'll draw a linked list in the old

46
00:01:57,825 --> 00:02:01,662
fashioned way, but you always know
that there's an array pool equivalent.

47
00:02:01,662 --> 00:02:05,240
What about treating the list
ranking as an add scan?

48
00:02:05,240 --> 00:02:08,560
Remember that the key idea here was to
choose the right set of initial values

49
00:02:08,560 --> 00:02:09,949
at each node.

50
00:02:09,949 --> 00:02:13,400
So we put a 0 at the head and
1's everywhere else.

51
00:02:13,400 --> 00:02:18,110
So now we can apply the third idea
which is to use jumps to get sublists.

52
00:02:18,110 --> 00:02:22,080
If you jump repeatedly, you know the sub
list will get shorter and shorter.

53
00:02:22,080 --> 00:02:24,310
At the same time,
you'll be transforming this list, so

54
00:02:24,310 --> 00:02:27,150
you're going to have to do something
with these initial values.

55
00:02:27,150 --> 00:02:29,280
How about this,
let's maintain an invariant.

56
00:02:30,320 --> 00:02:33,800
The invariant will be,
if we take any node i, and

57
00:02:33,800 --> 00:02:36,690
we start at the head of its sub list,
and

58
00:02:36,690 --> 00:02:41,830
then let's say we traverse the sub list,
and we add up all the values.

59
00:02:41,830 --> 00:02:44,260
Then we'll get exactly the rank of i.

60
00:02:44,260 --> 00:02:47,390
So for the initial values,
you can easily check that this holds.

61
00:02:48,540 --> 00:02:52,690
Now suppose I've done a bunch of jumps
and I'm looking at a particular sublist.

62
00:02:52,690 --> 00:02:55,500
So here I'm just in
the middle of some sublist.

63
00:02:55,500 --> 00:02:58,410
And let's further suppose
that the invariant holds.

64
00:02:58,410 --> 00:03:01,520
Now let's jump everywhere
simultaneously.

65
00:03:01,520 --> 00:03:03,820
You'll get a list that looks like this.

66
00:03:03,820 --> 00:03:04,638
Now notice what happened.

67
00:03:04,638 --> 00:03:09,426
For this node here, we effectively
cut 4 out of its sublist, but

68
00:03:09,426 --> 00:03:12,141
we need to maintain this invariant.

69
00:03:12,141 --> 00:03:16,270
So we can't just drop the value 4,
we've got to incorporate it somehow.

70
00:03:16,270 --> 00:03:19,950
An easy way to do that would
just be to absorb 4's value.

71
00:03:19,950 --> 00:03:21,977
So 12 would become 16.

72
00:03:21,977 --> 00:03:26,898
The way this can work is before we do a
jump from 4, we take the value of 4 and

73
00:03:26,898 --> 00:03:29,280
push it to its successor.

74
00:03:29,280 --> 00:03:31,120
Okay.
Let's give this a try.

75
00:03:31,120 --> 00:03:34,090
Let's do one step of the update and
jump.

76
00:03:34,090 --> 00:03:38,280
For the update every node pushes
its value to its successor.

77
00:03:38,280 --> 00:03:41,150
Then we do the jump to
create two sublists.

78
00:03:41,150 --> 00:03:42,666
And let's just repeat this process.

79
00:03:42,666 --> 00:03:46,528
Push, jump,

80
00:03:46,528 --> 00:03:50,390
push, jump.

81
00:03:50,390 --> 00:03:52,970
Once every node is a stand
alone node you are done.

82
00:03:54,250 --> 00:03:57,480
Now I already gave you
a subroutine to perform the jumps.

83
00:03:57,480 --> 00:03:58,380
What about the updates?

84
00:03:59,460 --> 00:04:03,180
Here's an algorithm for
just the update step, which is parallel.

85
00:04:03,180 --> 00:04:07,310
So for each node i, we take its value
and we push it to the successor..

86
00:04:08,330 --> 00:04:12,230
We'll do all the rights to
a separate array of ranks.

87
00:04:12,230 --> 00:04:14,080
This way we can do all
these updates in parallel.

88
00:04:15,110 --> 00:04:16,709
Okay.
You're now almost ready to see

89
00:04:16,709 --> 00:04:17,570
the final algorithm.
