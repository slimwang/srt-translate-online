1
00:00:00,180 --> 00:00:03,824
Now, so far,
any time I talk about overflow,

2
00:00:03,824 --> 00:00:06,542
I indicated that we're writing.

3
00:00:06,542 --> 00:00:10,074
That we're storing data in
some part of memory, and

4
00:00:10,074 --> 00:00:13,622
we keep going beyond the limit
where we should stop.

5
00:00:13,622 --> 00:00:17,120
And so, the overflow is
the result of writing stuff.

6
00:00:17,120 --> 00:00:21,400
Overflows don't just have to be
associated with writing data.

7
00:00:21,400 --> 00:00:24,681
Overflows could also
happen because we read.

8
00:00:24,681 --> 00:00:29,541
The whole idea here is that overflow
is because we do too much of something.

9
00:00:29,541 --> 00:00:34,380
We keep writing beyond the limit, so we
write more than what we're supposed to.

10
00:00:34,380 --> 00:00:36,370
What if you read too much?

11
00:00:36,370 --> 00:00:41,060
Let's say a variable has 12 bytes but
you asked to read 100 bytes.

12
00:00:41,060 --> 00:00:44,978
What the read is going to do is it's
going to keep going beyond the variable

13
00:00:44,978 --> 00:00:48,373
and it's going to go on to the next
one and the one after that, and

14
00:00:48,373 --> 00:00:49,441
things like that.

15
00:00:49,441 --> 00:00:53,093
So wherever in memory you have
that variable that you're reading,

16
00:00:53,093 --> 00:00:56,561
if you go beyond that, you're
going to get into other variables.

17
00:00:56,561 --> 00:01:01,181
Now, there is a fairly well-known
vulnerability in the open SSL code

18
00:01:01,181 --> 00:01:05,253
which is used to secure all kinds
of online transactions, and

19
00:01:05,253 --> 00:01:07,701
secure communications, and so on.

20
00:01:07,701 --> 00:01:10,761
It was called
the Heartbleed Vulnerability.

21
00:01:10,761 --> 00:01:14,101
Actually, it was an overflow
related vulnerability.

22
00:01:14,101 --> 00:01:19,040
But it wasn't writing into the stack
beyond the memory that we had allocated

23
00:01:19,040 --> 00:01:22,340
for the variable into
which we are writing.

24
00:01:22,340 --> 00:01:26,050
It was actually a read
overflow vulnerability.

25
00:01:26,050 --> 00:01:28,870
Actually, this OpenSSL Heartbleed did,

26
00:01:28,870 --> 00:01:33,350
is that it kept reading beyond the
variable that you're supposed to read.

27
00:01:33,350 --> 00:01:37,100
And there was some juicy stuff
beyond that to do with keys and

28
00:01:37,100 --> 00:01:38,301
things like that.

29
00:01:38,301 --> 00:01:42,653
So if you read too much, you're going to
get additional data beyond what's really

30
00:01:42,653 --> 00:01:46,090
should be in this variable
that you're trying to read.

31
00:01:46,090 --> 00:01:50,180
And so, the additional data that
you got could be used to figure out

32
00:01:50,180 --> 00:01:54,120
sensitive keys and things like that,
and that's what the vulnerability was.

33
00:01:54,120 --> 00:01:57,900
But the vulnerability comes from
the fact that we're reading beyond

34
00:01:57,900 --> 00:02:00,711
the variable that the code
was supposed to access.

35
00:02:00,711 --> 00:02:04,151
As a result, the overflow
occurs while you are reading.

36
00:02:04,151 --> 00:02:07,492
You go beyond the boundary of
the variable and keep going.

37
00:02:07,492 --> 00:02:10,508
So that's called
a Read-only Buffer Overflow, and

38
00:02:10,508 --> 00:02:14,798
the example that we just discussed
the is the Heartbleed Vulnerability that

39
00:02:14,798 --> 00:02:17,070
occurred because of that.

40
00:02:17,070 --> 00:02:19,521
Buffer overflows don't
have to be on attack only.

41
00:02:19,521 --> 00:02:23,466
They can happen on the heap, and
buffer overflows don't have to be just

42
00:02:23,466 --> 00:02:26,381
when you write,
they can also happen when you read.

43
00:02:26,381 --> 00:02:30,501
It's just going beyond the boundary
where you should stop.

44
00:02:30,501 --> 00:02:32,521
You don't do that, that's the overflow.

45
00:02:32,521 --> 00:02:36,110
If you're reading some data,
then it's read-only buffer overflow.
