1
00:00:00,300 --> 00:00:05,470
So how do we make this BTB realistic? It needs to be small yet

2
00:00:05,470 --> 00:00:09,910
it needs to work this way. First of all we don't need to have an entry for

3
00:00:09,910 --> 00:00:15,220
every possible PC. It's enough if we have enough entries for

4
00:00:15,220 --> 00:00:19,230
all the instructions that are likely to execute soon. So for

5
00:00:19,230 --> 00:00:24,010
example if our program is executing a loop that has about a hundred instructions

6
00:00:24,010 --> 00:00:29,160
of code we really need only slightly more than a 100 entries. After the first

7
00:00:29,160 --> 00:00:34,020
iteration of the loop the BTB will be populated with instructions in the loop,

8
00:00:34,020 --> 00:00:38,670
at which point we will keep finding what we need in the BTB. So

9
00:00:38,670 --> 00:00:43,440
now we have relatively few entries in the BTB. Let's say that we do our timing

10
00:00:43,440 --> 00:00:50,170
experiments and we find that only 1,024 entries can be accessed in one cycle.

11
00:00:50,170 --> 00:00:55,910
The question is now, there are many, many possible PCs. How do we map each PC

12
00:00:55,910 --> 00:01:01,840
to an entry in a way that avoids conflicts among different PCs that map to

13
00:01:01,840 --> 00:01:06,140
the same entry? And note also that we need this mapping function to be really,

14
00:01:06,140 --> 00:01:11,120
really simple because any delay in computing the mapping function means that we

15
00:01:11,120 --> 00:01:15,500
need an even smaller BTB so that the whole thing finishes in one cycle.

16
00:01:15,500 --> 00:01:20,320
The way we do this is the program counter from which we are fetching,

17
00:01:20,320 --> 00:01:25,920
is let's say is 64 bit to byte. So it has bits starting from zero, to 63.

18
00:01:25,920 --> 00:01:31,380
We need 10 bits to index into our BTB. So what we will do is we'll take

19
00:01:31,380 --> 00:01:36,900
the least significant ten bits and use that as the index into our BTB.

20
00:01:36,900 --> 00:01:40,980
This mapping function is really fast because we do is we

21
00:01:40,980 --> 00:01:45,760
just take things ten bits and we just feed that to the BTB as an index.

22
00:01:45,760 --> 00:01:51,090
Why are we using the least significant bits and not the most significant bits?

23
00:01:51,090 --> 00:01:56,720
Think about the typical program where an instruction has some sort of PC address

24
00:01:56,720 --> 00:02:01,570
and then the next instruction will have an address that is very close to it.

25
00:02:01,570 --> 00:02:05,170
For example, just increment by four and so on.

26
00:02:05,170 --> 00:02:09,880
So if we were using the most significant bits of the PC, all instructions that

27
00:02:09,880 --> 00:02:13,450
are in the same part of the program would map to the same entry.

28
00:02:13,450 --> 00:02:18,830
because they have the same most significant bits. Thus, if you have a loop of

29
00:02:18,830 --> 00:02:24,170
some sort here, all of the instructions in the loop would map to the same entry,

30
00:02:24,170 --> 00:02:27,210
so that as we execute this loop, these instructions are kicking each

31
00:02:27,210 --> 00:02:30,950
other's stuff from the BTB, which we don't want to have. We want each of

32
00:02:30,950 --> 00:02:36,020
these to have an entry. If we use the least significant bits, what we get

33
00:02:36,020 --> 00:02:41,750
is that each instruction gets a different entry from nearby instructions, thus

34
00:02:41,750 --> 00:02:46,980
ensuring that things like loops and functions and so on neatly map to the BTB.
