1
00:00:00,350 --> 00:00:03,330
The absolutely indispensable
element of dynamic programming

2
00:00:03,330 --> 00:00:06,520
is what we'll call an optimal
similar substructure.

3
00:00:06,520 --> 00:00:10,360
By this I mean that we have some hard
problems that we want to solve and

4
00:00:10,360 --> 00:00:14,250
we think to ourselves, oh, if I only
had the answer to these two similar,

5
00:00:14,250 --> 00:00:17,230
smaller subproblems this would be easy.

6
00:00:17,230 --> 00:00:20,200
And because the subproblems
are similar to the original,

7
00:00:20,200 --> 00:00:23,160
we can keep playing this game,
letting the problems get smaller and

8
00:00:23,160 --> 00:00:26,340
smaller, until we've
reached a trivial case.

9
00:00:26,340 --> 00:00:29,900
Well, at first, this feels like
an ideal case for recursion.

10
00:00:29,900 --> 00:00:33,660
Since those subproblems are similar,
perhaps we can use the same code and

11
00:00:33,660 --> 00:00:35,510
just change the parameters.

12
00:00:35,510 --> 00:00:38,410
Starting from this hard problem,
we could recurse back to this one,

13
00:00:38,410 --> 00:00:40,670
and then to this one, and so

14
00:00:40,670 --> 00:00:45,060
forth using this whole subgraph
here to solve this subproblem.

15
00:00:45,060 --> 00:00:49,380
But when we recurse through this branch
we would come to this node again and

16
00:00:49,380 --> 00:00:53,570
do all this recomputation again,
which would be terribly wasteful.

17
00:00:53,570 --> 00:00:56,531
This is sometimes called one
of the perils of recursion.

18
00:00:56,531 --> 00:00:59,724
And it's often illustrated to beginning
programmers with the example of

19
00:00:59,724 --> 00:01:02,170
computing the Fibonacci sequence.

20
00:01:02,170 --> 00:01:06,710
Each number in the Fibonacci sequence is
the sum of the previous two numbers, and

21
00:01:06,710 --> 00:01:10,000
the first two numbers
are one to get us started.

22
00:01:10,000 --> 00:01:14,457
This hard problem of computing the nth
number in the sequence depends on

23
00:01:14,457 --> 00:01:18,471
solving the slightly easier
problems of computing the n-1 and

24
00:01:18,471 --> 00:01:20,788
the n-2 elements in the sequence.

25
00:01:20,788 --> 00:01:26,124
Figuring out n-1 depends
on n-2 as well as n-3.

26
00:01:26,124 --> 00:01:32,153
N-2 depends on knowing the answer
to n-3 and n-4, and so forth.

27
00:01:32,153 --> 00:01:36,661
Thinking about how the recursion
will operate here,

28
00:01:36,661 --> 00:01:43,083
notice that we need to compute Fn-2
once for Fn, and once also for Fn-1.

29
00:01:43,083 --> 00:01:46,052
So there's going to be some
repeated computation here, and

30
00:01:46,052 --> 00:01:49,800
it's going to get worse and
worse the further to the left we go.

31
00:01:49,800 --> 00:01:51,418
How bad does it get?

32
00:01:51,418 --> 00:01:56,310
Well, the top-level problem of computing
the nth number will only be called once,

33
00:01:56,310 --> 00:02:00,910
and here we'll call the f-1
subproblem once as well.

34
00:02:00,910 --> 00:02:04,590
Computing S of n- 2
needs to happen once for

35
00:02:04,590 --> 00:02:09,100
each time that the 2 computations
that depend on it are called.

36
00:02:09,100 --> 00:02:12,427
Once for n- 1 and once for n.

37
00:02:12,427 --> 00:02:15,590
Similarly, n -3 needs
to be called once for

38
00:02:15,590 --> 00:02:20,580
every time that the subproblems
that depend on it are called.

39
00:02:20,580 --> 00:02:26,565
Twice for Fn-2 and once for
Sn-1 for a total of 3.

40
00:02:26,565 --> 00:02:33,120
Fn-4 gets computed once for
each time that Fn0-3 is called and

41
00:02:33,120 --> 00:02:38,440
once for each time that Fn-2
is called for a total of 5.

42
00:02:38,440 --> 00:02:43,250
Notice that each number here is the sum
of the two numbers to the right.

43
00:02:43,250 --> 00:02:47,650
So this actually is the Fibonacci
sequence, and the number of the times

44
00:02:47,650 --> 00:02:53,060
that the n-kth number is computed will
be equal to the kth Fibonacci number,

45
00:02:53,060 --> 00:02:56,590
which is roughly the golden
ratio raised to the kth power.

46
00:02:56,590 --> 00:02:57,760
So yikes!

47
00:02:57,760 --> 00:03:00,680
This recursive strategy is exponential.

48
00:03:00,680 --> 00:03:04,190
Of course, computing the Fibonacci
numbers doesn't need to be exponential.

49
00:03:04,190 --> 00:03:06,594
We could just start on the left here,

50
00:03:06,594 --> 00:03:09,786
initializing the first
two numbers to 1 and 1.

51
00:03:09,786 --> 00:03:10,489
And then,

52
00:03:10,489 --> 00:03:15,267
compute the next one as the sum of
the previous two with a simple for loop.

53
00:03:15,267 --> 00:03:18,860
There are two ways to cope with this
problem of repeated computation.

54
00:03:18,860 --> 00:03:22,330
One, is to memoized the answer
to the subproblems.

55
00:03:22,330 --> 00:03:26,690
After we solve it the first time we
write ourselves a memo with the answer

56
00:03:26,690 --> 00:03:29,540
and before we actually do
the work of solving a subproblem

57
00:03:29,540 --> 00:03:33,420
we always check our wall of memos to
see if we have the answer already.

58
00:03:33,420 --> 00:03:37,430
So for instance, for this subproblem
here I would have memoized it,

59
00:03:37,430 --> 00:03:40,400
written myself a memo to remember
that I've already done it.

60
00:03:40,400 --> 00:03:44,540
And so, when I come this path here,
I wouldn't redo all this computations.

61
00:03:44,540 --> 00:03:46,530
I'd just look up the answer.

62
00:03:46,530 --> 00:03:50,360
Alternatively, we can solve
the subproblems in the right order, so

63
00:03:50,360 --> 00:03:53,230
that any time we want to solve one
of these problems we're sure that we

64
00:03:53,230 --> 00:03:56,040
have the answer to its
subproblems already.

65
00:03:56,040 --> 00:03:59,480
This can always be done because
the dependency relationships

66
00:03:59,480 --> 00:04:03,690
among the subproblems must
form a directed graph.

67
00:04:03,690 --> 00:04:07,330
If they're a cycle, then we would
have a circular dependence and

68
00:04:07,330 --> 00:04:09,370
the recursion wouldn't work either.

69
00:04:09,370 --> 00:04:13,240
So we just find an appropriate ordering
of the subproblems so that all the edges

70
00:04:13,240 --> 00:04:18,450
go left to right, and then we solve
the subproblems in left to right order.

71
00:04:18,450 --> 00:04:20,899
This is the approach we'll take for
this lesson.

72
00:04:20,899 --> 00:04:24,290
It tends to expose more of the
underlying nature of the problem, and

73
00:04:24,290 --> 00:04:28,100
create faster implementations than
using recursion and memoizing.
