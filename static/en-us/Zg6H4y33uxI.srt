1
00:00:00,000 --> 00:00:04,000
Let's talk about a final implication of the interaction between testing domains

2
00:00:04,000 --> 00:00:07,000
and trust relationships between different entities.

3
00:00:07,000 --> 00:00:09,000
Let's say we have some sort of an interface here,

4
00:00:09,000 --> 00:00:12,000
and on both sides of it we have people we trust.

5
00:00:12,000 --> 00:00:15,000
Here's me, here are some of my teammates.

6
00:00:15,000 --> 00:00:18,000
And so the question we have to ask is can I trust my teammates,

7
00:00:18,000 --> 00:00:23,000
and can my teammates trust me to always generate inputs when using the various APIs

8
00:00:23,000 --> 00:00:26,000
that remain within the domain of those inputs?

9
00:00:26,000 --> 00:00:28,000
And of course the answer is generally no.

10
00:00:28,000 --> 00:00:31,000
In fact, I probably can't even trust myself to always generate inputs

11
00:00:31,000 --> 00:00:36,000
that are within the domain of acceptable inputs for APIs.

12
00:00:36,000 --> 00:00:38,000
And so what this brings us to is the idea of defensive coding--

13
00:00:38,000 --> 00:00:42,000
that is to say, error checking--for its own sake to detect internal inconsistencies,

14
00:00:42,000 --> 00:00:44,000
and this is something that we'll get to a little bit later during this unit.

15
00:00:44,000 --> 00:00:50,000
So overall, testing software by calling into the APIs that it provides is fairly straightforward.

16
00:00:50,000 --> 00:00:55,000
We just make calls into the API and look at the results.

17
00:00:55,000 --> 00:01:00,000
But something inconvenient about real software is that software doesn't just provide APIs,

18
00:01:00,000 --> 00:01:02,000
it also uses them.

19
00:01:02,000 --> 00:01:04,000
What I mean here is that the software under test

20
00:01:04,000 --> 00:01:09,000
is going to be issuing calls into libraries and getting return values into the operating system

21
00:01:09,000 --> 00:01:12,000
and into virtual machines such as the Python runtime.

22
00:01:12,000 --> 00:01:15,000
So let's take, for example, just for the next couple of minutes

23
00:01:15,000 --> 00:01:18,000
the idea that the software under test is something like a web browser.

24
00:01:18,000 --> 00:01:23,000
One thing we can do is test the web browser using the APIs that it provides--

25
00:01:23,000 --> 00:01:26,000
that is to say, using its graphical user interface--

26
00:01:26,000 --> 00:01:30,000
and not worry about testing it with respect to the APIs that it uses.

27
00:01:30,000 --> 00:01:32,000
And so what kind of APIs is the web browser using?

28
00:01:32,000 --> 00:01:35,000
For one thing, it's talking to the network,

29
00:01:35,000 --> 00:01:38,000
it's talking to the hard disk through the operating system,

30
00:01:38,000 --> 00:01:40,000
it's talking to all sorts of lower level interfaces.

31
00:01:40,000 --> 00:01:44,000
And sometimes those APIs don't act as we would expect.

32
00:01:44,000 --> 00:01:49,000
Just as a simple example, let's take the case where our web browser is storing cookies--

33
00:01:49,000 --> 00:01:51,000
here I'm trying to draw a chocolate chip cookie--

34
00:01:51,000 --> 00:01:53,000
onto the hard drive of the local computer.

35
00:01:53,000 --> 00:01:56,000
Most of the time during testing, we expect the storage and retrieval of cookies

36
00:01:56,000 --> 00:01:58,000
to operate perfectly normally.

37
00:01:58,000 --> 00:02:00,000
But what happens if, for example, the hard disk is full

38
00:02:00,000 --> 00:02:02,000
when the web browser tries to store a cookie?

39
00:02:02,000 --> 00:02:04,000
Does the web browser crash?

40
00:02:04,000 --> 00:02:08,000
Does it mangle its internal state in some fashion and become impossible to use?

41
00:02:08,000 --> 00:02:12,000
Or does it gracefully stop storing cookies for that session

42
00:02:12,000 --> 00:02:15,000
and, for example, wait until there's more disk space free

43
00:02:15,000 --> 00:02:17,000
before it starts to store cookies again?

44
00:02:17,000 --> 00:02:20,000
Of course we'd like our web browser to do the right thing, whatever it is,

45
00:02:20,000 --> 00:02:22,000
but on the other hand, we need to actually test this.

46
00:02:22,000 --> 00:02:24,000
If we just hope that the software does the right thing,

47
00:02:24,000 --> 00:02:29,000
then one of the golden rules of testing is we shouldn't ever just hope that it does something;

48
00:02:29,000 --> 00:02:31,000
we need to actually check this.

49
00:02:31,000 --> 00:02:34,000
So the problem is that we have this fairly awkward problem

50
00:02:34,000 --> 00:02:37,000
where we don't actually control how the operating system responds

51
00:02:37,000 --> 00:02:39,000
to calls that we make.

52
00:02:39,000 --> 00:02:41,000
And what I mean by that is the awkward thing here

53
00:02:41,000 --> 00:02:44,000
is that we don't actually have direct control

54
00:02:44,000 --> 00:02:47,000
over how the operating system responds to calls that we make.

55
00:02:47,000 --> 00:02:51,000
So we can't easily just make storage of a cookie file fail.

56
00:02:51,000 --> 00:02:55,000
Rather, we would have to do something like create a full disk partition,

57
00:02:55,000 --> 00:02:58,000
arrange for our web browser to store cookies there, and then see how it responds.

58
00:02:58,000 --> 00:03:03,000
And so in this particular case, creating a full disk partition is awkward, but we could do it,

59
00:03:03,000 --> 00:03:07,000
but there are plenty of cases where lower level software has failure modes

60
00:03:07,000 --> 00:03:10,000
that we really can't easily simulate, regardless of how hard we work.

61
00:03:10,000 --> 00:03:14,000
So what we're going to do now is go back to our friend the UNIX read system call.

62
00:03:14,000 --> 00:03:16,000
Let's take another quick look at the UNIX read system call.

63
00:03:16,000 --> 00:03:19,000
And so this is our UNIX process's read from files,

64
00:03:19,000 --> 00:03:23,000
and so of course real UNIX programs are issuing calls to read constantly,

65
00:03:23,000 --> 00:03:25,000
maybe hundreds of times per second.

66
00:03:25,000 --> 00:03:28,000
And so earlier, we were concerned with the domain of the read system call--

67
00:03:28,000 --> 00:03:32,000
that is to say, the set of possible valid arguments to the read system call--

68
00:03:32,000 --> 00:03:34,000
and now we're concerned with the range

69
00:03:34,000 --> 00:03:37,000
because now we're not testing the UNIX operating system anymore;

70
00:03:37,000 --> 00:03:39,000
we're testing a program that runs on top of the UNIX operating system.

71
00:03:39,000 --> 00:03:45,000
And so it's the response of the operating system back to the process that concerns us here.

72
00:03:45,000 --> 00:03:48,000
We can see here that read returns the number of bytes read from a file,

73
00:03:48,000 --> 00:03:52,000
but there's an interesting fact here that read is allowed to read

74
00:03:52,000 --> 00:03:54,000
less bytes than you actually asked for.

75
00:03:54,000 --> 00:03:57,000
So it's going to return some number between 0 and count,

76
00:03:57,000 --> 00:03:59,000
but we don't know what number it's going to return.

77
00:03:59,000 --> 00:04:02,000
Another thing that read can do is just fail outright--

78
00:04:02,000 --> 00:04:06,000
that is to say, it can return -1 to the application--

79
00:04:06,000 --> 00:04:11,000
but it turns out that there are a whole lot of different reasons for that kind of a failure.

80
00:04:11,000 --> 00:04:15,000
We can see here that there are at least 9 different error conditions that read can return.

81
00:04:15,000 --> 00:04:20,000
We have EAGAIN, EWOULDBLOCK, EBADF, EFAULT, etc.

82
00:04:20,000 --> 00:04:24,000
And the point is for the application that's calling read,

83
00:04:24,000 --> 00:04:27,000
the operating system can return any of these values,

84
00:04:27,000 --> 00:04:30,000
and these values aren't all semantically equivalent.

85
00:04:30,000 --> 00:04:33,000
The application might have to do different things depending on which of these values it gets.

86
00:04:33,000 --> 00:04:38,000
And the point is it might be very hard as people testing the web browser

87
00:04:38,000 --> 00:04:43,000
to actually make the operating system read call return all of those different values.

88
00:04:43,000 --> 00:04:45,000
And until we've tested it with all of those different values,

89
00:04:45,000 --> 00:04:49,000
we're left with software whose behavior we probably don't understand,

90
00:04:49,000 --> 00:04:52,000
and, therefore, it's software that hasn't been tested very well.

91
00:04:52,000 --> 00:04:55,000
And so I'd like to tell you that there's some really great solution to this problem,

92
00:04:55,000 --> 00:04:57,000
but there really isn't.

93
00:04:57,000 --> 00:05:00,000
And the fact is that a lot of real programs that run on operating systems

94
00:05:00,000 --> 00:05:03,000
aren't prepared for some of these odder, stranger responses

95
00:05:03,000 --> 00:05:05,000
that the operating systems can deliver,

96
00:05:05,000 --> 99:59:59,999
and, consequently, when those things happen, the software malfunctions.
