1
00:00:00,000 --> 00:00:05,000
It's sort of cool that Top K via partitioning as just described works.

2
00:00:05,000 --> 00:00:08,000
It gets us the Top K values in a not sorted order.

3
00:00:08,000 --> 00:00:15,000
Right. Let's do an analysis of the time it takes for a Top K to do its work via this partitioning approach.

4
00:00:15,000 --> 00:00:19,000
And because it's recursive algorithm, it's going to help to set this up in terms of recurrence relations.

5
00:00:19,000 --> 00:00:22,000
Here's the recurrence relation we want to solve.

6
00:00:22,000 --> 00:00:27,000
The time it takes to run Top K via partitioning on one element.

7
00:00:27,000 --> 00:00:32,000
Let's call that 1, and the time that it takes to run an n element

8
00:00:32,000 --> 00:00:37,000
is going to be hard to write down exactly but we can put down a bound. So what does it do?

9
00:00:37,000 --> 00:00:41,000
First, it does the partitioning operation, which runs through all the elements of the list

10
00:00:41,000 --> 00:00:46,000
that takes time n and then it's going to recurse assuming it hasn't gotten really lucky

11
00:00:46,000 --> 00:00:50,000
and since this is a less than or equal to let's assume it didn't get lucky.

12
00:00:50,000 --> 00:00:52,000
It's going to recurse on either the left or the right.

13
00:00:52,000 --> 00:00:58,000
Now, the partitioning algorithm is going to split this list L into a left and a right.

14
00:00:58,000 --> 00:01:01,000
In different cases, it's going to recurse on either the left or the right.

15
00:01:01,000 --> 00:01:05,000
But we don't know which one it's going to recurse on and we don't know which one is bigger.

16
00:01:05,000 --> 00:01:10,000
What do we know? Well, it's just as likely for the left to be bigger

17
00:01:10,000 --> 00:01:13,000
as it is for the right to be bigger and vice versa.

18
00:01:13,000 --> 00:01:17,000
Really you can imagine with justification that with probability of half

19
00:01:17,000 --> 00:01:22,000
the left side is bigger and in particular bigger than size n/2

20
00:01:22,000 --> 00:01:28,000
and in half the cases right is bigger and again bigger meaning it's going to be at least size n/2.

21
00:01:28,000 --> 00:01:32,000
If the recursive algorithm gets called on the smaller half

22
00:01:32,000 --> 00:01:39,000
then the work that it has to do is whatever the recursive running time is on at least of size n/2

23
00:01:39,000 --> 00:01:43,000
or smaller as this is an upper bound and that happens with the probability of half

24
00:01:43,000 --> 00:01:46,000
but we might also get unlucky and have to recurse on the larger half,

25
00:01:46,000 --> 00:01:51,000
which could involve actually something almost the size of the entire list.

26
00:01:51,000 --> 00:01:55,000
It's kind of a weird recurrence relation because it has probabilities in it

27
00:01:55,000 --> 00:01:58,000
but really we want a bound on the running time.

28
00:01:58,000 --> 00:02:05,000
How many steps it's going to take in this case on average for Top K to finish each stop.

29
00:02:05,000 --> 00:02:08,000
I mean this gives us an upper bound. This recurrence relation gives us an upper bound.

30
00:02:08,000 --> 00:02:11,000
All right so to solve this recurrence relation, I'm going to cheat a little bit

31
00:02:11,000 --> 00:02:18,000
because I know that 4n is going to be a good upper bound on the value of T(n).

32
00:02:18,000 --> 00:02:22,000
All we have to do is actually prove that that's true. We don't actually have to figure it out.

33
00:02:22,000 --> 00:02:26,000
To prove that this is true we're going to proceed by induction.

34
00:02:26,000 --> 00:02:32,000
Our base case is T(1) = 1, which is indeed less than or equal to 4.

35
00:02:32,000 --> 00:02:37,000
For inductive step, we know from the structure of the algorithm

36
00:02:37,000 --> 00:02:42,000
that the time it takes to handle an input of size n is on average going to be

37
00:02:42,000 --> 00:02:49,000
less than or equal to n+1/2T(n/2)+1/2T(n) just like we argued before.

38
00:02:49,000 --> 00:02:53,000
And now we're going to use our inductive hypothesis that T(n) â¤ 4n

39
00:02:53,000 --> 00:02:55,000
to get an upper bound on this quantity.

40
00:02:55,000 --> 00:03:04,000
T(n/2) we're assuming is upper bounded by 4n/2, which is 2n,

41
00:03:04,000 --> 00:03:08,000
and this quantity T(n) we're assuming is less than 4n.

42
00:03:08,000 --> 00:03:12,000
Now this is a little bit of a mathematical abuse of induction.

43
00:03:12,000 --> 00:03:16,000
We really don't want this to be n here because our inductive step is going to assume this

44
00:03:16,000 --> 00:03:19,000
true for everything smaller than n and not equal to n

45
00:03:19,000 --> 00:03:22,000
but the reality is this is actually a tiny little bit less than n.

46
00:03:22,000 --> 00:03:27,000
The worst possible case that you get in this algorithm is we pick the partition on the n,

47
00:03:27,000 --> 00:03:29,000
and then we recurse on everything but the n.

48
00:03:29,000 --> 00:03:33,000
There's t(n-1) here but it's--with apologies, you can make these

49
00:03:33,000 --> 00:03:37,000
details all work out but it's a little irritating.

50
00:03:37,000 --> 00:03:49,000
With that caveat, we proceed. What we have is this is equal to n+n+2n, which is indeed 4n.

51
00:03:49,000 --> 00:03:56,000
We've now shown that for each value of n, T(n) is always upper bounded by 4n.

52
00:03:56,000 --> 00:03:59,000
And that's what we wanted to show, but this is pretty remarkable.

53
00:03:59,000 --> 00:04:04,000
Because what that means is we actually find the Top K elements in Î(n).

54
00:04:04,000 --> 00:04:10,000
You know 4n is Î(n) so the running time is going to be linear, which is pretty neat.
