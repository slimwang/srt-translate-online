1
00:00:00,000 --> 00:00:05,000
[Thrun] So in this next assignment, I'd like you to fix certain data points.

2
00:00:05,000 --> 00:00:08,000
Just as much as you fixed the data points originally in our path,

3
00:00:08,000 --> 00:00:12,000
the beginning and end point, now I want to fix you 4 points.

4
00:00:12,000 --> 00:00:15,000
These are the corner points in our data points.

5
00:00:15,000 --> 00:00:18,000
In our original data, it's the one over here, the one over here,

6
00:00:18,000 --> 00:00:21,000
and I want those to be fixed so they can't move.

7
00:00:21,000 --> 00:00:27,000
And the way I indicated this in the code is by giving you a fix array that looks like this

8
00:00:27,000 --> 00:00:29,000
where each of these numbers corresponds to exactly 1 data point.

9
00:00:29,000 --> 00:00:32,000
There's as many elements in fix as there is in path.

10
00:00:32,000 --> 00:00:37,000
And then when I call smooth, I add fix as a parameter.

11
00:00:37,000 --> 00:00:40,000
So when you change the procedure and run it,

12
00:00:40,000 --> 00:00:42,000
I can tell you you should be surprised by the output

13
00:00:42,000 --> 00:00:48,000
in that when I run my procedure it copies over the initial path into the output.

14
00:00:48,000 --> 00:00:52,000
We'll talk about this in a second, but please go ahead and change your procedure

15
00:00:52,000 --> 00:00:57,000
so that your output ends up to be giving you something very much like this.

16
00:00:57,000 --> 00:00:59,000
The modification is simple.

17
00:00:59,000 --> 00:01:03,000
As I go through my data points, I only apply the update if it's not fixed.

18
00:01:03,000 --> 00:01:07,000
So if the fix flag is not set, they go in here.

19
00:01:07,000 --> 00:01:09,000
This is all indented one compared to before.

20
00:01:09,000 --> 00:01:11,000
It's a single line change.

21
00:01:11,000 --> 00:01:13,000
Let me tell you why this doesn't work.

22
00:01:13,000 --> 00:01:15,000
Consider a few data points like these.

23
00:01:15,000 --> 00:01:17,000
If you fix this data point over here,

24
00:01:17,000 --> 00:01:21,000
then this guy is perfectly happy with his 2 neighbors--

25
00:01:21,000 --> 00:01:23,000
this is a smooth path--

26
00:01:23,000 --> 00:01:25,000
and so is this guy over here.

27
00:01:25,000 --> 00:01:28,000
The only data point that's unhappy is the one over here

28
00:01:28,000 --> 00:01:30,000
because it's not part of a very smooth path,

29
00:01:30,000 --> 00:01:32,000
but this one is never being updated.

30
00:01:32,000 --> 00:01:35,000
So as a result, all the other ones stay where they are.

31
00:01:35,000 --> 00:01:39,000
They already have the absolute minimum for smoothness and for the data fit.

32
00:01:39,000 --> 00:01:43,000
No updates take change, and we don't have the desired result.

33
00:01:43,000 --> 00:01:46,000
We don't get a nice round curve the way we wish to get it.

34
00:01:46,000 --> 00:01:51,000
To get this, we are going to modify our rule a little bit now, and that's the interesting part.

35
00:01:51,000 --> 00:01:54,000
For a node like this with coordinates xi and yi,

36
00:01:54,000 --> 00:01:59,000
we add to it with a very small constant gamma--

37
00:01:59,000 --> 00:02:04,000
in fact, it will be half our weight smoothing constant in a minute--

38
00:02:04,000 --> 00:02:06,000
2 times the previous guy--

39
00:02:06,000 --> 00:02:09,000
and of course that's cyclic, so you have to make sure this is really cyclic--

40
00:02:09,000 --> 00:02:14,000
minus the guy 2 steps away and minus our node.

41
00:02:14,000 --> 00:02:19,000
Why this makes sense we see when we go into the opposite direction.

42
00:02:19,000 --> 00:02:26,000
Here we add a small gamma, 2 times this guy over here minus this guy here

43
00:02:26,000 --> 00:02:28,000
minus our original data point.

44
00:02:28,000 --> 00:02:30,000
And behind this is a certain desire.

45
00:02:30,000 --> 00:02:34,000
We want the vector over here to be the same as the vector over here.

46
00:02:34,000 --> 00:02:41,000
This vector is this difference over here of xi + 1 over yi + 1 - xi over yi.

47
00:02:41,000 --> 00:02:44,000
That is this vector over here.

48
00:02:44,000 --> 00:02:51,000
And the vector over here is similarly the difference of the point i + 2

49
00:02:51,000 --> 00:02:53,000
minus the same for i + 1.

50
00:02:53,000 --> 00:02:58,000
If you set these to be equal and bring yi to the right side,

51
00:02:58,000 --> 00:03:05,000
then if you modify yi in proportion to this expression over here, we reduce the error.

52
00:03:05,000 --> 00:03:11,000
In fact, the expression in the brackets is the same as this one, called (A),

53
00:03:11,000 --> 00:03:14,000
minus this one, called (B).

54
00:03:14,000 --> 00:03:16,000
So we're looking at the mismatch between these 2 vectors

55
00:03:16,000 --> 00:03:20,000
and use it to adjust the xi factor over here.

56
00:03:20,000 --> 00:03:23,000
We do those sequentially--this one first, this one second.

57
00:03:23,000 --> 00:03:25,000
You might call them a little bit sloppy

58
00:03:25,000 --> 00:03:29,000
because the first update already inferences the second update. But who cares?

59
00:03:29,000 --> 00:03:32,000
We're just going to add lines of code that achieve this over here,

60
00:03:32,000 --> 00:03:38,000
and when you do this, please make sure that your update

61
00:03:38,000 --> 00:03:41,000
understands the fact that these indices are cyclic.

62
00:03:41,000 --> 00:03:43,000
So I did this in my code and I'm running it,

63
00:03:43,000 --> 00:03:46,000
and out come the following numbers that you can read over here.

64
00:03:46,000 --> 00:03:50,000
These numbers are indeed a cycle.

65
00:03:50,000 --> 00:03:53,000
So if we were to plot them--and this is the original data--

66
00:03:53,000 --> 00:03:55,000
these are the points we would constant,

67
00:03:55,000 --> 00:04:00,000
then the new data lies in over very much like this. You can plot them.

68
00:04:00,000 --> 00:04:04,000
Unfortunately, I can't plot them in our environment here, but you could see this.

69
00:04:04,000 --> 00:04:06,000
Now we are not shifting the racetrack inbound anymore.

70
00:04:06,000 --> 00:04:11,000
Please go to your code and modify the function smooth by doing these new constraints.

71
00:04:11,000 --> 00:04:18,000
For the update strength, I suggest you use half of weight_smooth for each update.

72
00:04:18,000 --> 00:04:22,000
So in total, you add another 0.1 as update strength.
