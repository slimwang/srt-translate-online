1
00:00:00,300 --> 00:00:03,468
I find myself usually modifying the fragment shader in a program, since that's

2
00:00:03,468 --> 00:00:07,486
where all the per pixel processing is happening. Let's back up a bit and show

3
00:00:07,486 --> 00:00:11,738
how various parameters were produced by the vertex shader. The position and

4
00:00:11,738 --> 00:00:15,548
normal of the vertex are passed in with these names, position and normal. A few

5
00:00:15,548 --> 00:00:19,139
built in matrices are used for transformation, namely projectionMatrix,

6
00:00:19,139 --> 00:00:23,602
modelViewMatrix and normalMatrix. In Three.js, these are always available to

7
00:00:23,602 --> 00:00:28,020
the shader if desired. In WebGL itself you need to do a little more work.

8
00:00:28,020 --> 00:00:30,792
There's currently not a modelViewProjectionMatrix of these two matrices

9
00:00:30,792 --> 00:00:34,354
multiplied together. Maybe you'll be the person to add it to Three.js, as it's

10
00:00:34,354 --> 00:00:38,540
commonly used and would be more efficient to use here. What we get out of this

11
00:00:38,540 --> 00:00:42,455
shader are a few vectors. First the gl.Position is set, which is the location

12
00:00:42,455 --> 00:00:46,700
in clip coordinates. This vector must always be set by the vertex shader, at a

13
00:00:46,700 --> 00:00:50,114
minimum. One of the features of the vertex shader is that you can change the

14
00:00:50,114 --> 00:00:53,613
shape of an object. You can't really change it in the fragment shader. The

15
00:00:53,613 --> 00:00:58,400
normal in modelView space is computed here, using the normal transform matrix.

16
00:00:58,400 --> 00:01:01,487
Finally, a vector from the location in modelView space toward the viewer is

17
00:01:01,487 --> 00:01:05,025
computed. First the position in modelView space is computed, and then negating

18
00:01:05,025 --> 00:01:07,798
this vector gives the direction toward the viewer from the surface, instead of

19
00:01:07,798 --> 00:01:12,210
from the viewer to object. Remember that the camera's at the origin in View

20
00:01:12,210 --> 00:01:15,970
space. We don't really need the temporary mvPosition vector. We could have

21
00:01:15,970 --> 00:01:19,482
combined these last two lines of code. This example is here to show how to

22
00:01:19,482 --> 00:01:22,676
compute it. To sum up, the vertex shader took as inputs the model space

23
00:01:22,676 --> 00:01:26,860
position and normal. It transformed them to create a point in clip coordinates

24
00:01:26,860 --> 00:01:31,264
for the rasterizer. It also transformed the normal and position. The resulting

25
00:01:31,264 --> 00:01:34,037
transform vertices are then interpolated across the triangle during

26
00:01:34,037 --> 00:01:38,159
rasterization, and sent to the fragment shader for each fragment produced.
