1
00:00:00,380 --> 00:00:03,570
At the beginning of each module all I
ask you to open up a playground file

2
00:00:03,570 --> 00:00:04,970
like this one.

3
00:00:04,970 --> 00:00:07,930
That file will contain the examples
I will walk through so

4
00:00:07,930 --> 00:00:09,640
you can follow along.

5
00:00:09,640 --> 00:00:13,680
A second file will contain exercises for
you to do on your own.

6
00:00:13,680 --> 00:00:16,960
You can download all the files for the
course from the link in the instructors

7
00:00:16,960 --> 00:00:18,910
notes at the beginning of each lesson.

8
00:00:18,910 --> 00:00:21,729
Go ahead and download the playground
files for lesson one now.

9
00:00:22,960 --> 00:00:27,930
Then open up the file entitled
Lesson One, Types and Operators.

10
00:00:27,930 --> 00:00:29,880
If your playground doesn't
look like this, but

11
00:00:29,880 --> 00:00:32,159
instead has a bunch of green comments.

12
00:00:32,159 --> 00:00:35,790
You'll want to change one of
the settings up here in the editor menu.

13
00:00:35,790 --> 00:00:39,920
Go down to here where where my
menu says Show Raw Markup.

14
00:00:39,920 --> 00:00:42,790
Yours might say Show Rendered Markup.

15
00:00:42,790 --> 00:00:45,560
So you want to click on it if
it says Show Rendered Markup.

16
00:00:46,590 --> 00:00:48,680
Then it should look like this.

17
00:00:48,680 --> 00:00:51,270
I'm going to start by quickly
running through the definitions of

18
00:00:51,270 --> 00:00:53,060
Swift's primitive types.

19
00:00:53,060 --> 00:00:55,990
Swift's primitive types don't
have too many surprises.

20
00:00:55,990 --> 00:00:59,990
Here in this LightSwitch class
the on property is a bool.

21
00:00:59,990 --> 00:01:03,160
Swift booleans always have
a value of true or false.

22
00:01:03,160 --> 00:01:08,500
They can't be assigned to zero or one as
in C, or YES or NO as in Objective C.

23
00:01:08,500 --> 00:01:11,740
If you don't recognize any
of this syntax, don't worry.

24
00:01:11,740 --> 00:01:13,320
That's to be expected.

25
00:01:13,320 --> 00:01:14,280
I'll explain class and

26
00:01:14,280 --> 00:01:18,100
property definitions soon,
along with this dot syntax.

27
00:01:18,100 --> 00:01:20,860
For now just focus on the data types.

28
00:01:20,860 --> 00:01:23,570
For properties that need
to hold continuous values,

29
00:01:23,570 --> 00:01:26,550
we might want to use the int type,
which holds an integer.

30
00:01:26,550 --> 00:01:28,655
For example if our light
switch had a dimmer.

31
00:01:28,655 --> 00:01:31,025
I'll give our LightSwitch 
a dimmer property.

32
00:01:31,025 --> 00:01:33,455
And then I'll set that dimmer
property to be of type int.

33
00:01:34,715 --> 00:01:37,645
What if we wanted to
set our dimmer to pi.

34
00:01:37,645 --> 00:01:41,365
If we want this dimmer property
to be able to represent decimals,

35
00:01:41,365 --> 00:01:43,485
we can try using a float
instead of an int.

36
00:01:45,090 --> 00:01:49,740
Of course if we use a double then we can
get a more precise representation of pi.

37
00:01:49,740 --> 00:01:51,770
Here I've carried it
out to eleven digits.

38
00:01:51,770 --> 00:01:52,800
Between float and double,

39
00:01:52,800 --> 00:01:56,070
you can decide which type to use based
on the level of precision you need.

40
00:01:57,200 --> 00:02:00,950
Strings and characters in Swift
are pretty much as you would expect.

41
00:02:00,950 --> 00:02:03,570
Naturally the character type
holds a single character,

42
00:02:03,570 --> 00:02:08,650
and the string type represents
an ordered collection of characters.

43
00:02:08,650 --> 00:02:11,180
The Swift string type comes
with a handy bag of tricks,

44
00:02:11,180 --> 00:02:13,920
that makes string manipulations nice and
concise.

45
00:02:13,920 --> 00:02:15,700
Like this simple string concatenation.

46
00:02:15,700 --> 00:02:20,010
Here in the playground sidebar you
can see the concatenated string.

47
00:02:20,010 --> 00:02:23,730
We'll have more fun with strings and
the exercises at the end of the lesson.

48
00:02:23,730 --> 00:02:27,440
There are two other Swift types
that require a deeper dive.

49
00:02:27,440 --> 00:02:31,190
The first is the optional type,
which is the focus of the next lesson.

50
00:02:31,190 --> 00:02:35,510
And the second is tuples, which we'll
talk about in the collections lesson.

51
00:02:35,510 --> 00:02:38,430
For now, just know of their existence.

52
00:02:38,430 --> 00:02:42,050
Before we finish,
there's a secret I haven't revealed.

53
00:02:42,050 --> 00:02:44,989
See how I've indicated the type for
each of these variables?

54
00:02:46,120 --> 00:02:49,260
I can actually take all of
these type indicators out.

55
00:02:51,540 --> 00:02:54,910
But the compiler is having no
problem inferring the correct type.

56
00:02:54,910 --> 00:02:59,460
And we can even test that by taking
a look at the type of these variables.

57
00:02:59,460 --> 00:03:01,950
Let's try this concatenated string.

58
00:03:01,950 --> 00:03:06,690
This dynamic type property can be
used to investigate any objects type.

59
00:03:06,690 --> 00:03:10,740
And we can see over here in the sidebar
that the type of concatenated string

60
00:03:10,740 --> 00:03:12,140
is a Swift string.

61
00:03:12,140 --> 00:03:14,070
And the compiler was able to infer that,

62
00:03:14,070 --> 00:03:17,640
even though we didn't indicate
it directly in the definition.

63
00:03:17,640 --> 00:03:20,710
In the upcoming quiz,
you get to play the role of compiler and

64
00:03:20,710 --> 00:03:22,140
do some type inference of your own.
