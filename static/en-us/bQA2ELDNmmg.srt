1
00:00:00,000 --> 00:00:05,000
Let's now have some fun and apply this to an actual car problem.

2
00:00:05,000 --> 00:00:10,000
The one I'll using is a bit simplified as always,

3
00:00:10,000 --> 00:00:15,000
but it does relate to real world path planning as is done, for example, by Google Maps.

4
00:00:15,000 --> 00:00:17,000
Suppose we have a car down here.

5
00:00:17,000 --> 00:00:23,000
This car now has its state an x, a y, and an orientation, theta.

6
00:00:23,000 --> 00:00:34,000
By orientation for simplicity is chosen from 4 possible directions--up, down, left, and right.

7
00:00:34,000 --> 00:00:39,000
As I quiz you in the beginning, I'd like to get to the location over here, facing left.

8
00:00:39,000 --> 00:00:46,000
Realize that now the state space is 3-dimensional, just like in our localization example.

9
00:00:46,000 --> 00:00:50,000
I now would like to implement a dynamic programming planner

10
00:00:50,000 --> 00:00:53,000
that gives me the optimal path for going from here to here

11
00:00:53,000 --> 00:00:55,000
and that let's me play with cost functions.

12
00:00:55,000 --> 00:00:58,000
There are three principle actions.

13
00:00:58,000 --> 00:01:05,000
One is move in which the car just goes 1 grid cell forward in its present orientation.

14
00:01:05,000 --> 00:01:10,000
It doesn't turn at all. That could be applied anywhere in the maze in any direction.

15
00:01:10,000 --> 00:01:14,000
One is turn left and then move.

16
00:01:14,000 --> 00:01:20,000
This car in this position in the cell over here could chose

17
00:01:20,000 --> 00:01:23,000
the turn left and move, which makes it move over here.

18
00:01:23,000 --> 00:01:26,000
The last one is turn right and move,

19
00:01:26,000 --> 00:01:29,000
in which case it would, from this cell over here,

20
00:01:29,000 --> 00:01:31,000
turn over here and head in this direction.

21
00:01:31,000 --> 00:01:33,000
Here's our world again.

22
00:01:33,000 --> 00:01:36,000
You can see there is a street over here that's navigable, one over here that's navigable.

23
00:01:36,000 --> 00:01:39,000
You see the loop on the right side.

24
00:01:39,000 --> 00:01:43,000
Remember that now this state space is 3-dimensional, not 2- dimensional.

25
00:01:43,000 --> 00:01:47,000
Our goal is to move to cell [2, 0], which is the one over here.

26
00:01:47,000 --> 00:01:50,000
Our initial state is up here,

27
00:01:50,000 --> 00:01:54,000
and the initial state has not just a position of [4, 3] but also an orientation of 0.

28
00:01:54,000 --> 00:01:57,000
It's a 3-dimensional state.

29
00:01:57,000 --> 00:02:02,000
Here are my orientations--0, 1, 2, and 3.

30
00:02:02,000 --> 00:02:05,000
The first one makes the robot go up, the second go left,

31
00:02:05,000 --> 00:02:08,000
third one go down, and the fourth one go right.

32
00:02:08,000 --> 00:02:11,000
Here are the names associated with it---up, left, down, and right.

33
00:02:11,000 --> 00:02:13,000
This thing here is interesting.

34
00:02:13,000 --> 00:02:16,000
As actions, we have 3 actions.

35
00:02:16,000 --> 00:02:20,000
We can add to the index orientation -1, 0, or 1.

36
00:02:20,000 --> 00:02:24,000
If we add -1 we jump 1 up in the cyclic array over here,

37
00:02:24,000 --> 00:02:27,000
which is the same as doing a right turn.

38
00:02:27,000 --> 00:02:34,000
For example, if you go from go left to go up, that the same as turning right.

39
00:02:34,000 --> 00:02:38,000
If we add +1, that's the same as turning left.

40
00:02:38,000 --> 00:02:41,000
If we leave the orientation unchanged,

41
00:02:41,000 --> 00:02:46,000
then we go straight, which is indicated by this hash symbol over here.

42
00:02:46,000 --> 00:02:48,000
These actions come with different costs.

43
00:02:48,000 --> 00:02:51,000
Right now the left turn costs me 2, going straight costs me 1,

44
00:02:51,000 --> 00:02:54,000
and going right costs me 1 as well, which, as we all know,

45
00:02:54,000 --> 00:02:58,000
makes the left turn the preferred solution over here.

46
00:02:58,000 --> 00:03:04,000
Indeed, as I run it, you can see how the car turns left over here to the goal location.

47
00:03:04,000 --> 00:03:10,000
If I were to increase the cost for the left action to 20, then my solution changes.

48
00:03:10,000 --> 00:03:13,000
You can see the car dashes straight ahead over here, turns right over here,

49
00:03:13,000 --> 00:03:18,000
right over here, right over here, and then goes straight to the goal location.

50
00:03:18,000 --> 00:03:21,000
That software I want you to implement. There is one more hint.

51
00:03:21,000 --> 00:03:27,000
The value function itself is 3-dimensional, and here is the code that I've been using.

52
00:03:27,000 --> 00:03:33,000
Not necessarily the most efficient, but it has inside 4 identical arrays

53
00:03:33,000 --> 00:03:37,000
of the size of the grid concatenated into a megagrid

54
00:03:37,000 --> 00:03:41,000
and initialized all by a very large value--999 in this case.

55
00:03:41,000 --> 00:03:47,000
You need functions just like these, and it turns out this makes it more difficult to write the code.

56
00:03:47,000 --> 00:03:50,000
This is our last quiz in this lecture.

57
00:03:50,000 --> 00:03:53,000
Our last programming assignment, and you might spend some time.

58
00:03:53,000 --> 99:59:59,999
It took me a while to program it myself to get an output just like this over here.
