1
00:00:00,880 --> 00:00:05,500
Material design says that motion
design can effectively guide

2
00:00:05,500 --> 00:00:09,240
the user's attention in ways
that both inform and delight.

3
00:00:09,240 --> 00:00:14,240
Use motion to smoothly transport
users between navigational contexts.

4
00:00:14,240 --> 00:00:17,360
Explain changes in the arrangement
of elements on a screen.

5
00:00:17,360 --> 00:00:20,420
And reinforce element hierarchy.

6
00:00:20,420 --> 00:00:22,600
We aren't really doing that yet.

7
00:00:22,600 --> 00:00:26,710
But we can add something that does,
a shared element transition.

8
00:00:26,710 --> 00:00:30,590
When we talk about shared elements,
we're really talking about Android

9
00:00:30,590 --> 00:00:34,710
views that contain content that is
shared between two different activities.

10
00:00:34,710 --> 00:00:37,720
We animate the transition between
the activities by moving and

11
00:00:37,720 --> 00:00:42,090
scaling the element into place,
which draws the eye to the element and

12
00:00:42,090 --> 00:00:44,730
creates continuity between
the two activities.

13
00:00:44,730 --> 00:00:47,760
It's relatively easy to add a shared
element to the transition we've

14
00:00:47,760 --> 00:00:49,130
already created.

15
00:00:49,130 --> 00:00:53,550
We first need to tell Android which
views in both activities are paired up.

16
00:00:53,550 --> 00:00:58,360
We start by adding a transition name
to the view in the destination layout.

17
00:00:58,360 --> 00:01:00,910
We'll also want to add a transition
name to any view that we're

18
00:01:00,910 --> 00:01:02,470
transitioning from.

19
00:01:02,470 --> 00:01:05,650
So that the system can find it again in
case it has to tear down the activity,

20
00:01:05,650 --> 00:01:08,750
thanks to rotating the device or
some other hardware change.

21
00:01:08,750 --> 00:01:12,030
If the shared view is filled out
when the activity is first created,

22
00:01:12,030 --> 00:01:13,660
that's all we'd have to do.

23
00:01:13,660 --> 00:01:17,070
However, many activities do
things like create a fragment and

24
00:01:17,070 --> 00:01:20,030
then need to go to the database
to fetch the shared element.

25
00:01:20,030 --> 00:01:23,080
Both of which typically involve
asynchronous tasks, and

26
00:01:23,080 --> 00:01:26,140
we are using best Android practices.

27
00:01:26,140 --> 00:01:28,470
We also want to wait for
any layout to be complete.

28
00:01:28,470 --> 00:01:30,800
Fortunately there's a solution for that.

29
00:01:30,800 --> 00:01:33,580
We can ask Android to wait
before beginning the transition

30
00:01:33,580 --> 00:01:36,610
using supportPostponeEnterTransition.

31
00:01:36,610 --> 00:01:41,440
And tell it we're ready by using
supportStartPostponedEnterTransition.

32
00:01:41,440 --> 00:01:45,280
We have to a bit careful here
about how long we postpone things,

33
00:01:45,280 --> 00:01:48,960
as we've pretty much stopped
the world in motion when we do this.

34
00:01:48,960 --> 00:01:53,089
I.e., going out to the network while
we postpone things isn't going to

35
00:01:53,089 --> 00:01:54,558
work well.

36
00:01:54,558 --> 00:01:59,220
Since I try very hard to keep
display-related logic in layouts,

37
00:01:59,220 --> 00:02:02,890
I'm going to create an attribute to
enable postponing the enter transition

38
00:02:02,890 --> 00:02:04,600
in forecast fragment.

39
00:02:04,600 --> 00:02:08,150
I then read the attribute
in the onInflate method.

40
00:02:08,150 --> 00:02:11,840
For the detail fragment,
I'll add a flag as an argument and

41
00:02:11,840 --> 00:02:13,610
read it during the onCreateView method.
