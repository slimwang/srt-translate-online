1
00:00:00,410 --> 00:00:04,939
We have seen a RAW based processor, but this processor has not been

2
00:00:04,939 --> 00:00:09,250
a superscalar processor. It was only issuing one instruction per cycle, and

3
00:00:09,250 --> 00:00:12,670
even though we have seen a variant in one of the quizzes that commits up

4
00:00:12,670 --> 00:00:16,190
to two instructions per cycle, the bottom link will still be the issue.

5
00:00:16,190 --> 00:00:20,090
So now let's look at a real superscalar processor. What does it have to do?

6
00:00:20,090 --> 00:00:23,790
First, it needs to fetch more than one instruction per cycle. When we

7
00:00:23,790 --> 00:00:27,320
are really fetching more than one instructions worth of memory per cycle. So

8
00:00:27,320 --> 00:00:30,840
if the instructions are for example four bites and we want to fetch two,

9
00:00:30,840 --> 00:00:33,970
our fetch really needs to supply us with eight bits every cycle.

10
00:00:33,970 --> 00:00:37,040
Then, we need to decode more than one instruction per cycle.

11
00:00:37,040 --> 00:00:39,930
This amounts to basically having more than one decoder.

12
00:00:39,930 --> 00:00:44,230
So, every cycle the first decoder will be looking at the first instruction,

13
00:00:44,230 --> 00:00:48,200
while the second one will be looking at the second instruction we fetched, etc.

14
00:00:48,200 --> 00:00:50,810
Next, we have to issue more than one instruction per cycle.

15
00:00:50,810 --> 00:00:53,050
Remember that we need to issue instructions in order.

16
00:00:53,050 --> 00:00:56,900
So every cycle, we will consider the next instruction that should issue for

17
00:00:56,900 --> 00:01:00,630
issuing. And if it can issue, we will also consider the next instruction, and

18
00:01:00,630 --> 00:01:03,310
if that one can issue, we will consider the next one, and so on.

19
00:01:03,310 --> 00:01:06,540
So for example, if you were trying to issue up to three instructions per cycle,

20
00:01:06,540 --> 00:01:09,520
they still need to be three consecutive instructions, and

21
00:01:09,520 --> 00:01:13,830
if one of them cannot issue, then the following ones cannot issue either.

22
00:01:13,830 --> 00:01:16,670
We want to be able to dispatch more than one instruction per cycle.

23
00:01:16,670 --> 00:01:19,160
We have seen that if we have more than one execution unit,

24
00:01:19,160 --> 00:01:22,350
we actually can dispatch one instruction to each of the units. Effectively,

25
00:01:22,350 --> 00:01:26,240
we will already able to dispatch more than one instruction per cycle. Now,

26
00:01:26,240 --> 00:01:30,170
the problem usually is that you have many more adds than multiplies for

27
00:01:30,170 --> 00:01:33,800
example. So if you really want to finish more than one instruction per cycle and

28
00:01:33,800 --> 00:01:37,690
do that over many cycles, probably we would have to have something like two add

29
00:01:37,690 --> 00:01:41,630
units and a multiplication unit so that even if we have only adds to

30
00:01:41,630 --> 00:01:46,020
do we would be able to issue and dispatch two per cycle on average.

31
00:01:46,020 --> 00:01:49,580
Then we need to be able to broadcast more than one result per cycle.

32
00:01:49,580 --> 00:01:53,420
This involves not having only two broadcast passes or three broadcast passes but

33
00:01:53,420 --> 00:01:57,800
also every reservation station has to compare it's tags that it's waiting for

34
00:01:57,800 --> 00:02:02,020
to every one of the passes because in any given cycle we could have any of

35
00:02:02,020 --> 00:02:05,740
the passes producing a result. So, this immensely complicates the reservation

36
00:02:05,740 --> 00:02:09,940
station. Basically the cost of each reservation station is

37
00:02:09,940 --> 00:02:14,830
proportional to the number of broadcasts we have to monitor. If we had one,

38
00:02:14,830 --> 00:02:18,680
let's say that's some cost, having three broadcasting sets is going to be at

39
00:02:18,680 --> 00:02:22,880
least three times as costly. And finally our commit logic needs to be capable of

40
00:02:22,880 --> 00:02:25,790
committing more than one instruction per cycle. We have already seen in one

41
00:02:25,790 --> 00:02:30,360
of our quizzes that this is very similar to issuing in that for committing,

42
00:02:30,360 --> 00:02:35,280
we consider the first instruction that is not committed for commit. It that one

43
00:02:35,280 --> 00:02:38,250
can't commit, we consider the next one to commit in the same cycle, and so

44
00:02:38,250 --> 00:02:42,430
on. So, it's not only that we have to consider three instructions for commit and

45
00:02:42,430 --> 00:02:46,040
check whether they're done, we also have to make sure that we don't commit for

46
00:02:46,040 --> 00:02:48,860
example, the third instruction we are considering unless both of

47
00:02:48,860 --> 00:02:53,180
the previous ones are committed. And among these we really have to

48
00:02:53,180 --> 00:02:57,370
be worried about the weakest link. Meaning if we can fetch up to let's say

49
00:02:57,370 --> 00:03:00,980
four instructions per cycle, decode up to four instructions per cycle,

50
00:03:00,980 --> 00:03:04,350
issue only one per cycle, dispatch up to four, broadcast up to four,

51
00:03:04,350 --> 00:03:08,740
and commit up to four, we will still be limited by the issue of only one. So on

52
00:03:08,740 --> 00:03:12,190
average we can never produce more than one instruction finishing per cycle and

53
00:03:12,190 --> 00:03:16,580
committing, because simply they have to go through issue one at a time. If all

54
00:03:16,580 --> 00:03:20,540
of these are very, very large, and one of them is limited to let's say three,

55
00:03:20,540 --> 00:03:24,590
then again, we will not be able to average more than three instructions per

56
00:03:24,590 --> 00:03:29,020
cycle, no matter how well the programming is managed in this organization. So,

57
00:03:29,020 --> 00:03:34,420
pretty much this is kind of like a pipe where the width of the pipe in each of

58
00:03:34,420 --> 00:03:39,730
the stage, is determining the flow of the entire pipe pretty much. The narrowest

59
00:03:39,730 --> 00:03:43,330
place in the pipe is what limits the flow of the instructions through it.
