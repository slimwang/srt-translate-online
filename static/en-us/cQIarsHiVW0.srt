1
00:00:00,170 --> 00:00:01,990
So here is a virtual memory manager and it

2
00:00:01,990 --> 00:00:06,030
is responsible for an address space that it is governing

3
00:00:06,030 --> 00:00:08,220
and this is the guy that is going to worry

4
00:00:08,220 --> 00:00:11,740
about breaking a linear address space into regions and mapping

5
00:00:11,740 --> 00:00:15,468
those regions to specific memory objects. For a particular

6
00:00:15,468 --> 00:00:18,349
process that is living in an address space to access

7
00:00:18,349 --> 00:00:21,620
a particular memory object. Obviously, this memory object has

8
00:00:21,620 --> 00:00:25,380
to be brought into DRAM and that is what a

9
00:00:25,380 --> 00:00:30,750
pager object is going to do. Which is equivalent to the idea of what is called

10
00:00:30,750 --> 00:00:34,070
external pages in other systems, such as Mark.

11
00:00:34,070 --> 00:00:38,330
A pager object is responsible for making or

12
00:00:38,330 --> 00:00:42,660
establishing the connection between virtual memory and physical

13
00:00:42,660 --> 00:00:45,690
memory. And a portion of the virtual memory

14
00:00:45,690 --> 00:00:47,640
that is a region of the linear address

15
00:00:47,640 --> 00:00:50,600
space has been mapped to this memory object,

16
00:00:50,600 --> 00:00:52,610
and it is the responsibility of this pager

17
00:00:52,610 --> 00:00:54,740
object to make sure that this memory object

18
00:00:54,740 --> 00:00:58,930
has the representation in the physical memory when

19
00:00:58,930 --> 00:01:01,740
the process wants to access that portion of

20
00:01:01,740 --> 00:01:04,980
the address space range that corresponds to this

21
00:01:04,980 --> 00:01:08,510
memory object. So this pager object creates what

22
00:01:08,510 --> 00:01:11,960
is called a cached object representation for the

23
00:01:11,960 --> 00:01:15,780
memory object in the DRAM. So now, the portion

24
00:01:15,780 --> 00:01:17,750
of the address piece, that is the region

25
00:01:17,750 --> 00:01:20,320
of the address piece That this virtual memory

26
00:01:20,320 --> 00:01:24,400
manager mapped to this memory object one becomes

27
00:01:24,400 --> 00:01:27,960
available for the process to address in its DRAM

28
00:01:27,960 --> 00:01:29,780
because of the work done by this pager

29
00:01:29,780 --> 00:01:33,940
object in mapping this memory object into this DRAM.

30
00:01:33,940 --> 00:01:37,720
Similarly, a different virtual memory manager object. Managing

31
00:01:37,720 --> 00:01:40,930
a different address space can similarly map another memory

32
00:01:40,930 --> 00:01:44,680
object and clear a cache representation for

33
00:01:44,680 --> 00:01:47,310
this address space to map a region of

34
00:01:47,310 --> 00:01:49,770
its address space to this memory object

35
00:01:49,770 --> 00:01:53,020
using this pager object. I mentioned that the

36
00:01:53,020 --> 00:01:55,910
address space manager can make any number

37
00:01:55,910 --> 00:01:59,100
of such mapping between regions of the linear

38
00:01:59,100 --> 00:02:02,580
address space and memory objects. For instance, there's

39
00:02:02,580 --> 00:02:05,960
another region of the linear address space that

40
00:02:05,960 --> 00:02:07,780
is mapped to this memory object, too, and

41
00:02:07,780 --> 00:02:10,100
there may be a pager object that governs the

42
00:02:10,100 --> 00:02:14,730
paging of this object into a DRAM representation.

43
00:02:14,730 --> 00:02:17,660
So there's a cached object representation for this memory

44
00:02:17,660 --> 00:02:20,930
object which is part of the region Of

45
00:02:20,930 --> 00:02:24,240
the linear address space of a particular process managed

46
00:02:24,240 --> 00:02:27,360
by this VMM1. So in this example, this

47
00:02:27,360 --> 00:02:31,090
pager one is a pager for two distinct memory

48
00:02:31,090 --> 00:02:34,210
objects, memory object one and memory object two, and which

49
00:02:34,210 --> 00:02:38,610
are cached by VMM1 on behalf of a process. So

50
00:02:38,610 --> 00:02:41,080
there are two pager objects. One for each one of

51
00:02:41,080 --> 00:02:43,440
these things. So the important point I want to get

52
00:02:43,440 --> 00:02:46,080
across is that there's not a single paging mechanism that

53
00:02:46,080 --> 00:02:49,300
needs to be used for all the memory objects. So

54
00:02:49,300 --> 00:02:52,750
it gives you an ability to have different regions of

55
00:02:52,750 --> 00:02:56,710
the linear address space of a given process by associating

56
00:02:56,710 --> 00:02:59,410
different pager objects with each of the regions

57
00:02:59,410 --> 00:03:02,750
that correspond to a particular memory object. And

58
00:03:02,750 --> 00:03:05,400
all of these associations between regions and memory

59
00:03:05,400 --> 00:03:09,330
objects can be dynamically created. So for instance, this

60
00:03:09,330 --> 00:03:12,970
address space manager may decide to associate a

61
00:03:12,970 --> 00:03:15,630
region in this linear address space to this memory

62
00:03:15,630 --> 00:03:18,210
object. If it does that, then there is

63
00:03:18,210 --> 00:03:22,130
a new pager object that. Is going to manage their

64
00:03:22,130 --> 00:03:25,720
association between the region of the virtual address

65
00:03:25,720 --> 00:03:28,610
space that is mapped to this memory object

66
00:03:28,610 --> 00:03:32,520
three and the cached object representation is the

67
00:03:32,520 --> 00:03:35,780
DRAM representation of this memory object created by a

68
00:03:35,780 --> 00:03:38,800
pager object that is managing the relationship between

69
00:03:38,800 --> 00:03:42,010
this region. And this particular memory object three. Now

70
00:03:42,010 --> 00:03:44,560
this is an interesting situation, because you have

71
00:03:44,560 --> 00:03:47,760
a memory object that is shared by two different

72
00:03:47,760 --> 00:03:51,870
address spaces. And there are two distinct pager

73
00:03:51,870 --> 00:03:56,360
objects associated with managing The region of the

74
00:03:56,360 --> 00:04:02,430
address space in VMM 1 that maps to this memory object, and the region of the

75
00:04:02,430 --> 00:04:06,810
address space in VMM 2 that maps to the same memory object. Now what about the

76
00:04:06,810 --> 00:04:10,020
coherence of the cache representation of this object

77
00:04:10,020 --> 00:04:12,770
that exists over here? And the cached representation

78
00:04:12,770 --> 00:04:15,210
of this object that exists over here. Who manages

79
00:04:15,210 --> 00:04:18,814
that? Well it's entirely up to the pager object [INAUDIBLE]

80
00:04:18,814 --> 00:04:22,580
instantiated. In order to manage the mapping between this

81
00:04:22,580 --> 00:04:26,360
memory object and the cached object. So if coherence is

82
00:04:26,360 --> 00:04:29,600
needed. For the cache representation of this memory object

83
00:04:29,600 --> 00:04:32,030
in the DRAM of this address space and this address

84
00:04:32,030 --> 00:04:35,220
space, then it is a responsibility of these two

85
00:04:35,220 --> 00:04:38,045
pager objects to coordinate that. So it's not something that

86
00:04:38,045 --> 00:04:40,370
string system is responsible for, but it

87
00:04:40,370 --> 00:04:43,730
provides the basic mechanisms through which these

88
00:04:43,730 --> 00:04:47,470
entities can manage the regions that they

89
00:04:47,470 --> 00:04:51,080
are mapping. In terms of the memory objects

90
00:04:51,080 --> 00:04:53,840
and the DRAM representation of those objects.

91
00:04:53,840 --> 00:04:56,700
So in other words, external pagers establish

92
00:04:56,700 --> 00:05:00,040
the mapping between virtual memory, which is

93
00:05:00,040 --> 00:05:03,400
indicated by these memory objects, and physical memory,

94
00:05:03,400 --> 00:05:05,900
which is represented by the cached objects. So

95
00:05:05,900 --> 00:05:08,950
in summary, the way memory management works in the

96
00:05:08,950 --> 00:05:12,460
spring system is, the address space managers. Are

97
00:05:12,460 --> 00:05:15,600
responsible for managing the linear address space of a

98
00:05:15,600 --> 00:05:17,910
process, and they do the mapping of the

99
00:05:17,910 --> 00:05:20,670
linear address space of a process by carving them

100
00:05:20,670 --> 00:05:23,830
up into regions. And associating the regions with different

101
00:05:23,830 --> 00:05:28,630
memory objects, and these memory objects maybe swap space

102
00:05:28,630 --> 00:05:31,390
on the disk. Or it could be files that

103
00:05:31,390 --> 00:05:33,710
are being mapped into specific regions of the linear

104
00:05:33,710 --> 00:05:36,720
address space. Entirely up to the application, what they

105
00:05:36,720 --> 00:05:39,210
want to do with it, but these abstractions are powerful

106
00:05:39,210 --> 00:05:42,410
for facilitating whatever may be the intent of the

107
00:05:42,410 --> 00:05:47,300
user. And mapping the memory objects to the cache representation,

108
00:05:47,300 --> 00:05:50,640
which lives in DRAM, is the responsibility of pager

109
00:05:50,640 --> 00:05:54,260
objects. And you can have any number of external pages

110
00:05:54,260 --> 00:05:59,940
that manage this mapping. And in particular, through this example I've shown you

111
00:05:59,940 --> 00:06:03,230
that you can have, for a single

112
00:06:03,230 --> 00:06:06,170
linear address space, multiple pager objects that

113
00:06:06,170 --> 00:06:08,980
are managing different regions of that same

114
00:06:08,980 --> 00:06:12,070
address space. And that's the flexibility and

115
00:06:12,070 --> 00:06:15,100
power that's available in the structure, of

116
00:06:15,100 --> 00:06:17,605
the spring system, using the object technology.
