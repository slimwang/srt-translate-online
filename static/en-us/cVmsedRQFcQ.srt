1
00:00:00,740 --> 00:00:03,052
So we already know that ILP is not equal to

2
00:00:03,052 --> 00:00:06,180
IPC on any real processor, actually it can be but it's

3
00:00:06,180 --> 00:00:09,376
not necessarily, so, and that is because ILP is really

4
00:00:09,376 --> 00:00:13,356
the IPC on a perfect processor that does perfect branch prediction.

5
00:00:13,356 --> 00:00:16,416
And only has to follow data dependencies, so now lets

6
00:00:16,416 --> 00:00:19,272
look at an example of a program and a real processor

7
00:00:19,272 --> 00:00:22,332
and see basically how do we determine ILP, and and how

8
00:00:22,332 --> 00:00:26,408
do we determine the IPC. So this is our program, and

9
00:00:26,408 --> 00:00:28,424
now let's look at what the processor looks

10
00:00:28,424 --> 00:00:33,400
like. So our processor is two issue, meaning it

11
00:00:33,400 --> 00:00:36,540
can handle two instructions per cycle. Out of

12
00:00:36,540 --> 00:00:38,960
order super scalar, which means that it doesn't need

13
00:00:38,960 --> 00:00:43,238
to execute instructions exactly in program order. And

14
00:00:43,238 --> 00:00:45,758
let's say that it only has one multiplication unit,

15
00:00:45,758 --> 00:00:47,942
and two units that can do what add, subtract,

16
00:00:47,942 --> 00:00:51,550
x, or et cetera. For our ILP, we can

17
00:00:51,550 --> 00:00:54,350
just ignore all of this, because the ILP, again, is

18
00:00:54,350 --> 00:00:56,810
just the property of a program. So we have to

19
00:00:56,810 --> 00:01:01,640
just obey dependencies. There is a data dependence here, and

20
00:01:01,640 --> 00:01:05,310
that's only really the only dependence that we have. So as

21
00:01:05,310 --> 00:01:08,210
far as ILP is concerned, we can do this in

22
00:01:08,210 --> 00:01:11,940
two cycles. This, this, this, and this would be done in

23
00:01:11,940 --> 00:01:13,920
the first cycle, and then this would be done in

24
00:01:13,920 --> 00:01:16,700
the second cycle because it, it depends on the instruction that

25
00:01:16,700 --> 00:01:22,020
is done in the first cycle. So we have five instructions, over two cycles,

26
00:01:22,020 --> 00:01:27,240
gives us 2.5. In contrast, the IPC for this processor

27
00:01:27,240 --> 00:01:31,760
needs to consider all the limitations of this processor. So we have this

28
00:01:31,760 --> 00:01:34,350
instruction can be done in the first cycle. This

29
00:01:34,350 --> 00:01:36,940
one cannot because of a dependence, so therefor the

30
00:01:36,940 --> 00:01:39,730
IPC we still have to obey all the dependencies,

31
00:01:39,730 --> 00:01:42,120
plus we have to also worry about the other limitations

32
00:01:42,120 --> 00:01:44,520
of the processor. This is an out-of-order processor, so

33
00:01:44,520 --> 00:01:46,006
we are not doing this. But we can still

34
00:01:46,006 --> 00:01:48,294
look further, because we can do instructions out of

35
00:01:48,294 --> 00:01:52,531
order. The XOR can be done because we have two

36
00:01:52,531 --> 00:01:55,716
add subtracted et cetera units so we can do

37
00:01:55,716 --> 00:02:00,690
this in the first cycle two. This instruction can be

38
00:02:00,690 --> 00:02:03,174
done in the first cycle, because we can use

39
00:02:03,174 --> 00:02:07,164
the multiplier. For example, this instruction here cannot be done

40
00:02:07,164 --> 00:02:09,368
in the first cycle unlike when we computed the

41
00:02:09,368 --> 00:02:12,470
ILP. It can not be done, because we only have

42
00:02:12,470 --> 00:02:15,340
two add, subtract, x, or et cetera units, and

43
00:02:15,340 --> 00:02:18,210
we have already consumed both of them in the first

44
00:02:18,210 --> 00:02:20,420
cycle for the add and the XOR. So in

45
00:02:20,420 --> 00:02:24,870
the second cycle now, we can do this and this.

46
00:02:24,870 --> 00:02:27,470
So it turns out that I, our IBC is still

47
00:02:27,470 --> 00:02:32,310
five instructions over two cycles equals 2.5. But it doesn't

48
00:02:32,310 --> 00:02:34,780
have to be that way. For example, if this

49
00:02:34,780 --> 00:02:38,520
processor only had one, I would subtract extra units.

50
00:02:38,520 --> 00:02:42,400
We would now have the IPC off. In the

51
00:02:42,400 --> 00:02:46,010
first cycle we can do this. We cannot do this

52
00:02:46,010 --> 00:02:48,716
because of a dependence. We cannot do this because

53
00:02:48,716 --> 00:02:50,844
are already using our one unit that we have for

54
00:02:50,844 --> 00:02:54,030
an [UNKNOWN], et cetera. We can do the multiply,

55
00:02:54,030 --> 00:02:57,830
and we can't do this add either. In the second

56
00:02:57,830 --> 00:03:00,700
cycle, we can do this. We can not do

57
00:03:00,700 --> 00:03:03,313
any of these other two because, again, we are

58
00:03:03,313 --> 00:03:06,309
using our add subtract XOR. This will be our

59
00:03:06,309 --> 00:03:09,360
third cycle, and this will be our fourth cycle.

60
00:03:09,360 --> 00:03:12,629
So, now we have five instructions over four cycles.

61
00:03:13,650 --> 00:03:16,592
And that's equal to 1.25. So this IPC is

62
00:03:16,592 --> 00:03:22,970
half of this IPC, and half of this ILP. So what we can say is that the IPC

63
00:03:22,970 --> 00:03:24,570
has to be less than or equal to the

64
00:03:24,570 --> 00:03:27,980
ILP. The ILPs for a perfect PROCESSOR. A real prosser

65
00:03:27,980 --> 00:03:31,400
will have some limitations that will maybe allow it to

66
00:03:31,400 --> 00:03:34,490
achieve the same IPC as the ILP available in the

67
00:03:34,490 --> 00:03:38,558
application. But sometimes it will not. So what we can

68
00:03:38,558 --> 00:03:41,726
say is that the ILP is always greater than or

69
00:03:41,726 --> 00:03:46,150
equal to the IPC on any real PROCESSOR. And again,

70
00:03:46,150 --> 00:03:48,080
we don't really need to know what the prosser is

71
00:03:48,080 --> 00:03:50,160
to compute the ILP, but we do need to know what

72
00:03:50,160 --> 00:03:53,380
the prosser looks like when we're computing it's IPC. And we have

73
00:03:53,380 --> 00:03:56,040
seen that IPC can be equal to the ILP, or it can

74
00:03:56,040 --> 00:03:57,940
be lower than that, but it can not be larger than that.
