1
00:00:00,000 --> 00:00:05,000
[Norvig] Now, by all means, you should use the library functions like random.shuffle.

2
00:00:05,000 --> 00:00:07,000
That's what they're there for.

3
00:00:07,000 --> 00:00:09,000
But I'm going to allow a little bit of a diversion here

4
00:00:09,000 --> 00:00:13,000
because the shuffle algorithm is one that's important to me personally.

5
00:00:13,000 --> 00:00:19,000
It was the first nontrivial algorithm that I came up with on my own when I was in high school

6
00:00:19,000 --> 00:00:24,000
and one of the first cases where I saw that my teacher was just completely wrong.

7
00:00:24,000 --> 00:00:29,000
Here's the algorithm that my teacher was trying to describe to me.

8
00:00:29,000 --> 00:00:34,000
Of course, I went to high school in the Dark Ages before there was any Python,

9
00:00:34,000 --> 00:00:36,000
so it wasn't written in exactly this language,

10
00:00:36,000 --> 00:00:39,000
but I've translated it into Python to make sense to you.

11
00:00:39,000 --> 00:00:41,000
Here's what the algorithm does.

12
00:00:41,000 --> 00:00:46,000
It says we're going to keep track with an array of which items have been swapped so far,

13
00:00:46,000 --> 00:00:50,000
and then until they've all been swapped at least once,

14
00:00:50,000 --> 00:00:55,000
we're going to generate 2 random indices into that array and then swap them

15
00:00:55,000 --> 00:00:58,000
and record the fact that they were both swapped

16
00:00:58,000 --> 00:01:02,000
and keep going until all the items have been swapped at least once.

17
00:01:02,000 --> 00:01:04,000
So it looks like this.

18
00:01:04,000 --> 00:01:08,000
Again, we have this deck of cards

19
00:01:08,000 --> 00:01:13,000
and then we have a parallel array of the same length

20
00:01:13,000 --> 00:01:15,000
which tells us whether we've been swapped or not,

21
00:01:15,000 --> 00:01:20,000
and that starts out as being all false, while this one starts out being cards.

22
00:01:20,000 --> 00:01:23,000
And then we go through and we pick out random numbers.

23
00:01:23,000 --> 00:01:31,000
So say we pick out I and J as being here and here,

24
00:01:31,000 --> 00:01:33,000
and say we have a 9 of diamonds there.

25
00:01:33,000 --> 00:01:35,000
Then we're going to just swap the 2.

26
00:01:35,000 --> 00:01:37,000
And so we cross those out.

27
00:01:37,000 --> 00:01:43,000
We now have the 7 of spades there and the 9 of diamonds there,

28
00:01:43,000 --> 00:01:45,000
and we mark the 2 spots as being swapped.

29
00:01:45,000 --> 00:01:49,000
So now this one is true and this one is true.

30
00:01:49,000 --> 00:01:53,000
Those 2 spots have been swapped, and then we keep on going

31
00:01:53,000 --> 00:01:58,000
until all the elements of swapped are all equal to true. Then we know we're done.

32
00:01:58,000 --> 00:02:02,000
So that's what my teacher was trying to sell to me that day in high school.

33
00:02:02,000 --> 00:02:06,000
I was sitting in the back, and I just woke up and I said,

34
00:02:06,000 --> 00:02:08,000
"That can't be right."

35
00:02:08,000 --> 00:02:12,000
I just had this visceral reaction that said, "I can see what the algorithm does,

36
00:02:12,000 --> 00:02:16,000
"and I know it swaps everything, but it just seems too inefficient."

37
00:02:16,000 --> 00:02:21,000
"It has this loop that keeps on going, and it's not a for loop, it's a while loop."

38
00:02:21,000 --> 00:02:26,000
And it just seemed to me that it was possible that this loop could go forever.

39
00:02:26,000 --> 00:02:28,000
Depending on the choice of random numbers,

40
00:02:28,000 --> 00:02:30,000
this might never terminate, and that just seemed wrong.

41
00:02:30,000 --> 00:02:32,000
It seemed like there was a much better way.

42
00:02:32,000 --> 00:02:37,000
And in my head I came up with the shuffle algorithm that we showed before.

43
00:02:37,000 --> 00:02:40,000
Knuth calls it Algorithm P for permutation.

44
00:02:40,000 --> 00:02:42,000
It just seemed like that was the simple and correct way,

45
00:02:42,000 --> 00:02:46,000
and this was just too complicated, and that really bothered me.

46
00:02:46,000 --> 00:02:49,000
I thought that an algorithm should be guaranteed to terminate.
