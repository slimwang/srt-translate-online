1
00:00:00,420 --> 00:00:02,580
Let's apply scan in an interesting way,

2
00:00:02,580 --> 00:00:06,170
namely in parellelizing
the quicksort algorithm.

3
00:00:06,170 --> 00:00:09,460
And I know quicksort is your favorite
algorithm from computer science

4
00:00:09,460 --> 00:00:10,950
elementary school.

5
00:00:10,950 --> 00:00:14,250
First, let me remind you how to
do a quicksort sequentially.

6
00:00:14,250 --> 00:00:17,362
It's all based on what I'll
call a quicksort step.

7
00:00:17,362 --> 00:00:21,300
A quicksort step is a kind of dance
move for people like me who have two or

8
00:00:21,300 --> 00:00:22,910
more left feet.

9
00:00:22,910 --> 00:00:26,530
The first part of a quicksort
step is choosing a pivot element.

10
00:00:26,530 --> 00:00:27,860
Now, any element can work, but

11
00:00:27,860 --> 00:00:31,490
a good choice is to select
one uniformly at random.

12
00:00:31,490 --> 00:00:35,040
So for this 12-element array,
you might roll a 12-sided die and

13
00:00:35,040 --> 00:00:37,530
pick, I don't know, this element.

14
00:00:37,530 --> 00:00:40,650
The next part of a quicksort
step is to partition the input

15
00:00:40,650 --> 00:00:42,500
around the pivot value.

16
00:00:42,500 --> 00:00:45,620
That means get all the elements that
are less than or equal to the pivot and

17
00:00:45,620 --> 00:00:47,360
put them on one side.

18
00:00:47,360 --> 00:00:49,780
And get all the elements that
are greater than the pivot and

19
00:00:49,780 --> 00:00:50,769
put them on the other side.

20
00:00:51,790 --> 00:00:55,060
By doing so,
you now have two subparts of the array

21
00:00:55,060 --> 00:00:58,680
that can be sorted completely
independently from one another.

22
00:00:58,680 --> 00:01:00,654
That ends the quick step.

23
00:01:00,654 --> 00:01:02,811
Now, since the two
halves are independent,

24
00:01:02,811 --> 00:01:04,810
you can spawn them as independent tasks.

25
00:01:06,640 --> 00:01:09,690
And you just keep repeating
the quick step until you're done.

26
00:01:09,690 --> 00:01:12,980
Choose a pivot, partition and spawn.

27
00:01:14,780 --> 00:01:16,880
Here's the algorithm more formally.

28
00:01:16,880 --> 00:01:19,040
First, it chooses a pivot at random.

29
00:01:19,040 --> 00:01:21,940
Then it partitions
the input around the pivot.

30
00:01:21,940 --> 00:01:24,550
Then it conquers these two halves.

31
00:01:24,550 --> 00:01:27,470
And finally, it glues these
two results back together.

32
00:01:27,470 --> 00:01:28,940
Quick and easy.

33
00:01:28,940 --> 00:01:31,040
Well, except for one detail.

34
00:01:31,040 --> 00:01:33,030
How do you do this
partition step in parallel?
