1
00:00:00,000 --> 00:00:03,270
All right, so let's take a look at how I decide to do this.

2
00:00:03,270 --> 00:00:08,830
Like I said, you set up a second vertex called u and set it to equal to -1.

3
00:00:08,830 --> 00:00:14,350
In other words, it's not set to any actual vertex in the graph at first.

4
00:00:14,350 --> 00:00:21,580
So for every single element in the upper triangular portion of the adjacency matrix

5
00:00:21,580 --> 00:00:24,800
since we're presenting this as an adjacency matrix,

6
00:00:24,800 --> 00:00:30,440
we check if there is an edge between those two vertices between vertices I and J.

7
00:00:30,440 --> 00:00:37,540
And if there is, then we check if the assignment for I and J is zero

8
00:00:37,540 --> 00:00:43,380
that is they're not none anymore, we have specifically set them to not be in the assignment.

9
00:00:43,380 --> 00:00:50,250
Well, if both of them are explicitly out of the assignment and there's an edge between them

10
00:00:50,250 --> 00:00:54,640
well then that's not going to be a valid vertex cover, so we return float infinity.

11
00:00:54,640 --> 00:01:00,890
Now, otherwise, if we find that the assignment for both I and J is equal to none,

12
00:01:00,890 --> 00:01:06,300
then that means we haven't actually look at this yet, so it's a good candidate for setting v and u--

13
00:01:06,300 --> 00:01:10,930
so that we set u equal i and v equal to j and we continue on.

14
00:01:10,930 --> 00:01:18,010
Now, once we go through the entire double for loop, we check if v is still on set.

15
00:01:18,010 --> 00:01:24,970
If v is still on set, that means first of all we didn't fall out of this by not having a valid vertex cover

16
00:01:24,970 --> 00:01:31,250
and second of all, it means that all the vertices have been assigned to something rather

17
00:01:31,250 --> 00:01:33,930
because that's the only way that v could still be set to -1

18
00:01:33,930 --> 00:01:37,930
and if v is set to -1, then note that u also is.

19
00:01:37,930 --> 00:01:42,620
Now, if that's the case, then we set a variable size equal to zero

20
00:01:42,620 --> 00:01:48,740
and we start simply counting up all of the different vertices in the assignment.

21
00:01:48,740 --> 00:01:52,500
If the vertex is set in the assignment, then we increment size.

22
00:01:52,500 --> 00:01:58,480
It it's still unset, well then we have to do a little bit of manipulation here.

23
00:01:58,480 --> 00:02:02,780
We'll just set the vertex i to 1 if a neighbor is zero

24
00:02:02,780 --> 00:02:05,960
because we want to make sure that this is still a valid vertex cover.

25
00:02:05,960 --> 00:02:11,890
So, for every j in range i--well, I just realized I put an i in here.

26
00:02:11,890 --> 00:02:15,920
Well, then there are unnecessary just a slight inefficiency,

27
00:02:15,920 --> 00:02:21,970
you can boost this to i+1 since we don't allow any loops in the graph.

28
00:02:21,970 --> 00:02:27,290
If we did, then we would have to simply use i but this doesn't really particularly matter for this.

29
00:02:27,290 --> 00:02:37,090
Moving on, so for every other vertex in the graph, we check if there is an edge between i and j again

30
00:02:37,090 --> 00:02:42,810
and if there is and if the assignment of j is zero, well then, we have to set i

31
00:02:42,810 --> 00:02:49,990
and we say that the size is an additional element because we now have to set i,

32
00:02:49,990 --> 00:02:53,910
and once we go through all this, we return the size and that's done.

33
00:02:53,910 --> 00:02:58,560
Now, for each of these for the recursive part that you don't have to worry about,

34
00:02:58,560 --> 00:03:03,250
we try all the different possible combinations that aren't zero-zeros

35
00:03:03,250 --> 00:03:05,720
since that would not be a valid vertex cover.

36
00:03:05,720 --> 00:03:08,400
We try 1, 0; 0, 1; and 1, 1.

37
00:03:08,400 --> 00:03:13,120
We compute the size for each of these and then we return the minimum of those

38
00:03:13,120 --> 00:03:19,170
and compute this whole thing recursively.

39
00:03:19,170 --> 00:03:23,920
So that was a little tricky. If you had trouble with that, totally understandable.

40
00:03:23,920 --> 00:03:28,670
This does give you a little bit of improvement in the total size

41
00:03:28,670 --> 00:03:31,360
of the search tree we end up searching through.

42
00:03:31,360 --> 00:03:38,280
Before, it was 2 to the end--Now, we got about 1.733 to the end.

43
00:03:38,280 --> 00:03:42,570
It might not seem like much but in practice, it can be helpful.

44
00:03:42,570 --> 99:59:59,999
So, okay. Let's go ahead and look a different problem now.
