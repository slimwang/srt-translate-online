1
00:00:00,000 --> 00:00:04,000
That's the parser, and I know we went really quick.

2
00:00:04,000 --> 00:00:07,000
We didn't have time to go over a lot of the details.

3
00:00:07,000 --> 00:00:11,000
If you hadn't seen anything about parsing or languages before,

4
00:00:11,000 --> 00:00:13,000
I may have been too fast for you and I apologize.

5
00:00:13,000 --> 00:00:16,000
But part of the idea was to teach a little bit about language theory,

6
00:00:16,000 --> 00:00:19,000
but more the idea was just to give you a tool

7
00:00:19,000 --> 00:00:22,000
and to show you how these tools are built and how you can use them.

8
00:00:22,000 --> 00:00:27,000
Don't worry if you didn't get all the details of exactly how the parser works.

9
00:00:27,000 --> 00:00:32,000
If you are interested, there's another course and there's some other documentation

10
00:00:32,000 --> 00:00:34,000
that you can read to get up to speed on it.

11
00:00:34,000 --> 00:00:36,000
But I just want to talk about one more thing.

12
00:00:36,000 --> 00:00:41,000
There's something that bothers me here, which is say is say we have an expression--

13
00:00:41,000 --> 00:00:46,000
one single expression that's really long--and we start parsing it this way.

14
00:00:46,000 --> 00:00:50,000
We say let's go left to right. We'll do the first alternative first.

15
00:00:50,000 --> 00:00:53,000
Parse the term, and it parses this big, big long term

16
00:00:53,000 --> 00:00:58,000
and then tries to parse a plus or minus, and it says, oops, I hit the end.

17
00:00:58,000 --> 00:01:01,000
There's no more plus or minus. This alternative fails.

18
00:01:01,000 --> 00:01:05,000
Now I try the second alternative, and the second alternative says

19
00:01:05,000 --> 00:01:10,000
start with a term and we go back and we parse this whole big term all over again.

20
00:01:10,000 --> 00:01:13,000
We've doubled the amount of work, and it can be worse that that,

21
00:01:13,000 --> 00:01:17,000
because inside of each of these terms there's more little pieces,

22
00:01:17,000 --> 00:01:19,000
and we can be doubling each of those pieces work.

23
00:01:19,000 --> 00:01:21,000
That seems really inefficient.

24
00:01:21,000 --> 00:01:26,000
What we'd like to be able to do is fix up our parser so that once we've done this work

25
00:01:26,000 --> 00:01:30,000
we don't have to do it a second time in case this version fails.

26
00:01:30,000 --> 00:01:35,000
Don't worry about doing the work of saying what if like 5 out of 6 of these got parsed,

27
00:01:35,000 --> 00:01:40,000
just worry about the individual atoms, and saying if I did the work of computing

28
00:01:40,000 --> 00:01:44,000
the tree for an individual atom. I don't want to have to repeat that twice.

29
00:01:44,000 --> 00:01:48,000
The quiz question is can you go into here and modify this parse function

30
00:01:48,000 --> 00:01:52,000
so that it has that property that it doesn't repeat the work twice.

31
00:01:52,000 --> 00:01:58,000
Once it's done it once, it's asked to do it a second time, it doesn't repeat the computation.

32
00:01:58,000 --> 00:02:00,000
It just does the computation once.

33
00:02:00,000 --> 00:02:04,000
That may seem like a daunting task, but there is a solution that's really simple

34
00:02:04,000 --> 00:02:08,000
that you have the tools for to be able to solve.
