1
00:00:00,230 --> 00:00:03,250
So, that's the normalized cut approach,
and it's one of the more

2
00:00:03,250 --> 00:00:07,740
effective methods within the whole
graph-based way of doing segmentation.

3
00:00:07,740 --> 00:00:11,270
The pros are because
it's a graph structure,

4
00:00:11,270 --> 00:00:13,650
we've got lots of algorithms for
dealing with craft structure.

5
00:00:13,650 --> 00:00:16,600
So, it's a very generic way of doing it,
because you separate out

6
00:00:16,600 --> 00:00:20,200
this graph structure question from
the affinity matrix computation.

7
00:00:20,200 --> 00:00:23,000
So the affinity matrix is where
you get to play with things,

8
00:00:23,000 --> 00:00:25,650
like your distance functions,
and your feature spaces.

9
00:00:25,650 --> 00:00:30,110
And then, your graph algorithms just
run given that that, that matrix.

10
00:00:31,130 --> 00:00:35,130
So again, it doesn't require
a model of the data distribution.

11
00:00:35,130 --> 00:00:38,220
It just requires a distance
function that respects that.

12
00:00:38,220 --> 00:00:40,600
There are some challenges.

13
00:00:40,600 --> 00:00:43,975
In general, the complexity of dealing
with this can be pretty high,

14
00:00:43,975 --> 00:00:48,130
because you now have this, these
matrices that are essentially n by n,

15
00:00:48,130 --> 00:00:49,980
where n is the number of pixels.

16
00:00:49,980 --> 00:00:54,810
So you want to be careful exactly
how you manage that complexity.

17
00:00:54,810 --> 00:00:57,720
If you have densely connected graphs,
because you want to allow for

18
00:00:57,720 --> 00:01:01,150
large regions, et cetera the system
has to work even harder.

19
00:01:01,150 --> 00:01:06,420
And the, the spectral decomposition
approximation to the normalized cut

20
00:01:06,420 --> 00:01:08,520
is a little bit trickier to do.

21
00:01:08,520 --> 00:01:12,390
And, and then there's this question
about this balancing of the partition.

22
00:01:12,390 --> 00:01:16,800
So you remember, we introduced
the normalization to the min-cut,

23
00:01:16,800 --> 00:01:20,030
in order to not get small pieces,

24
00:01:20,030 --> 00:01:23,570
because there was a bias towards
small pieces in the algorithm?

25
00:01:23,570 --> 00:01:27,870
Well, another way of thinking about this
is, we've introduced a preference for

26
00:01:27,870 --> 00:01:30,375
balanced partitions,
for balanced regions.

27
00:01:30,375 --> 00:01:34,092
So if you really wanted to have small,
little spots being pulled off of

28
00:01:34,092 --> 00:01:37,937
something that was bigger, normalized
cut finds that kind of painful,

29
00:01:37,937 --> 00:01:40,792
because it wants to have
these balanced partitions.

30
00:01:40,792 --> 00:01:44,022
Having said that, I will say that
it is one of the more effective

31
00:01:44,022 --> 00:01:47,300
segmentation methods that
people currently use.

32
00:01:47,300 --> 00:01:50,290
And I think it's because it has
this nice dissociation between

33
00:01:50,290 --> 00:01:54,380
the affinity matrix computation and
the graph segmentation method.
