1
00:00:00,090 --> 00:00:02,969
So we have seen in most of our
examples that we have used pages of

2
00:00:02,969 --> 00:00:07,060
four kilobytes, and in the most recent
quiz we have used larger pages.

3
00:00:07,060 --> 00:00:11,110
So how do we choose the page size that
we're going to support in our processor?

4
00:00:11,110 --> 00:00:13,970
So comparing smaller
pages to larger pages,

5
00:00:13,970 --> 00:00:19,290
larger pages are good because they
will result in a smaller page table.

6
00:00:19,290 --> 00:00:21,590
The page table needs
to have one entry for

7
00:00:21,590 --> 00:00:25,490
each page that we are using in
the case of multi-level pages.

8
00:00:25,490 --> 00:00:29,830
So, if pages are larger, we would
have fewer entries in our page table.

9
00:00:29,830 --> 00:00:33,230
Smaller pages will suffer
from large page tables.

10
00:00:33,230 --> 00:00:36,930
So it seems like larger pages are good,
but

11
00:00:36,930 --> 00:00:41,710
we can only give memory to
applications in units of pages.

12
00:00:41,710 --> 00:00:43,300
So if you have a very large page,

13
00:00:43,300 --> 00:00:48,230
we will suffer from what is
called internal fragmentation.

14
00:00:48,230 --> 00:00:53,070
Internal fragmentation occurs when
the application requests some amount of

15
00:00:53,070 --> 00:00:59,280
space, let's say this much, but we can
only give it space in terms of pages,

16
00:00:59,280 --> 00:01:00,860
so we end up giving it, for example,

17
00:01:00,860 --> 00:01:06,280
two pages, where this space in this page
is not really used by the application.

18
00:01:06,280 --> 00:01:10,010
That means that whenever this
page is actually in memory,

19
00:01:10,010 --> 00:01:13,670
it is going to be using actual
physical memory, although in fact

20
00:01:14,740 --> 00:01:18,840
only this much of it is being
used by the application, so

21
00:01:18,840 --> 00:01:23,520
this much physical memory is going to be
wasted whenever this page is in memory.

22
00:01:23,520 --> 00:01:28,260
When the page is on disk, this is also
wasted because we store the whole page

23
00:01:28,260 --> 00:01:30,890
on disk, but
this is maybe less of a problem

24
00:01:30,890 --> 00:01:34,380
because the disk is usually much
larger than the physical memory.

25
00:01:34,380 --> 00:01:36,750
So how do we choose the page size?

26
00:01:36,750 --> 00:01:40,040
Well, obviously,
we want smaller page tables but

27
00:01:40,040 --> 00:01:44,510
we don't want to suffer from too
much internal fragmentation, so,

28
00:01:44,510 --> 00:01:49,710
just like with the block sizing caches,
we want to reach a compromise.

29
00:01:49,710 --> 00:01:53,970
And it turns out that the good
compromises are at page sizes from

30
00:01:53,970 --> 00:01:56,310
a few kB to a few MB.

31
00:01:56,310 --> 00:02:00,810
That is why x86 processors
use a 4kB page.

32
00:02:00,810 --> 00:02:04,700
At the time when they were designed,
the bias was slightly more toward

33
00:02:04,700 --> 00:02:09,180
the smaller pages because we were so
worried about wasting memory.

34
00:02:09,180 --> 00:02:14,420
Nowadays, waste of memory even
with megabyte sized pages

35
00:02:14,420 --> 00:02:17,780
is relatively small compared
to the overall memory size, so

36
00:02:17,780 --> 00:02:19,740
if we were designing
a processor nowadays,

37
00:02:19,740 --> 00:02:24,788
probably the page size would be closer
to a megabyte than to a 4kB page.
