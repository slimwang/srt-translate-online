1
00:00:00,230 --> 00:00:04,540
So let's look at the relatively
simple implementation of a barrier

2
00:00:04,540 --> 00:00:05,510
in a program.

3
00:00:05,510 --> 00:00:07,920
So this is our barrier implementation.

4
00:00:07,920 --> 00:00:10,590
Our counter is a shared variable, and

5
00:00:10,590 --> 00:00:13,180
everybody's trying to increment it
when they arrive to the variable.

6
00:00:13,180 --> 00:00:16,410
Multiple threads could arrive to
the variable at about the same time.

7
00:00:16,410 --> 00:00:19,590
So we have to protect
the counter using a lock.

8
00:00:19,590 --> 00:00:23,750
So here what we are really
doing is counting the arrivals.

9
00:00:23,750 --> 00:00:27,050
Once we are done incrementing the
counter we can check if the counter is

10
00:00:27,050 --> 00:00:28,170
equal to the total.

11
00:00:28,170 --> 00:00:32,590
If it is, that means that we
are either the last thread.

12
00:00:32,590 --> 00:00:34,630
Or the last thread has arrived.

13
00:00:34,630 --> 00:00:37,480
Note that the two are not
necessarily the same.

14
00:00:37,480 --> 00:00:41,280
We may be able to increment the counter,
but we are not the last thread.

15
00:00:41,280 --> 00:00:44,930
But, by the time we get to check the
total, the last thread has arrived and

16
00:00:44,930 --> 00:00:45,800
increments the counter.

17
00:00:45,800 --> 00:00:49,750
So, we read the counter that is not
the same as what we left it with.

18
00:00:49,750 --> 00:00:53,330
Either way,
if the counter is equal to the total.

19
00:00:53,330 --> 00:00:57,680
Then we reset the counter,
because it needs to be re initialized so

20
00:00:57,680 --> 00:01:02,050
that next time we enter the same barrier
variable we have the counted zero.

21
00:01:02,050 --> 00:01:06,010
And we set the release flag to one so
that

22
00:01:06,010 --> 00:01:10,870
the threats who are waiting find out
that the barrier can now be released.

23
00:01:10,870 --> 00:01:16,280
If the count is not equal to the total,
then we're going to spin here waiting

24
00:01:16,280 --> 00:01:22,270
for somebody else to find that the count
is equal to the total end release.

25
00:01:22,270 --> 00:01:25,680
After we are done going through
one instance of this barrier,

26
00:01:25,680 --> 00:01:27,720
the release will be one.

27
00:01:27,720 --> 00:01:31,290
Before we can reuse this barrier,

28
00:01:31,290 --> 00:01:36,100
the release needs to be set at zero and
that's the purpose of this line here.

29
00:01:36,100 --> 00:01:41,630
If we are the first thread to arrive,
then we're going to set release to zero.

30
00:01:41,630 --> 00:01:46,560
So the idea is now that as we enter the
barrier, the first thread that arrives,

31
00:01:46,560 --> 00:01:48,340
and know that this is done
in a critical section,

32
00:01:48,340 --> 00:01:53,690
so exactly one thread will see this
as zero, it sets release to zero.

33
00:01:53,690 --> 00:01:57,800
That thread then increments the count,
it becomes one, and goes on here.

34
00:01:57,800 --> 00:02:01,490
That thread, and all the other threads,
now see release as zero and

35
00:02:01,490 --> 00:02:05,200
the only way it becomes one is
if count reaches the total.

36
00:02:05,200 --> 00:02:09,340
So what happens is the first thread
might actually be delayed and

37
00:02:09,340 --> 00:02:13,520
read the count after everybody's done
in which case it's going to do this.

38
00:02:13,520 --> 00:02:15,280
Or it might go here and spin but

39
00:02:15,280 --> 00:02:21,310
either way, release becoming one means
that somebody got to this point.

40
00:02:21,310 --> 00:02:24,380
Which is when the barrier
should be released.

41
00:02:24,380 --> 00:02:28,150
One or more threads that arrive
towards the end are going to do this,

42
00:02:28,150 --> 00:02:32,890
which will reset the count so that
next time we enter we see count zero.

43
00:02:32,890 --> 00:02:36,460
And release is set to one which
ensures that those threads that didn't

44
00:02:36,460 --> 00:02:39,390
end up here are going to
see release as one.

45
00:02:39,390 --> 00:02:43,124
Note that the meaning of this
spin,release equals one,

46
00:02:43,124 --> 00:02:46,170
is actually that we wait for
release to be one.

47
00:02:46,170 --> 00:02:50,560
It turns out that this barrier
code is not entirely correct.

48
00:02:50,560 --> 00:02:55,250
If two threads are synchronizing on
this barrier, the total will be two.

49
00:02:55,250 --> 00:02:58,000
And the barrier actually
works the first time.

50
00:02:59,010 --> 00:03:00,960
So the thread one reaches the barrier.

51
00:03:00,960 --> 00:03:03,670
And so does thread two.

52
00:03:03,670 --> 00:03:07,530
Now they synchronize on this barrier,
and that will work.

53
00:03:07,530 --> 00:03:12,280
But if we try to continue work,
and then synchronize on the same

54
00:03:12,280 --> 00:03:17,870
barrier variable again, we would expect
that this setting of the count to zero,

55
00:03:17,870 --> 00:03:23,520
and is setting of the release to zero,
to work but it doesn't always work.

56
00:03:23,520 --> 00:03:26,330
So this is not an entirely correct

57
00:03:26,330 --> 00:03:29,290
implementation of a barrier that
can be used more than once.
