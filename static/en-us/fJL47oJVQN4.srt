1
00:00:00,000 --> 00:00:05,000
I spent a couple hours porting all the code over into this new format,

2
00:00:05,000 --> 00:00:10,000
and I want to spare you all this editing work so in the final code

3
00:00:10,000 --> 00:00:13,000
that is a little bit incomplete still, we have a grid.

4
00:00:13,000 --> 00:00:15,000
We've got a function called "main."

5
00:00:15,000 --> 00:00:24,000
Main then runs a path planner, A-star, smooths it, and then runs the controller, as in "run."

6
00:00:24,000 --> 00:00:29,000
Then the controller even implemented for you our particle filter that you're familiar with.

7
00:00:29,000 --> 00:00:31,000
There's nothing new here.

8
00:00:31,000 --> 00:00:34,000
You're going to get the exact same code from class that you programmed yourself.

9
00:00:34,000 --> 00:00:39,000
Then I go through a loop where I compute a crosstrack error,

10
00:00:39,000 --> 00:00:44,000
apply my only PD controller--here is no I term here--

11
00:00:44,000 --> 00:00:49,000
and I run my particle filter as before to estimate where the robot is.

12
00:00:49,000 --> 00:00:54,000
What I would like you to do is to implement the crosstrack error function,

13
00:00:54,000 --> 00:00:58,000
and I want you to use as an input the estimate, not the actual robot position,

14
00:00:58,000 --> 00:01:03,000
but the best estimate, which you can get by running filter.get_position.

15
00:01:03,000 --> 00:01:08,000
Now here is the difficulty, and I can tell you confidently it took me more than an hour

16
00:01:08,000 --> 00:01:11,000
to solve this problem myself just for this class.

17
00:01:11,000 --> 00:01:15,000
Our path now is a sequence of linear pieces.

18
00:01:15,000 --> 00:01:19,000
When our robot drives along, it has a certain crosstrack error,

19
00:01:19,000 --> 00:01:25,000
but as the robot state project beyond the end of a line segment, as is happening here,

20
00:01:25,000 --> 00:01:30,000
we have to change the corresponding line segments to be the next one.

21
00:01:30,000 --> 00:01:35,000
I addition, to calculating the assigned error relative to an arbitrary line segment,

22
00:01:35,000 --> 00:01:39,000
not just the y-axis, we also have to detect when the robot steps beyond

23
00:01:39,000 --> 00:01:44,000
the end of a line segment and switch over to the next one.

24
00:01:44,000 --> 00:01:47,000
Now, suppose this is our line segment.

25
00:01:47,000 --> 00:01:53,000
The path is given by the coordinates of the beginning point, p1, and the end point, p2,

26
00:01:53,000 --> 00:01:57,000
both of which are (x, y) coordinates, which you get straight in the path.

27
00:01:57,000 --> 00:02:01,000
Suppose our robot's position is something like this

28
00:02:01,000 --> 00:02:06,000
where it has its own (x, y) estimate that comes out of the particle filter in your case,

29
00:02:06,000 --> 00:02:09,000
and it has it's own orientation, theta.

30
00:02:09,000 --> 00:02:14,000
Then both the cross track error as well as how far it has progressed

31
00:02:14,000 --> 00:02:20,000
along the line segment--call this "U"--can be calculated using a dot product.

32
00:02:20,000 --> 00:02:25,000
Specifically, let's call this vector over here delta x and delta y

33
00:02:25,000 --> 00:02:31,000
as defined in x2 minus x1, and y2 minus y1--this vector over here.

34
00:02:31,000 --> 00:02:40,000
Let's call this vector over here our Rx, which is x minus x1, and Ry.

35
00:02:40,000 --> 00:02:46,000
Then U, the ratio of how far we've progressed along this segment is given

36
00:02:46,000 --> 00:02:53,000
by the dot product Rx times delta x plus Ry times delta y

37
00:02:53,000 --> 00:03:02,000
divided over the sum of squares delta x times delta x plus delta y times delta y. Why?

38
00:03:02,000 --> 00:03:09,000
Well, this normalizes the vector length to 1, and this is the dot product of this vector over here

39
00:03:09,000 --> 00:03:12,000
and the green vector, which happens to define the distance.

40
00:03:12,000 --> 00:03:18,000
If this is larger than 1, we know we've left the segment and it's time to move onto the next one.

41
00:03:18,000 --> 00:03:23,000
Finally, the crosstrack error--the red one over here--is given by a similar

42
00:03:23,000 --> 00:03:29,000
but not identical dot product of Ry times delta--

43
00:03:29,000 --> 00:03:32,000
notice we are now multiplying a y with an x--

44
00:03:32,000 --> 00:03:38,000
minus--instead of plus--our x times delta y

45
00:03:38,000 --> 00:03:41,000
with the exact same normalizer as down here.

46
00:03:41,000 --> 00:03:44,000
You can see the normalizer over here.

47
00:03:44,000 --> 00:03:47,000
What I want you to implement are these pieces of math over here.

48
00:03:47,000 --> 00:03:54,000
When you run your controller, you will find that I setup for you a variable called "index"

49
00:03:54,000 --> 00:03:56,000
that's the index into your path.

50
00:03:56,000 --> 00:04:00,000
When U exceeds 1, we should increment this index

51
00:04:00,000 --> 00:04:04,000
to make sure it never goes beyond what's legal in path length.

52
00:04:04,000 --> 00:04:09,000
The crosstrack error should be computed relative to the current index

53
00:04:09,000 --> 00:04:13,000
and is, of course, the assigned error using the exact same dot product I've shown you.

54
00:04:13,000 --> 00:04:16,000
The last thing I want to tell you is what the path is.

55
00:04:16,000 --> 00:04:18,000
I want you to use the following path.

56
00:04:18,000 --> 00:04:21,000
The path is called "S" path.

57
00:04:21,000 --> 00:04:24,000
It is given the run function as one of the parameters over here.

58
00:04:24,000 --> 00:04:26,000
You can see it up here.

59
00:04:26,000 --> 00:04:33,000
S path index is the indexth element of this path and 0 stands for x and 1 stands for y.

60
00:04:33,000 --> 00:04:37,000
Please fill in the missing code over here.

61
00:04:37,000 --> 00:04:41,000
I should tell you, when you run our controller with the missing code included,

62
00:04:41,000 --> 00:04:45,000
you get actually a valid, nice path that mostly doesn't collide.

63
00:04:45,000 --> 00:04:48,000
Occasionally it does, because of randomness in the system,

64
00:04:48,000 --> 00:04:50,000
but it should be mostly collision free.

65
00:04:50,000 --> 00:04:54,000
For this example, it will require about 130 or so robot steps.

66
00:04:54,000 --> 00:04:59,000
Just so that you see a typical answer, here is a random run.

67
00:04:59,000 --> 00:05:04,000
You read this as follows--true means the robot actually found the goal,

68
00:05:04,000 --> 00:05:08,000
zero means zero collisions, and it took 137 steps.

69
00:05:08,000 --> 00:05:11,000
Let me run it again, and here is another outcome.

70
00:05:11,000 --> 00:05:15,000
The robot didn't collide and reached the goal in 145 steps.

71
00:05:15,000 --> 00:05:17,000
I should warn you that sometimes I do get collisions here,

72
00:05:17,000 --> 00:05:20,000
and it's because our obstacle surfaces are relatively large.

73
00:05:20,000 --> 00:05:23,000
The noise in the system makes it hard to navigate.

74
00:05:23,000 --> 00:05:26,000
But most of the time we should be able to get to the goal without difficulties

75
00:05:26,000 --> 00:05:28,000
if we implement this piece of code correctly.

76
00:05:28,000 --> 99:59:59,999
Just to warn you, it took me quite a while to work this out.
