1
00:00:00,230 --> 00:00:02,310
The first scheduling policy is a very simple

2
00:00:02,310 --> 00:00:05,390
one, first come, first serve. And what this

3
00:00:05,390 --> 00:00:08,330
is saying is that you look at the

4
00:00:08,330 --> 00:00:12,760
order of arrival of threads into the scheduling queue

5
00:00:12,760 --> 00:00:16,219
of the scheduler and pick the one that

6
00:00:16,219 --> 00:00:20,040
is the earliest to become runnable again. And that's

7
00:00:20,040 --> 00:00:21,850
the one that you're going to schedule. So what

8
00:00:21,850 --> 00:00:25,670
this is saying is, well basically we will give

9
00:00:25,670 --> 00:00:29,480
importance to fairness for threads as opposed to affinity.

10
00:00:29,480 --> 00:00:32,680
So it is ignoring affinity altogether and simply saying

11
00:00:32,680 --> 00:00:35,460
let's just be fair. We'll pick the thread that

12
00:00:35,460 --> 00:00:38,450
became runnable at the earliest, that's the one that we're

13
00:00:38,450 --> 00:00:39,990
going to pick as the next one to run on

14
00:00:39,990 --> 00:00:43,460
the processor. That's first come, first served. The second

15
00:00:43,460 --> 00:00:46,870
scheduling policy is called fixed processor, or in other

16
00:00:46,870 --> 00:00:50,720
words, for every thread, when I schedule the thread the

17
00:00:50,720 --> 00:00:52,670
first time, I'm going to pick a particular

18
00:00:52,670 --> 00:00:55,450
processor. And I'm always going to stick to that.

19
00:00:55,450 --> 00:00:58,400
So the processor on which Ti will run

20
00:00:58,400 --> 00:01:02,380
will always be a particular fixed processor. And

21
00:01:02,380 --> 00:01:08,590
the, the, the, way we choose the initial processor on which to schedule Ti may

22
00:01:08,590 --> 00:01:12,880
depend on the, load balance. Making sure that

23
00:01:12,880 --> 00:01:15,740
all the processors in the multiprocessor are equally

24
00:01:15,740 --> 00:01:20,020
stressed in terms of, using the resources for

25
00:01:20,020 --> 00:01:22,300
running the available threads that are there in the

26
00:01:22,300 --> 00:01:24,380
system. And that's how I pick a particular

27
00:01:24,380 --> 00:01:27,470
processor but you, for the life of this thread,

28
00:01:27,470 --> 00:01:29,380
the processor on which Ti is going to run

29
00:01:29,380 --> 00:01:33,480
is always fixed. So that's fixed processor scheduling. The

30
00:01:33,480 --> 00:01:35,892
third scheduling policy is what is called a

31
00:01:35,892 --> 00:01:40,870
last proccessor scheduling policy. The idea here is the

32
00:01:40,870 --> 00:01:44,680
processor is going to pick among the set of threads

33
00:01:44,680 --> 00:01:47,170
that are available to be run at any point

34
00:01:47,170 --> 00:01:50,304
of time. It is going to pick a thread that

35
00:01:50,304 --> 00:01:53,545
used to run on it. In other words, if TI

36
00:01:53,545 --> 00:01:57,260
the last time it had any cycles from the

37
00:01:57,260 --> 00:02:01,030
system was on a particular processor. Then, when this

38
00:02:01,030 --> 00:02:04,020
processor is coming around looking for work, it'll see

39
00:02:04,020 --> 00:02:06,450
oh, Ti is there, he used to run on me.

40
00:02:06,450 --> 00:02:09,090
I'm going to pick that guy to run on me again. And

41
00:02:09,090 --> 00:02:11,520
as you can imagine, this is giving preference to the fact

42
00:02:11,520 --> 00:02:15,670
that there could be affinity for Ti to this processor, because

43
00:02:15,670 --> 00:02:17,670
it used to run on this. So that is what is

44
00:02:17,670 --> 00:02:22,340
called last processor scheduling, and of course when a processor is

45
00:02:22,340 --> 00:02:25,790
looking for work and it looks at the run queue, does

46
00:02:25,790 --> 00:02:28,120
not find any thread that used to run on it, and

47
00:02:28,120 --> 00:02:31,470
of course it has to pick some thread, right? So the,

48
00:02:31,470 --> 00:02:35,300
the inclination is to pick the thread that had

49
00:02:35,300 --> 00:02:39,020
run on this processor before. And, and that's the one

50
00:02:39,020 --> 00:02:41,310
that I want to schedule on P last. But

51
00:02:41,310 --> 00:02:43,150
if such a thread is not available, then you're going to

52
00:02:43,150 --> 00:02:45,900
pick something else. So, the idea behind this is

53
00:02:45,900 --> 00:02:49,038
that, you want to make sure that if this processor

54
00:02:49,038 --> 00:02:51,745
is going to pick a thread to run on it, the

55
00:02:51,745 --> 00:02:57,050
likelihood of this thread finding its memory contents in this

56
00:02:57,050 --> 00:02:59,478
processor is high. That's, that's what we're trying

57
00:02:59,478 --> 00:03:01,960
to shoot for in this last processor. The next

58
00:03:01,960 --> 00:03:04,140
couple of scheduling policies I'm going to tell you

59
00:03:04,140 --> 00:03:07,770
about. It requires more sophistication in terms of the

60
00:03:07,770 --> 00:03:10,960
information that the scheduler needs to keep on

61
00:03:10,960 --> 00:03:13,744
behalf of every thread. You know in order to

62
00:03:13,744 --> 00:03:17,040
make a scheduling decision. The next scheduling policy is

63
00:03:17,040 --> 00:03:22,460
what is called minimum Intervening policy. MI for short.

64
00:03:22,460 --> 00:03:24,870
And in MI, what we're going to do is the

65
00:03:24,870 --> 00:03:29,060
following. We're going to keep, for every thread, it's affinity with

66
00:03:29,060 --> 00:03:34,160
respect to a particular processor, and pick the processor for

67
00:03:34,160 --> 00:03:37,590
running this thread in which this thread has the highest affinity.
