1
00:00:00,000 --> 00:00:03,000
Now I'm going to show you how these translation tables work.

2
00:00:03,000 --> 00:00:07,000
I'm going to define a variable called "table"

3
00:00:07,000 --> 00:00:15,000
that's using the string.maketrans function, which makes a translation table,

4
00:00:15,000 --> 00:00:24,000
and I'm going to tranlate from the characters 'ABC' to '123.'

5
00:00:24,000 --> 00:00:27,000
I can give any number of characters here--

6
00:00:27,000 --> 00:00:31,000
the characters I want to replace and the ones I want to replace them with.

7
00:00:31,000 --> 00:00:35,000
I should say that this is using the string module,

8
00:00:35,000 --> 00:00:42,000
so somewhere we have to say import string before we start doing any of this.

9
00:00:42,000 --> 00:00:45,000
You only have to do that import once, of course.

10
00:00:45,000 --> 00:00:58,000
Now I'm going to define a formula f to be a simple formula A plus B equals C.

11
00:00:58,000 --> 00:01:08,000
Then I'm going to call the translate method of the formula f and pass it this translation table.

12
00:01:08,000 --> 00:01:18,000
That will evaluate to the string 1 plus 2 equals 3.

13
00:01:18,000 --> 00:01:21,000
It has taken each of the elements in the table,

14
00:01:21,000 --> 00:01:25,000
and they correspond A to 1, B to 2, C to 3,

15
00:01:25,000 --> 00:01:30,000
substituted those into f and given me back a brand new string.

16
00:01:30,000 --> 00:01:37,000
Now if I go ahead and evaluate f.translate of table,

17
00:01:37,000 --> 00:01:45,000
which is 1 plus 2 equals 3, then that will give me the result True,

18
00:01:45,000 --> 00:01:49,000
because 1 plus 2 is 3, and that's a legal Python expression.

19
00:01:49,000 --> 00:01:57,000
Now what I want you to do is to define for me the function "valid,"

20
00:01:57,000 --> 00:02:04,000
which takes a filled-in formula like 1 plus 2 equals 3, filled-in formula f,

21
00:02:04,000 --> 00:02:09,000
and returns True or False. True if the formula is, in fact, valid.

22
00:02:09,000 --> 00:02:13,000
If it represents a true equation like this.

23
00:02:13,000 --> 00:02:23,000
And False if it represents an invalid equation like 1 plus 3 equals 3.

24
00:02:23,000 --> 00:02:33,000
Or it should also return False if it represents a error like 1 divided by 0 equals 3.

25
00:02:33,000 --> 00:02:36,000
That wouldn't return True or False, that would signal an error,

26
00:02:36,000 --> 00:02:41,000
and I want you to handle that within the code for valid.

27
00:02:41,000 --> 00:02:44,000
I'll give you a hint,

28
00:02:44,000 --> 00:02:48,000
which is you should consider using a try statement.

29
00:02:48,000 --> 00:02:57,000
Try, do something, and then you can say "except ZeroDivisionError" something.

30
00:02:57,000 --> 00:03:04,000
What that does is it executes the main body in which you can test if evaluating

31
00:03:04,000 --> 00:03:11,000
this expression f is true or not and return appropriately,

32
00:03:11,000 --> 00:03:17,000
but if evaluating the expression f causes a zero division error,

33
00:03:17,000 --> 00:03:21,000
then this clause will catch it, and then you can do the appropriate thing here.

34
00:03:21,000 --> 00:03:25,000
You should also think about if there's anything else that can go wrong

35
00:03:25,000 --> 00:03:28,000
within the execution of valid.

36
00:03:28,000 --> 00:03:31,000
Here's my version of the solution.

37
00:03:31,000 --> 00:03:38,000
I'm defining valid, takes filled-in formula f, and it's going to return True.

38
00:03:38,000 --> 00:03:44,000
The main part is if we evaluate f and if that's true, then we should return True,

39
00:03:44,000 --> 00:03:47,000
but I also had to check for the zero division error

40
00:03:47,000 --> 00:03:50,000
and even to be a little bit more sore here,

41
00:03:50,000 --> 00:03:55,000
I ended up checking for arithmetic error, which is a super class of zero division error.

42
00:03:55,000 --> 00:04:01,000
It covers a few additional things like overflow of really big numbers.

43
00:04:01,000 --> 00:04:07,000
You didn't have to do that. I would've been fine to just catch the zero division error.

44
00:04:07,000 --> 00:04:10,000
If there is such an error, then you should return False.

45
00:04:10,000 --> 00:04:13,000
But I did one more thing here, and it looks kind of complicated.

46
00:04:13,000 --> 00:04:19,000
I'm using a regular expression search, and let's look at exactly what's going on

47
00:04:19,000 --> 99:59:59,999
in this confusing part of the clause here.
