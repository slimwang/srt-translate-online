1
00:00:00,000 --> 00:00:03,000
Alternate history is a genre of fiction where we explore what would have happened to the world

2
00:00:03,000 --> 00:00:05,000
had some historical event turned out differently.

3
00:00:05,000 --> 00:00:07,000
For example, we might have an alternate history now exploring

4
00:00:07,000 --> 00:00:09,000
what would have happened if the Allies hadn't won World War II.

5
00:00:09,000 --> 00:00:12,000
What we're going to do is look at a few alternate history examples where we're going to try

6
00:00:12,000 --> 00:00:16,000
to explore the question, "What would've happened if certain groups of people in the past had used

7
00:00:16,000 --> 00:00:19,000
random testing in addition to whatever other kinds of testing they were doing?"

8
00:00:19,000 --> 00:00:23,000
And we're going to sort of specifically focus on the question, "Would random testing have been likely

9
00:00:23,000 --> 00:00:26,000
to alter the outcome of some famous software bugs but would have not made much difference?

10
00:00:26,000 --> 00:00:28,000
Would it have not been a very useful technique?"

11
00:00:28,000 --> 00:00:32,000
And so the first case study we're going to look at is the FDIV bug in Intel Pentium chips.

12
00:00:32,000 --> 00:00:36,000
And so in 1994, it came to the world's attention that the FDIV instruction supported by

13
00:00:36,000 --> 00:00:40,000
Intel's Pentium processor was flawed and so FDIV is an instruction that you would use

14
00:00:40,000 --> 00:00:42,000
to perform floating point division.

15
00:00:42,000 --> 00:00:47,000
If we're writing an assembly language for a Pentium, we would issue the FDIV instruction

16
00:00:47,000 --> 00:00:52,000
with two operands and what do we do is compute the quotient of a divided by b.

17
00:00:52,000 --> 00:00:54,000
And so what happened is there's a bug in FDIV.

18
00:00:54,000 --> 00:00:57,000
And what had happened was the implementation of FDIV, that is to say

19
00:00:57,000 --> 00:01:01,000
the hardware implementation of this machine instruction was intended to be very fast.

20
00:01:01,000 --> 00:01:03,000
The Pentium was at that time a very high performance processor.

21
00:01:03,000 --> 00:01:08,000
And the way FDIV was fast, at least in part, was because it did part of its work using table lookups.

22
00:01:08,000 --> 00:01:11,000
So there was this table of values stored in the Pentium's hardware.

23
00:01:11,000 --> 00:01:13,000
What had happened was somewhere on the way to fabrication

24
00:01:13,000 --> 00:01:16,000
some of the values had not been loading correctly into the table.

25
00:01:16,000 --> 00:01:20,000
So part of the lookup table, I believe it was 5 entries, contained the wrong results.

26
00:01:20,000 --> 00:01:24,000
And for some values of A and B passed to the FDIV instruction, looking up these wrong results

27
00:01:24,000 --> 00:01:27,000
in the lookup table would cause it to do the wrong thing.

28
00:01:27,000 --> 00:01:31,000
This wasn't an extremely major error in the sense that it would return a million instead of 0

29
00:01:31,000 --> 00:01:35,000
but rather it was off in sort of some number of places after the decimal point.

30
00:01:35,000 --> 00:01:39,000
The reason that the flaws in FDIV went undetected for sometime was that only about

31
00:01:39,000 --> 00:01:43,000
1 in 9 Billion randomly selected inputs would actually trigger the bug.

32
00:01:43,000 --> 00:01:48,000
And so now the question we need to ask ourselves is given this relatively low observed failure rate

33
00:01:48,000 --> 00:01:53,000
on random inputs, would random testing have been a good way to find the Pentium FDIV bug?

34
00:01:53,000 --> 00:01:55,000
And the answer is almost certainly yes.

35
00:01:55,000 --> 00:01:58,000
So what we're going to do now is try to figure out about how long it would've taken Intel

36
00:01:58,000 --> 00:02:00,000
to find this bug using random testing.

37
00:02:00,000 --> 00:02:03,000
And so the first thing we're going to need to do is make an assumption about

38
00:02:03,000 --> 00:02:05,000
how many tests per second they can run.

39
00:02:05,000 --> 00:02:09,000
And so it's not as if in 1994 they have modern multigigahertz hardware available

40
00:02:09,000 --> 00:02:12,000
but rather these Pentiums ran at around 60 MHz.

41
00:02:12,000 --> 00:02:16,000
And so what we're going to say for the sake of argument is that it took 10 ÃÄ¾s

42
00:02:16,000 --> 00:02:19,000
to perform an FDIV and verify its result.

43
00:02:19,000 --> 00:02:24,000
So in other words, at 60 MHz, I'm assuming that it would take about 600 cycles

44
00:02:24,000 --> 00:02:26,000
to check a particular input for FDIV.

45
00:02:26,000 --> 00:02:31,000
Now let's try to work out the math.
