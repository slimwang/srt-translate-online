1
00:00:00,220 --> 00:00:04,566
If you never wrote any program in Python, here is

2
00:00:04,566 --> 00:00:09,654
some advice on the specifics of Python. If you

3
00:00:09,654 --> 00:00:12,439
know your way around Python simply skip this

4
00:00:12,439 --> 00:00:15,994
segment. To indicate that the rest of the line is

5
00:00:15,994 --> 00:00:19,947
a comment, simply put a # in front of that line

6
00:00:19,947 --> 00:00:24,777
to create variables simply type the name and

7
00:00:24,777 --> 00:00:28,258
write equals whatever you want, you do not

8
00:00:28,258 --> 00:00:31,924
specific the type of a variable, unlike in C or

9
00:00:31,924 --> 00:00:36,056
in Java or in C++ or in C#, Python is

10
00:00:36,056 --> 00:00:39,875
going to figure out the type on its own, like

11
00:00:39,875 --> 00:00:42,441
Javascript if you will. So that’s an allowed name.

12
00:00:42,441 --> 00:00:46,326
answer = 42, radius underscore of underscore earth

13
00:00:46,326 --> 00:00:52,869
is an allowed name, 6.371 times 10 to the 6.

14
00:00:52,869 --> 00:00:58,012
I’m writing comment M to say meters

15
00:00:58,012 --> 00:01:00,961
by just simplest way of indicating what the

16
00:01:00,961 --> 00:01:03,386
measurement unit would be. And you must not

17
00:01:03,386 --> 00:01:08,028
start names with digits: 13test, too is not a

18
00:01:08,028 --> 00:01:11,107
correct name. The print command, print out,

19
00:01:11,107 --> 00:01:14,562
what you’ve given after it, very simple. If you

20
00:01:14,562 --> 00:01:17,120
want to specify more things, simply use commas.

21
00:01:17,120 --> 00:01:20,579
This now shows some basic arithmetic’s advantage
I wrote it first

22
00:01:20,579 --> 00:01:24,228
for us to discuss the results. 42 is assigned to

23
00:01:24,228 --> 00:01:29,504
answer, 6.37 something times 10 to the 6 is

24
00:01:29,504 --> 00:01:32,629
assigned to radius underscore of underscore earth,

25
00:01:32,629 --> 00:01:36,385
now we do some computation of three times

26
00:01:36,385 --> 00:01:40,102
answer plus four and the result is assigned to a

27
00:01:40,102 --> 00:01:44,659
variable called A. Note that multiplication and

28
00:01:44,659 --> 00:01:48,363
division are executed before plus and minus.

29
00:01:48,363 --> 00:01:50,819
Now we take the radius of earth to the second

30
00:01:50,819 --> 00:01:54,504
power. Asteric asteric (**) represents the power

31
00:01:54,504 --> 00:01:58,395
operator in Python unlike C, unlike Java.

32
00:01:58,395 --> 00:02:02,273
Parenthesis work as they work in school and

33
00:02:02,273 --> 00:02:05,920
again the power operator 0.5 of course meaning

34
00:02:05,920 --> 00:02:08,151
this is the square root, that’s one way of

35
00:02:08,151 --> 00:02:12,394
writing this square root of A+3, the result

36
00:02:12,394 --> 00:02:14,749
is assigned to B. See this is what our output

37
00:02:14,749 --> 00:02:18,330
here. The second one gets pretty ugly. The

38
00:02:18,330 --> 00:02:21,664
content of answer is incremented by seven.

39
00:02:21,664 --> 00:02:24,864
Plus equals seven, that’s the same as in C and

40
00:02:24,864 --> 00:02:27,676
in Java and in Javascript. The increment operates

41
00:02:27,676 --> 00:02:31,558
on the same work for minus equals time equals

42
00:02:31,558 --> 00:02:34,904
divided equals. What you can’t do is plus, plus

43
00:02:34,904 --> 00:02:38,427
unlike C and its sibling. If you want to do plus

44
00:02:38,427 --> 00:02:41,760
plus you have to write plus equals one. This again

45
00:02:41,760 --> 00:02:44,818
is similar to C, if you divide integer numbers

46
00:02:44,818 --> 00:02:48,501
five divided by four, the result is an integer

47
00:02:48,501 --> 00:02:51,608
number. Lets look at up. C is the fourth one

48
00:02:51,608 --> 00:02:57,086
one, two, three, four.. 1... 5 / 4 is 1

49
00:02:57,086 --> 00:03:01,241
in Python as is for C and for Java and so on.

50
00:03:01,241 --> 00:03:03,385
If you want to see a floating point division at

51
00:03:03,385 --> 00:03:05,602
least one of these two numbers has to be of

52
00:03:05,602 --> 00:03:08,600
floating point numbers, simply write 4. (i.e., 4 dot)

53
00:03:08,600 --> 00:03:15,677
d.. Let's look at the second to last.. 1.25.. it works.. or 1.0

54
00:03:15,677 --> 00:03:20,108
times five divided by 4, Python starts from the

55
00:03:20,108 --> 00:03:26,499
left as does C, as does Java 1.0 times five is

56
00:03:26,499 --> 00:03:28,782
a floating point number that’s divided by the

57
00:03:28,782 --> 00:03:31,835
integer number results of floating point number.

58
00:03:31,835 --> 00:03:35,216
Keep that in mind, there is something that easy

59
00:03:35,216 --> 00:03:38,413
leads to not so obvious errors. There is more to

60
00:03:38,413 --> 00:03:41,650
mathematics than arithmetic’s. To do more we

61
00:03:41,650 --> 00:03:44,981
need to import the math library. This is

62
00:03:44,981 --> 00:03:47,965
done best at the start of a program when we need

63
00:03:47,965 --> 00:03:51,157
the square root, we then can then write math.sqrt(4)

64
00:03:51,157 --> 00:03:53,602
which actually is the

65
00:03:53,602 --> 00:03:57,850
same as four asteric asteric 0.5, if we need the sin

66
00:03:57,850 --> 00:04:02,230
function its math.sin parenthesis, the angle.

67
00:04:02,230 --> 00:04:05,274
Of course this angle is specified in radians,

68
00:04:05,274 --> 00:04:09,441
not in angular degrees. To convert from angular

69
00:04:09,441 --> 00:04:12,800
degrees to radians multiplie by pi - math.pi,

70
00:04:12,800 --> 00:04:17,322
it’s a built-in constant, divided by 180.

71
00:04:17,322 --> 00:04:20,887
If lines get longer, we may need to break the line

72
00:04:20,887 --> 00:04:23,974
to keep it readable, if there is an open

73
00:04:23,974 --> 00:04:27,107
parenthesis, you can break at any point then

74
00:04:27,107 --> 00:04:30,185
sometime close that parenthesis. If lines get

75
00:04:30,185 --> 00:04:33,114
longer, we may need to break them to make

76
00:04:33,114 --> 00:04:35,999
things – to keep things readable. Python is picky

77
00:04:35,999 --> 00:04:40,258
about lines. You cannot break anywhere; that’s

78
00:04:40,258 --> 00:04:43,665
unlike C and Java. But if there is an open

79
00:04:43,665 --> 00:04:47,439
parenthesis you can break anywhere. Python

80
00:04:47,439 --> 00:04:50,662
is going to wait for that closing parenthesis.

81
00:04:50,662 --> 00:04:53,138
For the standard mathematical functions, such as

82
00:04:53,138 --> 00:04:56,080
square root and sign, we need to import the

83
00:04:56,080 --> 00:04:59,813
math library. This is done best at the beginning

84
00:04:59,813 --> 00:05:03,471
of a program and then you invoke the square

85
00:05:03,471 --> 00:05:07,269
root for instance by typing math.square root and

86
00:05:07,269 --> 00:05:10,824
the argument is given in parenthesis. That’s

87
00:05:10,824 --> 00:05:14,297
pretty similar to Java and to C#. The result,

88
00:05:14,297 --> 00:05:17,532
of course, is 2.0. We could also have written four

89
00:05:17,532 --> 00:05:22,242
to the 0.5 power. The sin function is math.sin.

90
00:05:22,242 --> 00:05:25,367
The cosine would be math.cos and so on. The

91
00:05:25,367 --> 00:05:29,724
constant pi is included as math.pi. The sin

92
00:05:29,724 --> 00:05:33,718
function and it's friends work with radians,

93
00:05:33,718 --> 00:05:38,581
not with angular degrees. So if 23.4 is an angular

94
00:05:38,581 --> 00:05:41,857
degrees, we need to convert it. For instance, by

95
00:05:41,857 --> 00:05:46,388
multiplying with pi and dividing by 180. If lines

96
00:05:46,388 --> 00:05:49,506
get longer, you may want to break them to keep

97
00:05:49,506 --> 00:05:52,225
things readable, Python is picky about line

98
00:05:52,225 --> 00:05:56,573
breaks. That’s very much unlike C and Java. You

99
00:05:56,573 --> 00:06:00,311
cannot break a line at any place, but if there

100
00:06:00,311 --> 00:06:02,291
is at least one open parenthesis, you can

101
00:06:02,291 --> 00:06:04,884
break the line. This is what I’m using here.

102
00:06:04,884 --> 00:06:07,712
If you need something to be done a given number

103
00:06:07,712 --> 00:06:12,262
of times, you can use the 'for' loop, which looks

104
00:06:12,262 --> 00:06:15,961
quite different from C. The first thing that you notice

105
00:06:15,961 --> 00:06:19,211
is a colon at the end, no braces, but a

106
00:06:19,211 --> 00:06:22,187
colon here, at the end of the first line, and

107
00:06:22,187 --> 00:06:25,328
indentation. The indentation and that colon

108
00:06:25,328 --> 00:06:28,288
replace what C users know as curly braces.

109
00:06:28,303 --> 00:06:34,093
What happens here? h starts with 0, gets 1,

110
00:06:34,093 --> 00:06:38,059
2 and so on and at the end its 6 and then the

111
00:06:38,059 --> 00:06:41,814
loop terminates. So you do not write 'for h =0;'

112
00:06:41,814 --> 00:06:47,284
and so on. h < 7, you write 'for h in range 7'

113
00:06:47,284 --> 00:06:51,407
That’s the Python way. So if we look

114
00:06:51,407 --> 00:06:56,590
at the result... so it prints out square numbers

115
00:06:56,590 --> 00:07:02,625
starting with 0, and eventually terminating at 6

116
00:07:02,625 --> 00:07:05,236
to the second power. The 'while' loop is good for

117
00:07:05,236 --> 00:07:09,435
loops that run as long as something has to be done.

118
00:07:09,435 --> 00:07:13,430
So in this case, this loop runs as long as K is less

119
00:07:13,430 --> 00:07:21,566
than 130 or M is equal 140. So unlike C, you do

120
00:07:21,566 --> 00:07:27,155
not write '|| 4', you simply spell out 'or'. The same for &&.

121
00:07:27,155 --> 00:07:31,034
Don’t forget the colon, so

122
00:07:31,034 --> 00:07:35,657
we see that K runs up to 130, this first

123
00:07:35,657 --> 00:07:38,788
condition fails and the second one is not

124
00:07:38,788 --> 00:07:43,561
true either because M is 7,000 something.

125
00:07:43,561 --> 00:07:48,648
Now to conditional execution - if the value of K

126
00:07:48,648 --> 00:07:52,305
is larger than 42, don’t forget the colon,

127
00:07:52,305 --> 00:07:56,146
output 'Hi'. The text string and single quotes

128
00:07:56,146 --> 00:07:59,610
and 'elif' – that means if K was not larger than

129
00:07:59,610 --> 00:08:05,625
42, check if M is larger than 43. If so, output

130
00:08:05,625 --> 00:08:09,860
'Hello', if not which means if M is not larger than

131
00:08:09,860 --> 00:08:16,476
43, output "Buy". And of course K is larger than 42,

132
00:08:16,476 --> 00:08:19,920
its 130. So we output "Hi" and never see the rest.

133
00:08:19,920 --> 00:08:24,864
The 'else' is optional and the 'elif' is optional.

134
00:08:24,864 --> 00:08:28,469
We need to work with long lists of data. This

135
00:08:28,469 --> 00:08:31,877
package called numpy; it comes in handy, yeah.

136
00:08:31,877 --> 00:08:37,155
numpy.zeros creates a one dimensional array and this

137
00:08:37,155 --> 00:08:41,053
case with five entries numbered from 0 to 4, like in

138
00:08:41,053 --> 00:08:45,134
C. Here I change the entry number 0 and here

139
00:08:45,134 --> 00:08:48,310
I change the entry number 4, which is the last entry.

140
00:08:48,310 --> 00:08:50,913
I print the complete array and here I print the

141
00:08:50,913 --> 00:08:54,878
ultimate entry. This comes in very handy and is

142
00:08:54,878 --> 00:08:58,735
different from C and other languages. So the

143
00:08:58,735 --> 00:09:04,659
complete array contains 20,0,0,0,99 because I

144
00:09:04,659 --> 00:09:08,151
changed the entry number 0 and I changed the entry

145
00:09:08,151 --> 00:09:12,509
number 4. And the entry number if you will, minus

146
00:09:12,509 --> 00:09:16,077
1 is simply the last one. Often we do not get

147
00:09:16,077 --> 00:09:19,501
away with one dimensional lists, we’ve to use

148
00:09:19,501 --> 00:09:23,750
two dimensional tables. This creates a table

149
00:09:23,750 --> 00:09:29,263
that’s filled with 0s and has two rows and 3 columns.

150
00:09:29,263 --> 00:09:33,831
Here I change the entry that’s in the upper row,

151
00:09:33,831 --> 00:09:38,041
row number 0 and in the middle column, column

152
00:09:38,041 --> 00:09:43,729
number 1 (column is ranged from 0, 1 to 2) to 7.

153
00:09:43,729 --> 00:09:47,813
And here I change the entry in the lower row,

154
00:09:47,813 --> 00:09:51,313
the rows are 0 and 1 and in the right most

155
00:09:51,313 --> 00:09:57,127
column to 8, I output that. And then I do some

156
00:09:57,127 --> 00:10:00,659
arithmetic’s with matrices that is we’re

157
00:10:00,659 --> 00:10:03,260
going to cover that later, one plus twice

158
00:10:03,260 --> 00:10:05,976
the complete table that I built here.

159
00:10:05,976 --> 00:10:09,224
Let’s look at the output. So, that’s our array.

160
00:10:09,224 --> 00:10:15,462
0,7,0 is the row number 0. 0,0.8 is the row number 1.

161
00:10:15,462 --> 00:10:20,312
We changed the entry second column,

162
00:10:20,312 --> 00:10:23,950
row number 1 to 8. Thats this guy . And

163
00:10:23,950 --> 00:10:29,209
here I computed the one plus twice the array as

164
00:10:29,209 --> 00:10:34,439
above. The 7 becomes one plus two times 7,

165
00:10:34,439 --> 00:10:39,715
15, the 8 becomes one plus two times 8, 17.

166
00:10:39,715 --> 00:10:42,655
This again is something that you can’t do with

167
00:10:42,655 --> 00:10:45,841
regular arrays and C or in Java. This comes

168
00:10:45,841 --> 00:10:49,651
very handy for mathematics. And there is one

169
00:10:49,651 --> 00:10:52,565
more thing that resembles arrays in C and

170
00:10:52,565 --> 00:10:56,249
arrays in Java, if you think you copy that array,

171
00:10:56,249 --> 00:10:59,224
you didn’t actually create a copy, you just

172
00:10:59,224 --> 00:11:03,186
created a reference to the very same thing in

173
00:11:03,186 --> 00:11:07,206
memory. So yeah, it seem to create a copy Q

174
00:11:07,206 --> 00:11:12,724
equals P, I changed the copy to make the left

175
00:11:12,724 --> 00:11:16,904
– the top most left entry equal to 42. And then

176
00:11:16,904 --> 00:11:22,774
I output P and you see, if I look at P its too has the

177
00:11:22,774 --> 00:11:26,633
value 42 in here. There is just one instance

178
00:11:26,633 --> 00:11:30,549
of that array in memory; both Q and P refer to the

179
00:11:30,549 --> 00:11:34,549
same instance and memory.

180
00:11:34,549 --> 00:11:36,792
This is how we define functions in Python. We say def

181
00:11:36,792 --> 00:11:41,433
function name, the parameters that we want

182
00:11:41,433 --> 00:11:44,047
to hand over to the function, colon and

183
00:11:44,047 --> 00:11:46,575
then comes what the function should do.

184
00:11:46,575 --> 00:11:51,133
Again, of course, with indentation. And you call

185
00:11:51,133 --> 00:11:54,404
this function like you call math.sin and other

186
00:11:54,404 --> 00:11:57,457
build in functions: with parenthesis, similar to

187
00:11:57,457 --> 00:12:02,001
C and Java. So in this case U is set to 1,

188
00:12:02,001 --> 00:12:08,255
we compute two times U, R becomes 2

189
00:12:08,255 --> 00:12:12,563
and we return 2 plus 1 equals 3 and then

190
00:12:12,563 --> 00:12:16,530
this case its 7, U is set to 7, R becomes

191
00:12:16,530 --> 00:12:20,530
14 and we return 14 plus 7, that is 21.
