1
00:00:00,350 --> 00:00:02,765
But this loss of protection with the

2
00:00:02,765 --> 00:00:05,870
Dos-like structure is simply unacceptable for a

3
00:00:05,870 --> 00:00:08,460
general purpose operating system today. On the

4
00:00:08,460 --> 00:00:12,310
other hand, the monolithic structure gives the protection

5
00:00:12,310 --> 00:00:17,222
that is so important. At the same time, what it strives to do is also

6
00:00:17,222 --> 00:00:20,440
(no period) It reduces the potential for

7
00:00:20,440 --> 00:00:25,650
performance loss by consolidating all the services in

8
00:00:25,650 --> 00:00:28,750
one big monolithic structure. That is, even

9
00:00:28,750 --> 00:00:32,170
tough and application has to go from its

10
00:00:32,170 --> 00:00:35,150
address space, into the operating system's address

11
00:00:35,150 --> 00:00:39,330
space in order to get some service, It

12
00:00:39,330 --> 00:00:42,410
is usually the case that the operating

13
00:00:42,410 --> 00:00:45,980
system has several components and they have to

14
00:00:45,980 --> 00:00:48,300
talk to one another in order to provide

15
00:00:48,300 --> 00:00:51,180
the service that an application wants. Think about

16
00:00:51,180 --> 00:00:54,050
the file system, for instance. You make a call

17
00:00:54,050 --> 00:00:56,740
to the file system to open a file and the

18
00:00:56,740 --> 00:01:00,430
file system then may have to call the storage module

19
00:01:00,430 --> 00:01:03,320
in order to find out where exactly a file is

20
00:01:03,320 --> 00:01:06,000
residing. And it may have to contact The memory

21
00:01:06,000 --> 00:01:10,160
manager module to see where it wants to bring in

22
00:01:10,160 --> 00:01:12,700
the file that you want to open and see the

23
00:01:12,700 --> 00:01:16,270
content of. So in this sense there's infraction that's going to

24
00:01:16,270 --> 00:01:18,820
go on under the cover. Inside the

25
00:01:18,820 --> 00:01:21,130
operating system between components of the operating

26
00:01:21,130 --> 00:01:23,890
system. In order to satisfy a single

27
00:01:23,890 --> 00:01:27,120
service call from an application. So this monolithic

28
00:01:27,120 --> 00:01:33,760
structure insures that even though... We have to go from an application into the

29
00:01:33,760 --> 00:01:37,960
operating system's address space. Once you're inside

30
00:01:37,960 --> 00:01:41,560
the operating system's address space, then potential for

31
00:01:41,560 --> 00:01:45,320
performance loss is avoided by the consolidation

32
00:01:45,320 --> 00:01:47,890
of all the components that comprise the

33
00:01:47,890 --> 00:01:50,340
operating system. But what is lost in

34
00:01:50,340 --> 00:01:52,570
the monolithic structure (no period) That is the

35
00:01:52,570 --> 00:01:57,430
ability to customize the operating system service

36
00:01:57,430 --> 00:02:00,710
for different applications. This model of one

37
00:02:00,710 --> 00:02:03,240
size fits all, so far the system

38
00:02:03,240 --> 00:02:06,790
service is concerned with the monolithic structure shutsoed

39
00:02:06,790 --> 00:02:11,090
the opportunity for customizing the operating service

40
00:02:11,090 --> 00:02:13,890
for the needs of different applications. Now,

41
00:02:13,890 --> 00:02:16,350
you may wonder why do we need

42
00:02:16,350 --> 00:02:19,170
to customize the operating system service for different

43
00:02:19,170 --> 00:02:24,880
applications? Why not one size fits all? Why is there an issue? If you look

44
00:02:24,880 --> 00:02:26,710
at a couple of examples, the need

45
00:02:26,710 --> 00:02:31,880
for customization will become fairly obvious. For example,

46
00:02:31,880 --> 00:02:35,520
Interactive video games. The requirement of applications,

47
00:02:35,520 --> 00:02:39,020
that are providing a video game experience

48
00:02:39,020 --> 00:02:42,470
for the user. Or consider another application,

49
00:02:42,470 --> 00:02:45,290
which is computing, All the prime numbers. You

50
00:02:45,290 --> 00:02:48,330
can immediately see that the operating system

51
00:02:48,330 --> 00:02:51,980
needs for these two classes of applications

52
00:02:51,980 --> 00:02:57,060
are perhaps very different. On the one hand, for the little kid who is playing

53
00:02:57,060 --> 00:02:59,520
a video game, the key determinant of

54
00:02:59,520 --> 00:03:02,560
a good operating system would be responsiveness. How

55
00:03:02,560 --> 00:03:04,890
quickly the operating system is responding to his

56
00:03:04,890 --> 00:03:07,650
nifty moves when he plays his video game.

57
00:03:07,650 --> 00:03:09,550
On the other hand, for the programmer

58
00:03:09,550 --> 00:03:13,180
that wrote this prime number computing application, the

59
00:03:13,180 --> 00:03:17,340
key determinant of performance is going to be sustained

60
00:03:17,340 --> 00:03:21,780
CPU time that's available for crunching his application.
