1
00:00:00,360 --> 00:00:04,240
So more specific questions about building these applications

2
00:00:04,240 --> 00:00:10,390
include the following. One kind of question is, how do the clients know

3
00:00:10,390 --> 00:00:15,700
what capabilities are available to them? One approach, which is typically used,

4
00:00:15,700 --> 00:00:22,100
is naming. That is the client has the IP address or URL of server technology.

5
00:00:22,100 --> 00:00:26,950
Okay? And it, it essentially finds that service by providing that name.

6
00:00:26,950 --> 00:00:31,720
You can think of this as White Pages in the, in the telephone sense.

7
00:00:31,720 --> 00:00:37,815
An alternative to this approach is a client saying, I have a need for service x,

8
00:00:37,815 --> 00:00:44,590
and being able to try to find various resources that can find,

9
00:00:44,590 --> 00:00:48,040
can provide that service. That's similar to a Yellow Pages lookup.

10
00:00:49,240 --> 00:00:51,980
Some Yellow Pages technology have come out, but

11
00:00:51,980 --> 00:00:56,140
it hasn't proven quite as successful as maybe we had hoped.

12
00:00:56,140 --> 00:01:00,238
Second research question has to do with use of reflection and

13
00:01:00,238 --> 00:01:05,790
meta-object protocols. Recall that I mentioned that data can sometimes be

14
00:01:05,790 --> 00:01:10,510
self defining, that is the data itself reflects or

15
00:01:10,510 --> 00:01:13,930
represents its own structure. The same thing can hold with respect to,

16
00:01:13,930 --> 00:01:18,580
to programs, that is programs knowing what kind of services they provide

17
00:01:18,580 --> 00:01:24,950
even knowing how, they deal with non-functional considerations.

18
00:01:24,950 --> 00:01:27,910
How many transactions can they provide in a given unit of time and so on.

19
00:01:27,910 --> 00:01:33,660
The third category of questions has to do with data representations. For

20
00:01:33,660 --> 00:01:39,110
the past 20 years, relational databases have dominated the world, but

21
00:01:39,110 --> 00:01:45,390
now there's a recognition that one size does not fit all. The different

22
00:01:45,390 --> 00:01:49,260
kinds of applications might require different kinds of organizations for

23
00:01:49,260 --> 00:01:53,720
the data. Okay. This movement is sometimes called the NoSQL movement, and

24
00:01:53,720 --> 00:01:55,350
there is various commercial,

25
00:01:55,350 --> 00:02:00,130
even solutions out there that you can consider in building your applications.

26
00:02:00,130 --> 00:02:06,720
Another question is, fat versus thin. Particularly fat versus thin clients.

27
00:02:06,720 --> 00:02:11,320
This question has actually been with us for a long time. When we had applets,

28
00:02:11,320 --> 00:02:17,350
originally developed by Java, the idea was that the client,

29
00:02:17,350 --> 00:02:24,090
that is the web browser, would, download functionality as needed.

30
00:02:24,090 --> 00:02:28,190
Be able to try to provide as much functionality close to the user as possible.

31
00:02:28,190 --> 00:02:33,610
This is sometimes called a fat client. The other extreme is to say, let's make

32
00:02:33,610 --> 00:02:39,150
the client as thin as possible. That is, all it is is really a user interface.

33
00:02:39,150 --> 00:02:45,640
Now we've gone back and forth between fat and thin clients. AJAX is a way of

34
00:02:45,640 --> 00:02:49,930
being able to reduce the overhead of client to server messaging,

35
00:02:51,050 --> 00:02:55,660
in particular client to server when a whole page is being re-written.

36
00:02:55,660 --> 00:03:00,460
AJAX is a way of making local changes to web pages without necessarily having

37
00:03:00,460 --> 00:03:06,080
full server interaction. Another class of questions has to do with the different

38
00:03:06,080 --> 00:03:11,310
kinds of devices that are now parts of distributed systems. Sometimes those

39
00:03:11,310 --> 00:03:17,610
devices are relatively constrained by their power consumption and batteries,

40
00:03:17,610 --> 00:03:23,160
which might mean that their memories and their chips are going to be smaller or

41
00:03:23,160 --> 00:03:27,390
slower. In which case the overall device is going to

42
00:03:27,390 --> 00:03:32,150
be somewhat limited that might be a reason to have a thinner client on it.

43
00:03:32,150 --> 00:03:35,910
Related to that is the whole question of mobility. If part of the application,

44
00:03:35,910 --> 00:03:39,400
if the client side of the application is moving around, what happens if

45
00:03:39,400 --> 00:03:43,300
it all suddenly goes in a tunnel, right, and you can't reach it? Your system man

46
00:03:43,300 --> 00:03:46,680
has to be more robust with dealing with that kind of uncertainty.
