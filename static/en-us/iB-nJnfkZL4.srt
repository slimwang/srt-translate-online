1
00:00:00,170 --> 00:00:02,530
The solution to this problem is to

2
00:00:02,530 --> 00:00:05,610
construct what's called a Spanning Tree, which is

3
00:00:05,610 --> 00:00:09,410
a loop-free typology that covers every node in

4
00:00:09,410 --> 00:00:12,310
the graph. The set of edges, shown in

5
00:00:12,310 --> 00:00:15,030
blue, constitutes what's known as a Spanning

6
00:00:15,030 --> 00:00:17,720
Tree. The collection of edges in the blue

7
00:00:17,720 --> 00:00:21,740
typology covers every node in the underlying physical

8
00:00:21,740 --> 00:00:25,990
typology. And yet, there are no loops in

9
00:00:25,990 --> 00:00:29,690
the blue topology. Now, instead of flooding a

10
00:00:29,690 --> 00:00:33,670
frame, a switch in this topology would simply forward

11
00:00:33,670 --> 00:00:36,670
packets along the spanning tree. So for example,

12
00:00:36,670 --> 00:00:40,120
this switch would only send a frame along the

13
00:00:40,120 --> 00:00:42,670
port corresponding to the blue edge. And would

14
00:00:42,670 --> 00:00:45,200
not forward the frame out any edges that were

15
00:00:45,200 --> 00:00:48,560
not part of the spanning tree. Other switches

16
00:00:48,560 --> 00:00:51,250
that receive the frame, would flood in the same

17
00:00:51,250 --> 00:00:53,940
fashion, along all edges that were part of the

18
00:00:53,940 --> 00:00:57,580
spanning tree. While omitting edges that were not members of

19
00:00:57,580 --> 00:00:59,430
the spanning tree. Let's take a look at how

20
00:00:59,430 --> 00:01:03,210
to construct the spanning tree. First the collection of switches

21
00:01:03,210 --> 00:01:05,930
must elect a root, since every tree must have

22
00:01:05,930 --> 00:01:09,660
a root. Typically this is the switch with the smallest

23
00:01:09,660 --> 00:01:12,050
ID. In this case, the switch at the top

24
00:01:12,050 --> 00:01:16,640
of the topology is the root. Then each switch must

25
00:01:16,640 --> 00:01:19,120
decide which of its links to include in the

26
00:01:19,120 --> 00:01:24,110
spanning tree. And it excludes any link if that link

27
00:01:24,110 --> 00:01:27,310
is determined to be not on the shortest path

28
00:01:27,310 --> 00:01:31,510
to the root. For example, lets consider the switch in

29
00:01:31,510 --> 00:01:34,720
the lower right. It has three lengths, this length

30
00:01:34,720 --> 00:01:37,090
takes it on a path that's three hops from the

31
00:01:37,090 --> 00:01:39,590
root. This length takes it on a path that's two

32
00:01:39,590 --> 00:01:41,640
hops to the root, and this length takes it on

33
00:01:41,640 --> 00:01:44,250
a path, that's one hop to the root. Any link

34
00:01:44,250 --> 00:01:47,190
that's not on a shortest path to the route is excluded

35
00:01:47,190 --> 00:01:49,820
and any link that's on a shortest path on a route

36
00:01:49,820 --> 00:01:54,020
is included. Simarly here, this edge is on a path that's

37
00:01:54,020 --> 00:01:56,290
one hop away from the route and this edge is

38
00:01:56,290 --> 00:01:58,650
on a path that's two hops away. So this node will

39
00:01:58,650 --> 00:02:02,200
include this link from the spanning tree. Now, each switch repeats

40
00:02:02,200 --> 00:02:06,610
this process to exclude links from the underlying topology. And ultimately,

41
00:02:06,610 --> 00:02:09,729
this yields a [UNKNOWN] topology that looks like the

42
00:02:09,729 --> 00:02:12,790
blue Graph. And of course there is an issue which

43
00:02:12,790 --> 00:02:14,460
is how do we determine the root in the

44
00:02:14,460 --> 00:02:18,160
first place? Well initially, every node think it's the root.

45
00:02:18,160 --> 00:02:21,870
And the switches run an election process to determine

46
00:02:21,870 --> 00:02:25,280
which switch has the smallest ID. And if they learn

47
00:02:25,280 --> 00:02:28,630
of a switch with a smaller ID, they update their

48
00:02:28,630 --> 00:02:31,670
view of the root, and they compute the distance to

49
00:02:31,670 --> 00:02:34,750
the new root. Whenever a switch updates its view of the root,

50
00:02:34,750 --> 00:02:39,090
it also determines how far it is from that root. So that when

51
00:02:39,090 --> 00:02:44,740
other neighboring nodes receive those updates. They can determine their distance

52
00:02:44,740 --> 00:02:49,440
to the new root simply by adding one to any message that they receive.
