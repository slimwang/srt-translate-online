1
00:00:00,000 --> 00:00:03,759
So what we're really doing here is simply running a scan over the input.

2
00:00:03,759 --> 00:00:10,290
So the input to the scan is a 1 for each 0 bit and a 0 for each 1 bit,

3
00:00:10,290 --> 00:00:14,533
and that will give us the scatter addresses for the 0 half of the split.

4
00:00:14,533 --> 00:00:17,928
So we're going to scatter this element to an output 0, this element to 1,

5
00:00:17,928 --> 00:00:20,600
this element to 2, and this element to 3.

6
00:00:20,600 --> 00:00:22,808
Notice that the last element of the scan,

7
00:00:22,808 --> 00:00:25,970
with a little bit of extra math because it ends with a 0 element here,

8
00:00:25,970 --> 00:00:29,670
tells us how many 0 bits there are total in the input.

9
00:00:29,670 --> 00:00:32,801
In this case there are four--1, 2, 3, 4.

10
00:00:33,385 --> 00:00:36,455
Then we can begin with that value to do a second scan

11
00:00:36,455 --> 00:00:41,351
to compute the scatter addresses for the other half of the split, for the 1 bits.

12
00:00:41,351 --> 00:00:43,583
There are a number of interesting ways to make this faster,

13
00:00:43,583 --> 00:00:49,266
and the most common one is to reduce the total number of passes by taking multiple bits per pass.

14
00:00:49,266 --> 00:00:54,396
Four bits per pass and a resulting 16-way split, instead of our 2-way split here,

15
00:00:54,396 --> 00:00:56,231
appears to be fairly common.

16
00:00:56,231 --> 00:01:01,509
Overall, radix sort is a fairly brute force algorithm, but it's both simple and fast.

17
00:01:01,509 --> 00:01:08,081
Recent GPUs can run radix sort on 32-bit keys at a rate of over a billion keys sorted per second.
