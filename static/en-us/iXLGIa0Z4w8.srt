1
00:00:00,000 --> 00:00:03,000
Okay, so a 100 test cases passed in that tiny amount of times it took us to run.

2
00:00:03,000 --> 00:00:07,000
And so one thing we could conclude is that since a 100 of test passed over read all

3
00:00:07,000 --> 00:00:10,000
that the logic is solid but it turns out that this conclusion isn't really warranted.

4
00:00:10,000 --> 00:00:12,000
Let's see if we can get the program to tell us why.

5
00:00:12,000 --> 00:00:17,000
So I'm going to do here is print out a value indicating the number of bytes that was actually

6
00:00:17,000 --> 00:00:20,000
read by the raw read system call and then we'll run our testing loop.

7
00:00:20,000 --> 00:00:25,000
And what happens is every single time we called read, it read the full size of the file.

8
00:00:25,000 --> 00:00:30,000
So our splay.py here--we can see that's 3121 bytes and the actual Unix read system call

9
00:00:30,000 --> 00:00:32,000
always read that many bytes every time we call it.

10
00:00:32,000 --> 00:00:37,000
So it ends being the case even though it's illegal for read to return less bytes than we asked it to read

11
00:00:37,000 --> 00:00:40,000
is not actually doing this, so what we're going to need to do in order to test our logic

12
00:00:40,000 --> 00:00:44,000
in any meaningful way is make it do that, and so the question is how to do that.

13
00:00:44,000 --> 00:00:48,000
Well, one way to do that would be to go hack Mac OS so that sometimes doesn't read

14
00:00:48,000 --> 00:00:52,000
all the file bytes that we asked and that is not very fun, so we're going to do something a little easier.

15
00:00:52,000 --> 00:00:55,000
We're going to insert faults ourselves by calling a read fault injection file.

16
00:00:55,000 --> 00:01:00,000
By calling a read function with fault injection is the function I already wrote here, so what you can see

17
00:01:00,000 --> 00:01:04,000
that read with fault injection does is it has exactly the same interface as read

18
00:01:04,000 --> 00:01:07,000
just a different filename, but what it's going to do is instead of reading the nbytes

19
00:01:07,000 --> 00:01:11,000
that we asked for it's going to set the number of bytes to read to be a random number

20
00:01:11,000 --> 00:01:15,000
between 1 and the number of fault bytes inclusive.

21
00:01:15,000 --> 00:01:19,000
And so the +1 there means that instead of going from 0 to the number of bytes minus 1,

22
00:01:19,000 --> 00:01:23,000
we;re going to test the range from 1 to the number of bytes, and that's what we want to do.

23
00:01:23,000 --> 00:01:26,000
We don't want to return 0 because that indicates an end of file condition.

24
00:01:26,000 --> 00:01:28,000
So now we're ready to run some tests.
