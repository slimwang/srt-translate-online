1
00:00:00,150 --> 00:00:03,505
So let's try a slightly harder algorithm called list ranking.

2
00:00:03,505 --> 00:00:07,274
In list ranking, each node has the index of its successor in the list,

3
00:00:07,274 --> 00:00:09,280
and we know the first element in the output.

4
00:00:09,280 --> 00:00:11,685
What we want to be able to do is put the nodes in order.

5
00:00:11,685 --> 00:00:15,359
This has a number of uses, and in our lab, we've used it to decompress data

6
00:00:15,359 --> 00:00:18,358
that's been compressed with B sub 2, so let's take a look at an example.

7
00:00:18,358 --> 00:00:20,298
As an example we've got 10 nodes here.

8
00:00:20,298 --> 00:00:22,925
We know that the output is going to begin with node 0

9
00:00:22,925 --> 00:00:27,602
and the successor to node 0, so one farther in the chain is node 5.

10
00:00:27,602 --> 00:00:30,032
The successor to node 5 is node 2.

11
00:00:30,032 --> 00:00:32,503
The successor to node 2 is node 7 and so on.

12
00:00:32,503 --> 00:00:36,673
So this is our input--this array of 5, 6, 7, 9, 2, 3, 0, 1.

13
00:00:36,673 --> 00:00:38,960
What's our output going to be?

14
00:00:38,960 --> 00:00:43,576
It's going to be the chain 0, 5, 2, 7, 4, 9, 1, 6, 3, 8.

15
00:00:43,576 --> 00:00:46,082
So here's our input, and here's the output.

16
00:00:46,082 --> 00:00:48,554
Now, you can note that the array is actually circular,

17
00:00:48,554 --> 00:00:51,055
so it's necessary to actually designate the starting point,

18
00:00:51,055 --> 00:00:54,390
and in this case we're saying that node number 0 is the starting point.

19
00:00:54,390 --> 00:00:57,428
Of course, a serial processor could do this N steps.

20
00:00:57,428 --> 00:01:00,924
The question is, how can we make it work with parallel hardware

21
00:01:00,924 --> 00:01:03,468
with a smaller number of steps?
