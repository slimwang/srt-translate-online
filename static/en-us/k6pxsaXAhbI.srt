1
00:00:00,430 --> 00:00:02,920
Okay, I mentioned earlier that
getting everything up-to-date would

2
00:00:02,920 --> 00:00:05,320
require merging the local and
remote branches.

3
00:00:05,320 --> 00:00:06,870
How does this work in practice?

4
00:00:06,870 --> 00:00:09,166
As it turns out,
when you have a remote set-up,

5
00:00:09,166 --> 00:00:11,690
Git stores local copies of
all the remote branches.

6
00:00:11,690 --> 00:00:14,770
These will each contain the state of the
remote branch as of the last time you

7
00:00:14,770 --> 00:00:16,230
pushed or pulled the branch.

8
00:00:16,230 --> 00:00:19,275
Let's look at how this would play out
over the lifetime of a repository.

9
00:00:19,275 --> 00:00:23,100
We'll consider a repository that got
created on GitHub with a readme, and

10
00:00:23,100 --> 00:00:24,100
then got cloned.

11
00:00:24,100 --> 00:00:27,330
Remember that cloning sets up
a remote for you called origin.

12
00:00:27,330 --> 00:00:30,210
We've already seen that when you clone
a repository, you get a local branch

13
00:00:30,210 --> 00:00:33,520
called master, that points to
the same commit as the remote one.

14
00:00:33,520 --> 00:00:36,620
But what you haven't seen yet
is that you also get a local copy of

15
00:00:36,620 --> 00:00:39,500
the last known position of
that branch on the remote.

16
00:00:39,500 --> 00:00:42,310
The name of that branch includes
the name of the remote, origin,

17
00:00:42,310 --> 00:00:44,100
since you can have
multiple remotes set up,

18
00:00:44,100 --> 00:00:45,910
as well as the name of
the branch on the remote.

19
00:00:45,910 --> 00:00:48,810
In this case, master,
which is to be separated by a slash.

20
00:00:48,810 --> 00:00:51,650
So in this case, it'll be origin/master.

21
00:00:51,650 --> 00:00:53,840
And since we've just had
an interaction with the remote,

22
00:00:53,840 --> 00:00:57,240
it's currently in the same location
as the actual remote version.

23
00:00:57,240 --> 00:00:58,530
Let's consider what happens when you

24
00:00:58,530 --> 00:01:00,950
make commit on the master
branch locally.

25
00:01:00,950 --> 00:01:03,500
As usual,
when you make a commit on a branch,

26
00:01:03,500 --> 00:01:05,830
that branch will get updated
to point to the new commit.

27
00:01:05,830 --> 00:01:08,710
But, neither the local
origin/master branch, nor

28
00:01:08,710 --> 00:01:11,300
the actual master branch
on the GitHub repository,

29
00:01:11,300 --> 00:01:14,270
will get updated because you haven't
communicated that you want to do that.

30
00:01:14,270 --> 00:01:17,960
However, if you push the master branch,
the local origin/master branch and

31
00:01:17,960 --> 00:01:21,330
the remote GitHub branch will
get updated with the new commit.

32
00:01:21,330 --> 00:01:24,590
Similarly, if this branch were
to get updated on GitHub and

33
00:01:24,590 --> 00:01:28,230
then we pulled, both of these would
get updated with the new commit.

34
00:01:28,230 --> 00:01:30,560
Let's go back to thinking about what
happens if you've got different

35
00:01:30,560 --> 00:01:35,400
changes on each repository, with one
change locally and another remote.

36
00:01:35,400 --> 00:01:39,220
It turns out that you can update just
the local copy of the remote branch,

37
00:01:39,220 --> 00:01:43,310
leaving your actual local version alone
by running the command git fetch.

38
00:01:43,310 --> 00:01:46,340
In cases like this, where there
are potentially conflicting changes,

39
00:01:46,340 --> 00:01:49,830
using git fetch to update the local
copy of the remote branch can be nice,

40
00:01:49,830 --> 00:01:53,590
so that you can use git log and git diff
to see what changes were introduced,

41
00:01:53,590 --> 00:01:56,430
both on the local and
remote repositories.

42
00:01:56,430 --> 00:01:58,000
This way,
if you're going to be offline for

43
00:01:58,000 --> 00:02:00,050
a while,
say if you're about to get on a plane,

44
00:02:00,050 --> 00:02:02,670
you can update your local copy of
the remote branch before you leave.

45
00:02:02,670 --> 00:02:05,250
And then you'll have access to any
updates that have been made to

46
00:02:05,250 --> 00:02:08,240
the remote since you last synced up,
while you were offline.

47
00:02:08,240 --> 00:02:11,008
But you don't have to act on
combining those commits right away.

48
00:02:11,008 --> 00:02:12,630
Speaking of combining changes,

49
00:02:12,630 --> 00:02:16,470
now that you have the commit from GitHub
on your local repository, it's now

50
00:02:16,470 --> 00:02:20,680
possible to incorporate them into
your master branch, using git merge.

51
00:02:20,680 --> 00:02:23,880
It turns out that this is exactly
what happens when you do a git pull.

52
00:02:23,880 --> 00:02:26,300
First, the remote branch gets fetched,

53
00:02:26,300 --> 00:02:28,790
updating the local copy
of the remote branch.

54
00:02:28,790 --> 00:02:32,230
Then, that branch gets
merged into the local one.

55
00:02:32,230 --> 00:02:34,530
To put it more concretely, in this case,

56
00:02:34,530 --> 00:02:39,210
fetching updates origin/master with the
contents of GitHub's master branch, and

57
00:02:39,210 --> 00:02:42,250
then origin/master is
merged into master.

58
00:02:42,250 --> 00:02:46,990
So git pull is the same as git
fetch followed by git merge.

59
00:02:46,990 --> 00:02:50,590
Now Caroline will demonstrate doing this
process on the recipes repository on

60
00:02:50,590 --> 00:02:51,240
the command line.

61
00:02:52,460 --> 00:02:57,310
>> I can update the local copies by
running git fetch origin, which will

62
00:02:57,310 --> 00:03:01,420
update all of the local copies of
every branch for the origin remote.

63
00:03:01,420 --> 00:03:06,400
I can inspect the local copies by
running git log origin/master.

64
00:03:06,400 --> 00:03:10,300
Or git diff origin/master master.

65
00:03:10,300 --> 00:03:11,800
But before I do that,

66
00:03:11,800 --> 00:03:14,820
I want you to predict what you'll
see if you run these commands.

67
00:03:14,820 --> 00:03:17,620
You can also run the commands
yourself to see if you're right, but

68
00:03:17,620 --> 00:03:20,220
it can help to think about
this before trying it.

69
00:03:20,220 --> 00:03:22,540
I'd like you to predict
the output of git log and

70
00:03:22,540 --> 00:03:26,310
git status both before and
after you run git fetch.

71
00:03:26,310 --> 00:03:29,960
If you run git log origin/master
before you run git fetch,

72
00:03:29,960 --> 00:03:32,380
which of these commits do
you think will be shown?

73
00:03:32,380 --> 00:03:34,670
Larry's commit, adding the chili recipe?

74
00:03:34,670 --> 00:03:36,800
Your commit, adding a new spice?

75
00:03:36,800 --> 00:03:38,130
Sarah's commit, removing cumin?

76
00:03:38,130 --> 00:03:40,300
Check all that apply.

77
00:03:40,300 --> 00:03:43,480
Similarly, check all the commits
you think will be shown after you

78
00:03:43,480 --> 00:03:45,040
run git fetch.

79
00:03:45,040 --> 00:03:47,640
When you run git status
on the master branch,

80
00:03:47,640 --> 00:03:51,180
Git will let you know whether your local
master contains any commits that are not

81
00:03:51,180 --> 00:03:54,410
reachable from origin/master or
vice versa.

82
00:03:54,410 --> 00:03:56,960
If you run git status
before you run git fetch,

83
00:03:56,960 --> 00:04:01,500
will it say that your local master is
one commit ahead of origin/master?

84
00:04:01,500 --> 00:04:04,200
One commit behind origin/master?

85
00:04:04,200 --> 00:04:06,210
Will it say that your
branch is up-to-date,

86
00:04:06,210 --> 00:04:08,920
meaning the two branches
point to the same commit?

87
00:04:08,920 --> 00:04:11,120
Or will it say the two
branches are out of sync,

88
00:04:11,120 --> 00:04:14,070
meaning each has a commit
not present in the other?

89
00:04:14,070 --> 00:04:17,230
Similarly, after you run git fetch,
what will git status say?
