1
00:00:00,230 --> 00:00:04,676
It turns out there are many ways to specify a square. 1 solution with triangles

2
00:00:04,676 --> 00:00:09,168
is a bit brute force. What you do is you create 2 triangles independent of each

3
00:00:09,168 --> 00:00:14,311
other. So these four lines of code give you a triangle that goes from index 0,

4
00:00:14,311 --> 00:00:19,654
1, and 2. These are the first 3 points, right here. And then you have a second

5
00:00:19,654 --> 00:00:24,950
triangle 3, 4, and 5. That are these 3 points. Now you'll notice there's

6
00:00:24,950 --> 00:00:29,880
duplication of points 2 and 3 and 5 and 0 and we can save space and time by

7
00:00:29,880 --> 00:00:35,022
merging these. A more compact and efficient way to draw the square is to define

8
00:00:35,022 --> 00:00:40,088
the 4 vertices needed and then define 2 triangle faces reusing these points. So

9
00:00:40,088 --> 00:00:45,483
for example, here we're reusing these points, 0 and 2 for this first triangle,

10
00:00:45,483 --> 00:00:50,418
and for this second triangle. It turns out that the 3JS library happens to

11
00:00:50,418 --> 00:00:54,984
support a 4 point face. So you could just use one face like this. That said, the

12
00:00:54,984 --> 00:00:58,937
way that web GL, DirectX, and other low level APIs work is to define only

13
00:00:58,937 --> 00:01:03,371
triangles. When the 3JS library defines a 4 sided polygon this way, the

14
00:01:03,371 --> 00:01:07,932
quadrilateral is rendered by 2 triangles being sent to the GPU. If you happen to

15
00:01:07,932 --> 00:01:12,222
solve this exercise by drawing a single quadrilateral, that's great that you

16
00:01:12,222 --> 00:01:16,782
read the 3JS documentation, bonus points for you. But it's worth your while to

17
00:01:16,782 --> 00:01:19,713
try this exercise again using just triangles.
