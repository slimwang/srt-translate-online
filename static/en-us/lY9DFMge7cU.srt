1
00:00:00,130 --> 00:00:01,150
Are here are four.

2
00:00:01,150 --> 00:00:02,969
First off is associations.

3
00:00:02,969 --> 00:00:06,795
Associations are everywhere inside the OOA diagrams, but

4
00:00:06,795 --> 00:00:09,800
object-oriented programming languages don't have associations.

5
00:00:09,800 --> 00:00:13,490
It's going to be up to you to decide during object-oriented design how you're

6
00:00:13,490 --> 00:00:15,660
going to implement those associations.

7
00:00:15,660 --> 00:00:17,980
Related is the question of aggregation.

8
00:00:17,980 --> 00:00:20,990
We know in our diagrams that various,

9
00:00:20,990 --> 00:00:23,460
the diamond is used to represent aggregations.

10
00:00:23,460 --> 00:00:27,280
You will have some choices at programming time as to how you are going to

11
00:00:27,280 --> 00:00:31,110
represent what programming language futures you are going to use to represent

12
00:00:31,110 --> 00:00:35,100
those aggregations, and during O-design you have to make those decisions.

13
00:00:35,100 --> 00:00:36,940
Third off, is invariants, so

14
00:00:36,940 --> 00:00:40,150
in your OCL you may have to express certain invariants.

15
00:00:40,150 --> 00:00:44,380
And it's up to you in your program to enforce those invariants.

16
00:00:44,380 --> 00:00:48,360
That is, make sure that it's always the case that the invariant holds.

17
00:00:48,360 --> 00:00:52,130
During OOD design, you have to come up with some strategy whereby those

18
00:00:52,130 --> 00:00:54,300
invariants are going to be maintained.

19
00:00:54,300 --> 00:00:55,850
And finally with StateCharts,

20
00:00:55,850 --> 00:00:59,100
OO programming languages don't have state machines.

21
00:00:59,100 --> 00:01:04,099
And as we seen, the state charts that are produced during OOA can be complex, so

22
00:01:04,099 --> 00:01:07,660
you will need some kind of approach in your OOD for

23
00:01:07,660 --> 00:01:09,590
how you're going to deal with that complexity.
