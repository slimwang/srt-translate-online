1
00:00:00,020 --> 00:00:01,660
To see how see how a DNS cache

2
00:00:01,660 --> 00:00:05,850
poisoning attack works, consider a network where a stub

3
00:00:05,850 --> 00:00:10,440
resolver issues a query to its recursive resolver, and

4
00:00:10,440 --> 00:00:13,720
the recursive resolver in turn sends that A record

5
00:00:13,720 --> 00:00:16,309
query to the start of authority for that

6
00:00:16,309 --> 00:00:19,480
domain. Now, in an ideal world, the authoritative name

7
00:00:19,480 --> 00:00:22,320
server for that domain Would reply with the correct

8
00:00:22,320 --> 00:00:25,460
IP address. If an attacker guesses that a recursive

9
00:00:25,460 --> 00:00:28,080
resolver might eventually need to issue

10
00:00:28,080 --> 00:00:31,070
a query for say, www.google.com. The attacker

11
00:00:31,070 --> 00:00:36,260
can simply reply with multiple, specially crafted.

12
00:00:36,260 --> 00:00:39,900
Replies each with different id's. Although this

13
00:00:39,900 --> 00:00:45,960
query has some query id, the attacker doesn't need to see that query because

14
00:00:45,960 --> 00:00:50,520
the attacker can simply flood the recursive resolver with a bunch of bogus

15
00:00:50,520 --> 00:00:56,870
replies and one of them, in this case the response with id3 will match. As

16
00:00:56,870 --> 00:00:59,610
long as this bogus response reaches the recursive

17
00:00:59,610 --> 00:01:04,129
resolver before the legitimate response does, the recursive

18
00:01:04,129 --> 00:01:06,710
resolver will accept this bogus message. And

19
00:01:06,710 --> 00:01:09,700
worse, it caches the bogus message. And DNS,

20
00:01:09,700 --> 00:01:13,400
unfortunately, has no way to expunge. A message

21
00:01:13,400 --> 00:01:15,550
once it has been cached. So now this

22
00:01:15,550 --> 00:01:20,310
reclusive resolver will continue to send bogus

23
00:01:20,310 --> 00:01:23,530
A record responses for any query for

24
00:01:23,530 --> 00:01:27,020
this particular domain name until that entry

25
00:01:27,020 --> 00:01:30,050
expires from the cache. Now there's several defenses

26
00:01:30,050 --> 00:01:34,900
against DNS cache poisoning, and we've already seen one, which is the query ID.

27
00:01:34,900 --> 00:01:40,910
But of course, the query ID can be guessed. The next defense is to randomize

28
00:01:40,910 --> 00:01:46,190
the ID so rather than having a resolver, end queries where

29
00:01:46,190 --> 00:01:51,080
the ID's increment in sequence, the resolver can pick a random

30
00:01:51,080 --> 00:01:56,490
ID. This makes the ID tougher to guess, but still,

31
00:01:56,490 --> 00:02:01,600
the query ID is only 16 bits, which still makes it possible for

32
00:02:01,600 --> 00:02:06,330
an attacker to flood the recursive resolver with many

33
00:02:06,330 --> 00:02:08,620
possible responses. And, it's likely that, with

34
00:02:08,620 --> 00:02:12,050
relatively few responses, One of these bogus

35
00:02:12,050 --> 00:02:18,160
responses will match the ID for the real query. Due to the birthday paradox,

36
00:02:18,160 --> 00:02:21,500
the success probability for achieving a collision

37
00:02:21,500 --> 00:02:25,595
between the query ID of the query

38
00:02:25,595 --> 00:02:28,840
,and of the response actually only requires

39
00:02:28,840 --> 00:02:31,700
sending hundreds of replies, not a complete 32,000.

40
00:02:31,700 --> 00:02:36,410
Due to the birthday paradox, The probability that

41
00:02:36,410 --> 00:02:39,810
such an attack will succeed, using only a

42
00:02:39,810 --> 00:02:42,520
few hundreds of replies, is relatively close to

43
00:02:42,520 --> 00:02:44,770
one. The attacker does not need to send

44
00:02:44,770 --> 00:02:47,780
replies with all two to the 16th possible

45
00:02:47,780 --> 00:02:51,000
IDs. The success of a DNS cache poisoning

46
00:02:51,000 --> 00:02:53,420
attack not only depends on the ability to

47
00:02:53,420 --> 00:02:57,230
reply to a query with a correct matching ID,

48
00:02:57,230 --> 00:03:03,050
but it also depends on winning this race. That is, the attacker must reply

49
00:03:03,050 --> 00:03:05,810
to that query before the legitimate authoritative

50
00:03:05,810 --> 00:03:08,180
name server replies. If the bad guy, or

51
00:03:08,180 --> 00:03:10,910
the attacker, loses the race, then the

52
00:03:10,910 --> 00:03:14,090
attacker has to wait for that correct cached

53
00:03:14,090 --> 00:03:18,460
entry to expire, before trying again, however

54
00:03:18,460 --> 00:03:22,770
the attacker can generate his own DNS query.

55
00:03:22,770 --> 00:03:30,180
For example, he could query one.google.com, two.google.com and so forth. Each

56
00:03:30,180 --> 00:03:36,950
one of these bogus queries will generate a new race. And eventually the attacker

57
00:03:36,950 --> 00:03:41,430
will win one of these races for an A record query. But who

58
00:03:41,430 --> 00:03:44,384
cares? Nobody necessarily cares to own

59
00:03:44,384 --> 00:03:47,780
one.google.com, or google.com. The attacker really wants

60
00:03:47,780 --> 00:03:50,450
to own the entire zone. Well the trick

61
00:03:50,450 --> 00:03:53,990
here is that instead of just simply responding

62
00:03:53,990 --> 00:03:57,080
with A records in the bogus replies. The

63
00:03:57,080 --> 00:04:01,950
attacker can also respond with NS records for

64
00:04:01,950 --> 00:04:05,510
the entire zone of google.com. So by creating

65
00:04:05,510 --> 00:04:07,660
one of these races, using an A record

66
00:04:07,660 --> 00:04:10,320
query, and then responding not only with the

67
00:04:10,320 --> 00:04:13,340
A record response, but also with the authoritative

68
00:04:13,340 --> 00:04:18,750
of the NS record,for the entire zone. The attacker can in fact own the entire

69
00:04:18,750 --> 00:04:25,690
zone. This idea of generating extreme of A record queries to generate a bunch of

70
00:04:25,690 --> 00:04:31,960
races and then stuffing the A record responses for each of these with a bogus

71
00:04:31,960 --> 00:04:35,220
authoritative NS record for the entire zone. Is

72
00:04:35,220 --> 00:04:38,740
what's called the Kaminsky Attack, after Dan Kaminsky,

73
00:04:38,740 --> 00:04:41,410
who discovered the attack. The defenses of

74
00:04:41,410 --> 00:04:44,610
picking a query ID and randomizing the ID,

75
00:04:44,610 --> 00:04:47,280
help, but remember the randomization is only 16

76
00:04:47,280 --> 00:04:49,880
bits, so let's think about other possible defenses.
