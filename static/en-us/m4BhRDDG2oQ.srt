1
00:00:00,000 --> 00:00:04,000
What I'm going to do now is go over a fixed-sized queue data structure

2
00:00:04,000 --> 00:00:06,000
that's going to serve as a running example for some of this lecture,

3
00:00:06,000 --> 00:00:10,000
and we're also going to keep using for a couple of our exercises for the next several units.

4
00:00:10,000 --> 00:00:15,000
And the way this data structure works is it supports an enqueue operation,

5
00:00:15,000 --> 00:00:20,000
a dequeue operation, an enqueue elements to dequeue and FIFO order.

6
00:00:20,000 --> 00:00:26,000
The FIFO is first in first out--so if we enqueue 7 and then also 8, the first thing that we dequeue.

7
00:00:26,000 --> 00:00:31,000
will be 7 then 8, and if we try to dequeue again--if we try do dequeue an element

8
00:00:31,000 --> 00:00:34,000
with an empty queue, we're going to get some sort of an error.

9
00:00:34,000 --> 00:00:36,000
Okay, so that's all fixed-sized queue. Now let's look at some code.

10
00:00:36,000 --> 00:00:41,000
So in the implementation site--what we have here is a Python object so it's called queue

11
00:00:41,000 --> 00:00:45,000
and the constructor for that object is going to set up the data structure because structure

12
00:00:45,000 --> 00:00:51,000
for that object is going to take a size max argument--that's going to determine the largest

13
00:00:51,000 --> 00:00:55,000
number of objects that can be stored in our queue and it's going to set up the data structure.

14
00:00:55,000 --> 00:00:59,000
So first it's going to make sure that size max is greater than zero.

15
00:00:59,000 --> 00:01:04,000
It's going to save a temporary copy of that, initialize some head and tail pointers,

16
00:01:04,000 --> 00:01:08,000
a size variable which stores the number of objects currently in the queue,

17
00:01:08,000 --> 00:01:11,000
and finally we need to reserve some space for the queque elements themselves.

18
00:01:11,000 --> 00:01:16,000
But you can see here is we're allocating a Python array and so one implementation option

19
00:01:16,000 --> 00:01:20,000
for a queue in Python will be to just use a Python list and that will be basically trivial.

20
00:01:20,000 --> 00:01:24,000
Python list already is pretty much need of a support enqueue and dequeue operations

21
00:01:24,000 --> 00:01:28,000
and the problem with the Python list is they're dynamically allocated,

22
00:01:28,000 --> 00:01:31,000
they are dynamically tight and that makes them not very fast.

23
00:01:31,000 --> 00:01:35,000
And so by allocating a fixed-sized storage region of statically tight memory,

24
00:01:35,000 --> 00:01:39,000
where the "i" here means that our queue is only going to be able to store integers

25
00:01:39,000 --> 00:01:42,000
we can avoid some of Python's dynamic checks that makes the queue slow

26
00:01:42,000 --> 00:01:48,000
and so in some cases, a queue based on a Python list is perfectly fast but on the other hand

27
00:01:48,000 --> 00:01:53,000
in some benchmarking that I did, this statically sized, statically tight queue

28
00:01:53,000 --> 00:01:57,000
is more than 10 times faster than a queue based on a Python list.

29
00:01:57,000 --> 00:02:01,000
So the first method that queue supports is the empty method and this simply returns true if

30
00:02:01,000 --> 00:02:09,000
self.size equals zero--so of course the empty queue is the one that currently contains zero elements.

31
00:02:09,000 --> 00:02:15,000
Very similarly, the full queue method returns true if the current size of the queue

32
00:02:15,000 --> 00:02:18,000
is equal to the maximum size of the queue.

33
00:02:18,000 --> 00:02:20,000
So now let's look at a couple of routines that are slightly trickier.

34
00:02:20,000 --> 00:02:22,000
The enqueue method is going to take an argument x.

35
00:02:22,000 --> 00:02:25,000
X is an integer that we want to try add to the queue.

36
00:02:25,000 --> 00:02:29,000
The first thing this method is going to do is check if the current size of the queue

37
00:02:29,000 --> 00:02:33,000
is the maximum size--if so the queue is full, then we're going to return false.

38
00:02:33,000 --> 00:02:37,000
If we passed this test, of course, the queue is not full and we have room.

39
00:02:37,000 --> 00:02:41,000
So the next thing we're going to do is put the argument data item

40
00:02:41,000 --> 00:02:44,000
into the queue at the location pointed to by the tail.

41
00:02:44,000 --> 00:02:47,000
And so now let me show you a little bit of about how our representation works.

42
00:02:47,000 --> 00:02:52,000
So for demonstration purposes, we're going to look at a 3-element queue

43
00:02:52,000 --> 00:02:59,000
and initially it's going to have a head and a tail according to the first queue element--

44
00:02:59,000 --> 00:03:04,000
that is the queue element with index zero and also its size is going to be zero.

45
00:03:04,000 --> 00:03:08,000
To enqueue an item, the first check will be useful--no it's not because its size is zero.

46
00:03:08,000 --> 00:03:13,000
We go ahead and put the item--let's say it's the number 7 in the queue element pointed to by the tail

47
00:03:13,000 --> 00:03:17,000
We're never going to increment the tail, and now the last thing we have to do to enqueue

48
00:03:17,000 --> 00:03:22,000
an element is increase the size of the queue to be 1.

49
00:03:22,000 --> 00:03:24,000
Okay, now let's go look back at the code.

50
00:03:24,000 --> 00:03:27,000
Seeing here at the code, we can see that we put the element in the queue,

51
00:03:27,000 --> 00:03:31,000
we increased the size of the queue, we moved the tail to point to the next element

52
00:03:31,000 --> 00:03:36,000
and the only thing that's left the only bit of logic that's sort of tricky here is

53
00:03:36,000 --> 00:03:40,000
if the tail of the queue point passed the end of the queue--that is to say if it's equal to the max

54
00:03:40,000 --> 00:03:44,000
and so remember what the zero index array, the maximum way in is going to be one pass

55
00:03:44,000 --> 00:03:48,000
at the end of the queue--we're going to reset the tail to point at the zero element of the queue--

56
00:03:48,000 --> 00:03:50,000
that is to stay at the beginning.

57
00:03:50,000 --> 00:03:54,000
Now the dequeue operation is very similar--first if the size of the queue is zero then the queue

58
00:03:54,000 --> 00:03:58,000
is empty, we're not going to be able to dequeue an item.

59
00:03:58,000 --> 00:04:02,000
And so what we're going to do in this case is return Python to none type.

60
00:04:02,000 --> 00:04:07,000
So none of the special data types supported by Python we can often use to indicate

61
00:04:07,000 --> 00:04:10,000
that we don't have anything--we don't have any actual value.

62
00:04:10,000 --> 00:04:13,000
So if we pass that test, then there is something to return.

63
00:04:13,000 --> 00:04:17,000
So what we're going to do is store the item from the head of the queue in a temporary variable.

64
00:04:17,000 --> 00:04:21,000
So x is going to get 7. We're going to decrement the size of the queue.

65
00:04:21,000 --> 00:04:27,000
We're going to move the tail point out to point the next element and then using logic very similar

66
00:04:27,000 --> 00:04:32,000
to the tail pointer in the enqueue function, we're going to wrap the head pointer around

67
00:04:32,000 --> 00:04:34,000
if it's gone passed the end of the queue.

68
00:04:34,000 --> 00:04:38,000
So let's go back to the drawing and look out and see how this plays out.

69
00:04:38,000 --> 00:04:43,000
So we're going to return 7, decrement the size, and make the head element

70
00:04:43,000 --> 00:04:48,000
point to the next element of the list, and we're not going to bother erasing the 7 we returned

71
00:04:48,000 --> 00:04:52,000
but we're going to have to make sure that our queue logic never returns this dead element.

72
00:04:52,000 --> 99:59:59,999
Oh! So let's take a very quick quiz just to make sure that you understood all of that.
