1
00:00:00,000 --> 00:00:02,720
And the answer to that question of course is a little more subtle.

2
00:00:02,720 --> 00:00:05,130
So there's two reasons why that doesn't work.

3
00:00:05,130 --> 00:00:09,350
The first reason is a very formalistic one. The RAM can only handle integers.

4
00:00:09,350 --> 00:00:13,710
Or at least the RAM cannot handle numbers with an arbitrary precision

5
00:00:13,710 --> 00:00:17,930
because having an arbitrary precision is exactly the same thing as having

6
00:00:17,930 --> 00:00:21,550
an infinite amount of values available for each variable.

7
00:00:21,550 --> 00:00:23,630
And we said that the RAM doesn't support that.

8
00:00:23,630 --> 00:00:25,960
And actually your computer also doesn't fully support that.

9
00:00:25,960 --> 00:00:30,980
So you might be working with numbers such as 1.2345 or so,

10
00:00:30,980 --> 00:00:34,270
but these numbers are always rounded numbers.

11
00:00:34,270 --> 00:00:37,360
So also your computer does not have arbitrary precision.

12
00:00:37,360 --> 00:00:40,900
It' s pretty well thought out normally how your computer handle such numbers

13
00:00:40,900 --> 00:00:43,410
which is why we normally don't notice but in general

14
00:00:43,410 --> 00:00:46,240
there's no arbitrary precision for your computer also.

15
00:00:46,240 --> 00:00:51,520
Secondly, the table size wouldn't change. So we're not allowed to do this.

16
00:00:51,520 --> 00:00:57,090
But let's say we're allowed to do this and then represent all of the values in the table exactly.

17
00:00:57,090 --> 00:01:03,130
Then, the table size itself wouldn't change because you start out with a table that has

18
00:01:03,130 --> 00:01:07,260
1, 2, 3, 4 and so on until you get to the columns.

19
00:01:07,260 --> 00:01:10,660
And now in your new table, you would just have the same amount of columns

20
00:01:10,660 --> 00:01:17,500
only the columns would be labeled 1/v, 2/v, 3/v, 4/v until you get to 1.

21
00:01:17,500 --> 00:01:19,430
The third and the fourth are not valid reasons.

22
00:01:19,430 --> 00:01:23,160
Just because then P would be NP is no counterargument against this.

23
00:01:23,160 --> 00:01:26,850
And of course, as I've just shown you, that is also not true.

24
00:01:26,850 --> 00:01:31,180
But asking this question here leads us to something else.

25
00:01:31,180 --> 00:01:35,770
What if we were to divide all values by some number, which I'm going to specify to you,

26
00:01:35,770 --> 00:01:38,370
and then round it down.

27
00:01:38,370 --> 00:01:40,810
By rounding, we do two things.

28
00:01:40,810 --> 00:01:44,560
So by rounding, we would make numbers that the RAM can handle.

29
00:01:44,560 --> 00:01:48,380
And also in the case of rounding, the table size would change.

30
00:01:48,380 --> 00:01:56,340
So let's say you had a table that looked like 0.5, 1, 1.5, 2, 2.5, 3, and so on.

31
00:01:56,340 --> 00:02:00,030
Then, you could always put two columns together. So these two.

32
00:02:00,030 --> 00:02:03,440
Except for the first one. That would become 0. But all the others you can put together.

33
00:02:03,440 --> 00:02:06,990
So those two would become column 1. Those two would become column 2.

34
00:02:06,990 --> 00:02:10,750
If you have 3.5 here, they would become column 3 and so on.

35
00:02:10,750 --> 00:02:15,070
So you would be able to scale down the table but of course the whole thing comes at a price.

36
00:02:15,070 --> 00:02:19,000
Because scaling down the table means that you put two columns together

37
00:02:19,000 --> 00:02:23,490
only taking the minimum of it and therefore possibly arrive at a suboptimal solution.

38
00:02:23,490 --> 00:02:28,520
Because certain objects where one object has a slightly higher value than another one

39
00:02:28,520 --> 00:02:31,430
become indistinguishable using this technique.

40
00:02:31,430 --> 00:02:36,310
Well, we're not going to divide by V. We're going to divide by some factor.

41
00:02:36,310 --> 00:02:43,450
Dividing all values by a certain factor is a good idea but we have to round and this gives us an error.

42
00:02:43,450 --> 00:02:49,170
Now, if you take a close look at this, you can almost see the approximation algorithm

43
00:02:49,170 --> 00:02:53,900
emerging here because what happens when this factor here becomes very large?

44
00:02:53,900 --> 00:02:57,500
Well, then we scale down the table that we build a lot.

45
00:02:57,500 --> 00:03:00,770
So here we have n and here we have v.

46
00:03:00,770 --> 00:03:04,290
If we divide all values by some large factor and of course we have to round,

47
00:03:04,290 --> 00:03:09,280
then this table here becomes very small but of course our error also increases.

48
00:03:09,280 --> 00:03:14,410
And if this factor here is very small, which means we almost keep all of the original table,

49
00:03:14,410 --> 00:03:21,280
well then our running time is still very large but the error that we make is potentially smaller.

50
00:03:21,280 --> 00:03:24,850
So this is exactly where the time and quality tradeoff will come from.

51
00:03:24,850 --> 99:59:59,999
Let's now have a look at that in more detail.
