1
00:00:00,250 --> 00:00:03,400
David, which of these topics do you
think are applied to using a script?

2
00:00:03,400 --> 00:00:06,350
>> So I chose four of the seven
as applied to using a script.

3
00:00:06,350 --> 00:00:10,850
So for problem reduction, we saw earlier
that the script breaks down the overall

4
00:00:10,850 --> 00:00:14,710
scene into smaller scenes, and
even further into smaller actions.

5
00:00:14,710 --> 00:00:16,910
What that means is that when
we're executing the script,

6
00:00:16,910 --> 00:00:19,660
and it kind of gets caught
somewhere we can break it down and

7
00:00:19,660 --> 00:00:22,420
see exactly where the script got caught.

8
00:00:22,420 --> 00:00:25,400
So we can see exactly where
an expectation was violated.

9
00:00:25,400 --> 00:00:28,270
Classification we actually already
discussed because classification

10
00:00:28,270 --> 00:00:32,299
can help us identify which script to
execute in a given situation based on

11
00:00:32,299 --> 00:00:33,580
what we see.

12
00:00:33,580 --> 00:00:35,880
So if we walk into a restaurant and
see a hostess for

13
00:00:35,880 --> 00:00:39,780
example we can classify that as
a specific kind of restaurant and

14
00:00:39,780 --> 00:00:41,870
launch the script that
goes along with it.

15
00:00:41,870 --> 00:00:43,150
Although it would take a bigger jump,

16
00:00:43,150 --> 00:00:46,010
I can also imagine putting
a script in terms of formal logic.

17
00:00:46,010 --> 00:00:49,440
Especially because we discussed before,
that a script can be considered a plan

18
00:00:49,440 --> 00:00:53,210
that has already been executed once, and
can be transferred to new situations.

19
00:00:53,210 --> 00:00:55,880
So if we're discussing plans
in the form of formal logic,

20
00:00:55,880 --> 00:00:58,820
we may also be able to put scripts
in those same kind of terms.

21
00:00:58,820 --> 00:01:02,490
In terms of what they're asserting is
true for a given state of the script.

22
00:01:02,490 --> 00:01:04,849
So if we could put plans in
the form of formal logic,

23
00:01:04,849 --> 00:01:07,950
we can also imagine rewriting our
script in the form of formal logic.

24
00:01:07,950 --> 00:01:11,250
That would give us a script in
terms of what different elements

25
00:01:11,250 --> 00:01:14,270
of the script assert about the state
of the world at different points of

26
00:01:14,270 --> 00:01:15,820
the script's execution.

27
00:01:15,820 --> 00:01:18,940
Finally, we can also see understanding
applying pretty directly to scripts

28
00:01:18,940 --> 00:01:23,670
because it helps us disambiguate
similar events in different situations.

29
00:01:23,670 --> 00:01:26,480
So to go with Ashok's example about
receiving the bill right when you sit

30
00:01:26,480 --> 00:01:31,040
down at the table, understanding talks
about how we can disambiguate that event

31
00:01:31,040 --> 00:01:33,680
based on what else has
happened before and after.

32
00:01:33,680 --> 00:01:36,710
I didn't see the other three as
being as applicable to scripts for

33
00:01:36,710 --> 00:01:38,500
a couple different reasons.

34
00:01:38,500 --> 00:01:40,570
For Generate & Test and
Means-Ends Analysis,

35
00:01:40,570 --> 00:01:42,230
these are problem solving methods.

36
00:01:42,230 --> 00:01:46,320
And as we talked about with planning in
the previous exercise, scripts are often

37
00:01:46,320 --> 00:01:48,850
used when we already have a solution and
we simply need to execute it.

38
00:01:48,850 --> 00:01:52,860
Case-Based Reasoning keeps things at the
level of individual cases that can be

39
00:01:52,860 --> 00:01:54,650
adapted to our current problem.

40
00:01:54,650 --> 00:01:58,090
Where as scripts serve as
an abstraction over a number of cases.

41
00:01:58,090 --> 00:02:01,140
So I don't really see case-based
reasoning applying as much here either.

42
00:02:01,140 --> 00:02:01,920
>> This is good, David.

43
00:02:01,920 --> 00:02:03,570
Thank you for sharing this.

44
00:02:03,570 --> 00:02:06,947
Note that Generate and & Test, and
Case-Based Reasoning might be able to

45
00:02:06,947 --> 00:02:08,889
have the ability to
use scripts after all.

46
00:02:08,889 --> 00:02:12,150
So one can imagine a situation where
there are a large number of scripts

47
00:02:12,150 --> 00:02:15,522
available and the robot has to decide
which of the scripts should I use for

48
00:02:15,522 --> 00:02:16,750
a particular situation.

49
00:02:16,750 --> 00:02:20,245
And may not be able to classify
the situation dashed into scripts and

50
00:02:20,245 --> 00:02:23,859
with that case the robot will pick
a script, generate it, try it out,

51
00:02:23,859 --> 00:02:26,504
see if it works,
if it does not pick another one.

52
00:02:26,504 --> 00:02:30,858
Also Case-Based Reasoning is currently
the application of scripts in the sense

53
00:02:30,858 --> 00:02:32,843
that both Case-Based Reasoning and

54
00:02:32,843 --> 00:02:36,580
script-based reasoning
are extremely memory intensive.

55
00:02:36,580 --> 00:02:39,650
What both of them are saying is
that memory often supplies most of

56
00:02:39,650 --> 00:02:40,760
the answer.

57
00:02:40,760 --> 00:02:43,120
Like we said earlier when we were
discussing Case-Based Reasoning,

58
00:02:43,120 --> 00:02:45,910
we don't think as much
as we think we do.

59
00:02:45,910 --> 00:02:48,360
Most of the time memory
gives us the answer.

60
00:02:48,360 --> 00:02:51,510
The difference, of course, like David
pointed out is, that cases defer to

61
00:02:51,510 --> 00:02:54,680
instances whereas scripts
are abstractions of the instances.
