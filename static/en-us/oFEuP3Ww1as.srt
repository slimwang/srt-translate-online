1
00:00:00,000 --> 00:00:02,000
Here's my approach to the problem.

2
00:00:02,000 --> 00:00:04,000
Here's our axes.

3
00:00:04,000 --> 00:00:07,000
Here's my function, f(x).

4
00:00:07,000 --> 00:00:10,000
Now, the problem is I'm given some value of y,

5
00:00:10,000 --> 00:00:16,000
and I want to find the value of x that corresponds to that such that f(x) equals y.

6
00:00:16,000 --> 00:00:20,000
The strategy we had before was to just start at the 0 point

7
00:00:20,000 --> 00:00:26,000
and go out step-by-step-by-step, but that's going to be slow if there are lots of steps.

8
00:00:26,000 --> 00:00:29,000
My approach is going to be--first I'm going to take one step forward,

9
00:00:29,000 --> 00:00:36,000
and then if the value of f(x) is still below y, then I'm going to double how far out I go.

10
00:00:36,000 --> 00:00:41,000
I'm going to keep on doubling how far out I go and checking--

11
00:00:41,000 --> 00:00:48,000
1, 2, 4, 8, 16 units out--until I've got bounds.

12
00:00:48,000 --> 00:00:54,000
Here I have this value that I doubled. F(x) was less than the desired y.

13
00:00:54,000 --> 00:00:59,000
When I went all the way out to here, f(x was greater than the desired y.

14
00:00:59,000 --> 00:01:03,000
I know that the right x has to be somewhere within this range.

15
00:01:03,000 --> 00:01:08,000
That gives me the low and the high that I get by doubling.

16
00:01:08,000 --> 00:01:15,000
Now I'm going to find the exact value or close to exact value within low and high by halfing.

17
00:01:15,000 --> 00:01:17,000
First doubling, now halfing.

18
00:01:17,000 --> 00:01:22,000
I look in here, say what's halfway between low and high. That's at this point.

19
00:01:22,000 --> 00:01:24,000
F(x) there is still too high.

20
00:01:24,000 --> 00:01:27,000
Now I know I must be somewhere in this half.

21
00:01:27,000 --> 00:01:31,000
I go halfway there. That's still too high.

22
00:01:31,000 --> 00:01:37,000
Now I know I must be in this half, and I keep on doing that process

23
00:01:37,000 --> 00:01:40,000
until I zero in on the right value.

24
00:01:40,000 --> 00:01:43,000
That's the strategy. Now let's see what the code looks like.

25
00:01:43,000 --> 00:01:45,000
Here's my function "inverse."

26
00:01:45,000 --> 00:01:51,000
I'm going to have my smallest delta--the smallest amount that I move out--be 1/1024.

27
00:01:51,000 --> 00:01:55,000
That's going to get me to within three significant digits.

28
00:01:55,000 --> 00:01:58,000
I'm going to build up this f inverse function.

29
00:01:58,000 --> 00:02:00,000
I was given y = f(x).

30
00:02:00,000 --> 00:02:04,000
I'm going to build up x = f_1(y).

31
00:02:04,000 --> 00:02:07,000
I do that first by finding the low and high bounds--

32
00:02:07,000 --> 00:02:12,000
it's got to be somewhere in there--and then doing a binary search

33
00:02:12,000 --> 00:02:17,000
somewhere in between that low and high to find a value that's accurate to within delta.

34
00:02:17,000 --> 00:02:19,000
Here's how I find the bounds.

35
00:02:19,000 --> 00:02:24,000
I start off, and I just keep on doubling until I find a value that's high enough.

36
00:02:24,000 --> 00:02:28,000
What I keep on doing is narrowing down the interval between low and high

37
00:02:28,000 --> 00:02:31,000
until they come out to be the same--until the interval has disappeared.

38
00:02:31,000 --> 00:02:36,000
If I'm too high, then I change the low. Otherwise, I change the high value.

39
00:02:36,000 --> 00:02:38,000
That makes the interval smaller and smaller.

40
00:02:38,000 --> 00:02:41,000
If I hit it exactly, I go ahead and return the x value.

41
00:02:41,000 --> 00:02:46,000
If I haven't hit it exactly, then I know I'm somewhere in between the two,

42
00:02:46,000 --> 00:02:48,000
and I just check out which one to do.

43
00:02:48,000 --> 00:02:51,000
Now, I've defined some functions here to help me test what I've done.

44
00:02:51,000 --> 00:02:56,000
I've defined the square and the 10^x functions.

45
00:02:56,000 --> 00:02:58,000
Now I define those inverses.

46
00:02:58,000 --> 00:03:02,000
The logarithm is just the inverse of the power of 10,

47
00:03:02,000 --> 00:03:06,000
and sgrt is the inverse of square using the function I defined.

48
00:03:06,000 --> 00:03:09,000
Can also do a cube root as the inverse of the cube function.

49
00:03:09,000 --> 00:03:12,000
Then I'm defining some tests.

50
00:03:12,000 --> 00:03:17,000
For these sets of numbers, I'm going to test these functions--sqrt, log10, and cuberoot,

51
00:03:17,000 --> 00:03:22,000
and I'm going to test them against the correct mathematical functions as defined by Python.

52
00:03:22,000 --> 00:03:25,000
These are the ones I've defined with inverse.

53
00:03:25,000 --> 00:03:30,000
These are the ones Python defines, and here's my individual test.

54
00:03:30,000 --> 00:03:32,000
Here's what I get when I run the tests.

55
00:03:32,000 --> 00:03:35,000
For each of the numbers and for each of the functions here is the result I compute

56
00:03:35,000 --> 00:03:37,000
with my inverse function.

57
00:03:37,000 --> 00:03:43,000
Here is the actual results, and you can see the differences are all in the 0.001 or less.

58
00:03:43,000 --> 00:03:50,000
That's true for small numbers, and it's true even as we go up to bigger numbers like 10^8.
