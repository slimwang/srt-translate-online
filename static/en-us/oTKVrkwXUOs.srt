1
00:00:00,012 --> 00:00:04,770
>> Tiled allows an artist to do multiple layers per map tile, meaning that we

2
00:00:04,770 --> 00:00:09,475
can potentially do 10 draws per on screen tile. Sadly, our bounding view

3
00:00:09,475 --> 00:00:14,389
rectangle won't help us fix this in performance terms, so we have to employ a

4
00:00:14,389 --> 00:00:19,802
new technique. Now, as you've played Grids, you'll notice that their environment

5
00:00:19,802 --> 00:00:24,722
is mostly static. Which means that we could, hypothetically, add export time

6
00:00:24,722 --> 00:00:29,686
from the map editor. Actually composite our entire map into a single image. At

7
00:00:29,686 --> 00:00:34,537
run time, this means instead of doing 200 to 2000 draw calls, we could only do

8
00:00:34,537 --> 00:00:38,563
one. So this is not necessarily ideal, having a single large image representing

9
00:00:38,563 --> 00:00:42,375
the background of our map. Because of the fact that that's actually a pretty big

10
00:00:42,375 --> 00:00:46,061
image and it would take time to download that off the internet. Now, we can't

11
00:00:46,061 --> 00:00:49,836
deny the fact that this would help on the client's side for rendering. So, it'd

12
00:00:49,836 --> 00:00:53,553
be nice to find a way to mix both these techniques together so that we can

13
00:00:53,553 --> 00:00:57,747
improve rendering and reduce download time. Thankfully, Canvas provides a

14
00:00:57,747 --> 00:01:02,169
technique called Off Screen Canvas Rendering that allows a single canvas to be

15
00:01:02,169 --> 00:01:06,564
used an, an image element for future draws. So let's say we create an off-screen

16
00:01:06,564 --> 00:01:11,043
canvas. And in this canvas, we draw lots of little happy figures. Or happy

17
00:01:11,043 --> 00:01:15,921
trees. Later, when we'd like to actually draw this to our main canvas. We simply

18
00:01:15,921 --> 00:01:20,596
draw each of the elements using the draw image API. Passing into it the canvas

19
00:01:20,596 --> 00:01:25,051
that we composited before. So, if it took 300 draw calls to composite this

20
00:01:25,051 --> 00:01:29,723
canvas, when we draw to our real image, it will only actually take one for each

21
00:01:29,723 --> 00:01:34,086
time we render it. So, instead of doing 1200 draw calls, we only have to do 4.

22
00:01:34,086 --> 00:01:38,130
Which I think we can all agree is a good thing. Now, in order to support off

23
00:01:38,130 --> 00:01:42,222
screen canvas, we need to keep track of a separate canvas for each tile that

24
00:01:42,222 --> 00:01:46,637
we're creating in our map. We've separated this functionality out into a canvas

25
00:01:46,637 --> 00:01:51,037
tile class. Now, the canvas tile class itself has some boundaries that we should

26
00:01:51,037 --> 00:01:56,129
talk. First, is its x and y value in world space? And its width and its height.

27
00:01:56,129 --> 00:01:59,688
Next, we actually have a handle to the canvas object itself. Or more

28
00:01:59,688 --> 00:02:03,675
specifically, a handle to the canvas DOM object. As well as the handle to the

29
00:02:03,675 --> 00:02:07,755
context for the canvas. The create element for this process should be given a

30
00:02:07,755 --> 00:02:11,991
width and a height. Besides setting up some initial values, the create function

31
00:02:11,991 --> 00:02:16,086
should actually go through and create a brand new canvas element in the DOM and

32
00:02:16,086 --> 00:02:20,336
set its width and height accordingly to the past in values. From there, we cache

33
00:02:20,336 --> 00:02:24,057
that handle, and actually grab a handle to the 2D graphics context for the

34
00:02:24,057 --> 00:02:25,319
canvas we just created.
