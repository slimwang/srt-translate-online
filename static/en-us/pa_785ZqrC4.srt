1
00:00:00,310 --> 00:00:03,560
Hello and welcome to this lesson on multi-threaded programming.

2
00:00:03,560 --> 00:00:06,030
This lesson begins with a brief review of parallel

3
00:00:06,030 --> 00:00:09,120
programming in general and moves on to discuss multi-threaded

4
00:00:09,120 --> 00:00:13,460
programming in particular. It uses the POSIX threads library as

5
00:00:13,460 --> 00:00:16,280
the conical example, though the same principles apply to

6
00:00:16,280 --> 00:00:20,020
most all threads libraries. To motivate parallel programming, consider

7
00:00:20,020 --> 00:00:22,900
the following task. You're given a set of webpages,

8
00:00:22,900 --> 00:00:25,520
some of which link to each other. We'll draw this

9
00:00:25,520 --> 00:00:29,090
using a standard abstraction of a directed graph, where outgoing

10
00:00:29,090 --> 00:00:32,960
edges represent links. So webpage A here contains a link

11
00:00:32,960 --> 00:00:36,020
to webpage B. And our goal is to figure out,

12
00:00:36,020 --> 00:00:39,960
how many links our website, say U, has pointing to it.

13
00:00:39,960 --> 00:00:41,860
This is something that a search engine might do to

14
00:00:41,860 --> 00:00:44,600
help figure out how popular a website is. Now, there's no

15
00:00:44,600 --> 00:00:47,160
way to know whether another web page has a link

16
00:00:47,160 --> 00:00:50,390
to our web page in it without looking at it. So,

17
00:00:50,390 --> 00:00:52,110
in one way or another, we're going to need to read

18
00:00:52,110 --> 00:00:54,380
all of the web pages in our collection. And if we

19
00:00:54,380 --> 00:00:56,200
try to do this with a single processor, this could

20
00:00:56,200 --> 00:00:59,855
take a long time. First, I have to read webpage A

21
00:00:59,855 --> 00:01:04,069
then webpage B, etc. Thankfully, this task is highly paralyzable.

22
00:01:04,069 --> 00:01:07,790
That is, there is nothing about my processing of A ie,

23
00:01:07,790 --> 00:01:11,270
counting how many links it has to website U that

24
00:01:11,270 --> 00:01:15,790
affects how I'm going to process website B or website C. So,

25
00:01:15,790 --> 00:01:18,160
I can easily divide up the web pages among, say, three

26
00:01:18,160 --> 00:01:22,310
CPUs. Let's get these over here to CPU one, these to CPU

27
00:01:22,310 --> 00:01:26,190
two, and these to CPU 3. Now, we can let each CUP

28
00:01:26,190 --> 00:01:29,225
count up, in its sub group, how many links it has to

29
00:01:29,225 --> 00:01:31,560
you, and then we can just add these units up to

30
00:01:31,560 --> 00:01:34,580
get our final answer. Returning to our time graph, we see that

31
00:01:34,580 --> 00:01:38,320
with three CPUs, we only need 1 3rd of the time, potentially,

32
00:01:38,320 --> 00:01:41,500
with n CPUs we would only need 1 nth of the time.

33
00:01:41,500 --> 00:01:43,120
It's important to realize that we're doing the same

34
00:01:43,120 --> 00:01:46,210
amount of work here. Suppose that in our original thread,

35
00:01:46,210 --> 00:01:49,820
we first process the website assigned to CPU one, then

36
00:01:49,820 --> 00:01:52,700
those assigned to CPU two, and then those assigned to

37
00:01:52,700 --> 00:01:57,350
CPU three. Well, in parallel programming, we've cut this one

38
00:01:57,350 --> 00:02:01,300
long strand of computation into three shorter strands and arranged

39
00:02:01,300 --> 00:02:04,870
them in parallel by giving them to three seperate CPUs.

40
00:02:04,870 --> 00:02:07,760
This, of course, is the ideal case for parallel programming.

41
00:02:07,760 --> 00:02:09,470
Now of course, in real life, we don't always

42
00:02:09,470 --> 00:02:12,160
get as many processors as we want, they aren't

43
00:02:12,160 --> 00:02:14,790
always available. And given that our application will likely

44
00:02:14,790 --> 00:02:16,770
be running on the same machine as others, we

45
00:02:16,770 --> 00:02:18,670
don't know exactly how many processors we will have

46
00:02:18,670 --> 00:02:21,030
access to. But by expressing our algorithim in this

47
00:02:21,030 --> 00:02:23,100
way, we can take advantage of the processors that

48
00:02:23,100 --> 00:02:25,710
we do have and thus make our algorithms run faster.
