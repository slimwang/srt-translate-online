1
00:00:00,301 --> 00:00:02,414
In this homework assignment, we asked you to

2
00:00:02,414 --> 00:00:06,958
write a function called auto debug, which takes a

3
00:00:06,958 --> 00:00:12,319
test piece of code, a test list and a test interesting,

4
00:00:12,319 --> 00:00:15,904
which checks if the code is interesting in some way.

5
00:00:15,904 --> 00:00:18,548
What we really mean is if there is some kind

6
00:00:18,548 --> 00:00:21,435
of bug that we know is going to happen. So we

7
00:00:21,435 --> 00:00:24,305
have this test specifically to check for it. In this

8
00:00:24,305 --> 00:00:27,009
case, the test is interesting if it contains A plus B

9
00:00:27,009 --> 00:00:30,701
on the same line, and variable A and variable B

10
00:00:30,701 --> 00:00:33,597
before that line. So how do we go about doing this?

11
00:00:33,597 --> 00:00:36,424
Well, we just – we first take the actual test

12
00:00:36,424 --> 00:00:40,857
list and the interesting test itself and if test itself is

13
00:00:40,857 --> 00:00:43,164
not interesting, then we return none. Because if

14
00:00:43,164 --> 00:00:46,137
it’s not interesting, none of its subsets are going to

15
00:00:46,137 --> 00:00:48,980
be interesting either. Otherwise we continue on

16
00:00:48,980 --> 00:00:52,919
and we set a size and a current test, best size and

17
00:00:52,919 --> 00:00:55,560
best test to be the length of the current test and

18
00:00:55,560 --> 00:00:58,546
test itself. Because we know those are interesting

19
00:00:58,546 --> 00:01:00,761
since we didn’t return and we want to hopefully

20
00:01:00,761 --> 00:01:03,561
find a smaller subset, so that we can narrow down

21
00:01:03,592 --> 00:01:08,306
where we are and where the bug we care about

22
00:01:08,306 --> 00:01:12,219
actually is. So we run through all the subsets of

23
00:01:12,280 --> 00:01:14,524
test and I will go through how we implemented

24
00:01:14,524 --> 00:01:18,115
that in a second. And for every element smaller in

25
00:01:18,115 --> 00:01:21,808
all the possible subsets of the test list, we check if

26
00:01:21,822 --> 00:01:25,489
first of all the length of the subset is less than the

27
00:01:25,489 --> 00:01:29,094
current best size – the current size of the – of an

28
00:01:29,094 --> 00:01:32,815
interesting test list and that this element is also

29
00:01:32,815 --> 00:01:37,505
interesting. If it is, then we reset the new best test

30
00:01:37,551 --> 00:01:41,969
to be this smaller subset and the current best size

31
00:01:41,985 --> 00:01:45,086
to be equal to the length of this smaller subset.

32
00:01:45,086 --> 00:01:47,971
And we keep running through this until we find

33
00:01:47,971 --> 00:01:51,651
hopefully the smaller subset or a smallest subset.

34
00:01:51,651 --> 00:01:54,745
We might have two interesting subsets that are the

35
00:01:54,745 --> 00:01:57,858
same size, that’s possible. And then once we’re all

36
00:01:57,858 --> 00:02:00,559
done with checking through all possible subsets,

37
00:02:00,559 --> 00:02:03,471
we just return the best test. Now to get all the

38
00:02:03,471 --> 00:02:07,070
subsets, which is something called a power set, if

39
00:02:07,070 --> 00:02:09,652
you’re familiar with set theory, we run it through

40
00:02:09,652 --> 00:02:12,585
this other function called ‘all subsets’ that takes a

41
00:02:12,585 --> 00:02:17,828
list, sets an element called ‘power set’ or ‘P set’

42
00:02:17,828 --> 00:02:21,316
that is a list containing just the empty list, because

43
00:02:21,316 --> 00:02:23,615
the empty list is always a subset of everything

44
00:02:23,615 --> 00:02:26,088
because it’s nothing. And for every element in the

45
00:02:26,088 --> 00:02:30,291
list, we add two P set for all X that are currently

46
00:02:30,291 --> 00:02:33,757
in P set, that plus the element we’re talking about.

47
00:02:33,757 --> 00:02:36,769
And this is really something that you should

48
00:02:36,769 --> 00:02:40,857
probably play with and see how it acts, to really

49
00:02:40,857 --> 00:02:43,809
buy that this does what it says it does. It’s a really

50
00:02:43,809 --> 00:02:46,906
clever piece of code. And then we just return this.

51
00:02:46,906 --> 00:02:51,241
And this is just all the possible subsets, including

52
00:02:51,257 --> 00:02:55,065
the set itself. So what the all subsets method really

53
00:02:55,065 --> 00:03:00,069
does is it takes a list, let’s say list 1, 2, 3, and it

54
00:03:00,069 --> 00:03:04,852
returns all of the subsets of that list. So you would

55
00:03:04,852 --> 00:03:07,843
have the empty list and you would also have the

56
00:03:07,843 --> 00:03:11,850
subsets containing just one element and then all

57
00:03:11,850 --> 00:03:15,750
the subsets containing two elements or sub lists –

58
00:03:15,750 --> 00:03:18,961
I keep saying subsets; really these are lists and it’s

59
00:03:18,961 --> 00:03:23,394
not strictly the same thing, but we can treat them

60
00:03:23,394 --> 00:03:26,509
like that for now. And then all the subsets

61
00:03:26,509 --> 00:03:29,323
containing three elements, which is actually just

62
00:03:29,323 --> 00:03:32,811
the overarching list itself. And this is what the

63
00:03:32,811 --> 00:03:36,308
function of all subsets returns. Now to test this,

64
00:03:36,308 --> 00:03:39,663
we have a few test cases down here, and we

65
00:03:39,663 --> 00:03:43,023
already had the interesting test that we talked

66
00:03:43,023 --> 00:03:46,135
about earlier and we run test one through that and

67
00:03:46,135 --> 00:03:50,100
test one is this fragment of code up here.

68
00:03:50,100 --> 00:03:55,124
So variable X, variable Y, variable Z. X equals Y

69
00:03:55,124 --> 00:04:00,249
plus Z. Y equals Z and Z equals X plus X. So we

70
00:04:00,249 --> 00:04:03,160
run that through in – through auto debug and we

71
00:04:03,161 --> 00:04:06,365
should find that this is the smallest interesting

72
00:04:06,365 --> 00:04:09,642
fragment. And we see the first true statement,

73
00:04:09,642 --> 00:04:12,314
means that this is true. To find another interesting

74
00:04:12,314 --> 00:04:16,084
test, for this one, it’s just a list is interesting if it

75
00:04:16,084 --> 00:04:18,711
contains three numbers in strict sending order.

76
00:04:18,711 --> 00:04:21,348
And then we take some numbers here that we’ve

77
00:04:21,348 --> 00:04:24,553
generated somewhat randomly and we check auto

78
00:04:24,553 --> 00:04:27,825
debug against test two and interesting two.

79
00:04:27,825 --> 00:04:30,969
And just by hand-checking this, you should see

80
00:04:30,969 --> 00:04:34,856
that the length of the smallest interesting subset is

81
00:04:34,856 --> 00:04:37,268
three, which we can see; when it ran it, we got

82
00:04:37,268 --> 00:04:41,806
true, and indeed, if we check if the answer from

83
00:04:41,806 --> 00:04:44,155
this is itself interesting – if we run it back

84
00:04:44,155 --> 00:04:46,979
through interesting, we see that it is true.

85
00:04:46,979 --> 00:04:49,320
So our function for auto debugging or at least

86
00:04:49,320 --> 00:04:52,068
some auto debugging works fairly nicely.
