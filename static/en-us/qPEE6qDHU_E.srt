1
00:00:00,680 --> 00:00:02,420
So here's an example to explain why maybe

2
00:00:02,420 --> 00:00:04,630
the situation's not so bad after all. So let's

3
00:00:04,630 --> 00:00:06,480
look at a particular example. We've got our

4
00:00:06,480 --> 00:00:10,360
input space consisting of say, the first 10 integers.

5
00:00:10,360 --> 00:00:13,180
And our hypothesis space is, you take an

6
00:00:13,180 --> 00:00:15,850
input, and then you just return whether it's greater

7
00:00:15,850 --> 00:00:18,330
than or equal to some theta. So that's a

8
00:00:18,330 --> 00:00:21,760
parameter. And now, how big is the hypothesis space?

9
00:00:21,760 --> 00:00:23,450
>> What type is data?

10
00:00:23,450 --> 00:00:24,520
>> Let's say theta's a real number.

11
00:00:24,520 --> 00:00:26,660
>> Oh, so it's infinite. Infinite!

12
00:00:26,660 --> 00:00:29,910
>> Indeed it is. Now, on the other hand, what

13
00:00:29,910 --> 00:00:32,020
would you do to try to learn this? Can you use

14
00:00:32,020 --> 00:00:36,430
the algorithm that we talked about before to learn in this

15
00:00:36,430 --> 00:00:39,540
particular space? So, I guess what I'm asking is, is there

16
00:00:39,540 --> 00:00:42,310
a way you can sort of sneakily apply the ideas

17
00:00:42,310 --> 00:00:44,710
from before, now the ideas from before were that you actually

18
00:00:44,710 --> 00:00:47,680
keep track of all the hypotheses. And to keep the version

19
00:00:47,680 --> 00:00:51,340
space, and once you've seen enough examples that are randomly drawn,

20
00:00:51,340 --> 00:00:56,200
you would be able to know that you've epsilon-exhausted the version

21
00:00:56,200 --> 00:00:58,930
space, and then, ultimately, any hypothesis that's left is going to

22
00:00:58,930 --> 00:01:01,770
be okay. So, what could we possibly do to track all

23
00:01:01,770 --> 00:01:03,700
of these hypotheses? It's problematic, because

24
00:01:03,700 --> 00:01:05,410
there's an infinite number of them.

25
00:01:05,410 --> 00:01:07,490
>> Okay. I see where you're going with this. So when I

26
00:01:07,490 --> 00:01:09,050
asked you what type it was, you said it was a real

27
00:01:09,050 --> 00:01:13,260
number, but it would have been easier if it, theta weren't a

28
00:01:13,260 --> 00:01:16,390
real number, but were in fact, you know, a positive integer say,

29
00:01:16,390 --> 00:01:17,420
or a non-negative integer.

30
00:01:17,420 --> 00:01:20,060
>> That's true, though there's still an infinite number of those.

31
00:01:20,060 --> 00:01:22,590
>> True, but it doesn't matter because the size of

32
00:01:22,590 --> 00:01:25,361
X is, it's so finite. So any value of theta

33
00:01:25,361 --> 00:01:29,060
greater than ten for example It doesn't matter. It doesn't

34
00:01:29,060 --> 00:01:30,620
matter because it will always give you the same answer.

35
00:01:30,620 --> 00:01:33,175
>> Alright. So if we, what if we only track the

36
00:01:33,175 --> 00:01:39,300
non-negative integers 10 or below. This would be, what, it's finite.

37
00:01:41,150 --> 00:01:46,280
And it gives us the same answer, as if we had actually tracked the, the infinite

38
00:01:46,280 --> 00:01:49,330
hypothesis space. So there's kind of, well, I

39
00:01:49,330 --> 00:01:50,330
dunno, you had a, you had a good way

40
00:01:50,330 --> 00:01:51,550
of saying it before, do you want to say

41
00:01:51,550 --> 00:01:53,270
it again? What, what is the difference between

42
00:01:53,270 --> 00:01:55,300
kind of this hypothesis space that we're working

43
00:01:55,300 --> 00:01:58,440
with, and the hypothesis space as we defined it.

44
00:01:58,440 --> 00:02:02,740
>> So there's a there's a notion of syntactic hypothesis space which is

45
00:02:02,740 --> 00:02:03,950
all the things you could possibly

46
00:02:03,950 --> 00:02:06,490
write, and then there's the semantic hypothesis

47
00:02:06,490 --> 00:02:08,479
space which are the actual different

48
00:02:08,479 --> 00:02:10,680
functions that you are practically represented.

49
00:02:10,680 --> 00:02:11,820
>> Yeah, I like that, that, that you

50
00:02:11,820 --> 00:02:15,620
can make a distinction between semantically, say, finite

51
00:02:15,620 --> 00:02:18,940
hypothesis base and actually spec-, it specified syntactically

52
00:02:18,940 --> 00:02:21,620
infinitely. And you also have the example of

53
00:02:21,620 --> 00:02:24,930
of a decision tree. With discrete inputs as

54
00:02:24,930 --> 00:02:26,510
also being kind of like this. That we,

55
00:02:26,510 --> 00:02:28,140
you know, we, we generally think about only

56
00:02:28,140 --> 00:02:31,530
ones that split on a attribute once, but syntactically

57
00:02:31,530 --> 00:02:33,230
you could keep splitting on it. It just doesn't

58
00:02:33,230 --> 00:02:35,960
give you a semantically different tree. So, this is

59
00:02:35,960 --> 00:02:37,530
kind of at the heart of what we're going to

60
00:02:37,530 --> 00:02:40,300
be able to do to talk about how we can

61
00:02:40,300 --> 00:02:43,200
learn and if in an hypothesis space, more complicated

62
00:02:43,200 --> 00:02:45,870
ones than this example here. But at the same time,

63
00:02:45,870 --> 00:02:48,190
without having to track an infinite number of hypothesis,

64
00:02:48,190 --> 00:02:50,730
because there's just not that many, that are meaningfully different.

65
00:02:50,730 --> 00:02:51,430
>> I like that.
