1
00:00:00,000 --> 00:00:04,000
In this problem, we've been tasked with modifying code we built in lecture

2
00:00:04,000 --> 00:00:09,000
that simulates deterministic finite state machines to also simulate

3
00:00:09,000 --> 00:00:13,000
non-deterministic finite state machines, so as a quick review,

4
00:00:13,000 --> 00:00:16,000
what makes a non-deterministic finite state machine different

5
00:00:16,000 --> 00:00:18,000
than a deterministic one?

6
00:00:18,000 --> 00:00:21,000
One thing is that a non-deterministic state machine

7
00:00:21,000 --> 00:00:25,000
may have epsilon transitions, which means transitions

8
00:00:25,000 --> 00:00:28,000
that don't require any characters in the string

9
00:00:28,000 --> 00:00:31,000
and are taken automatically.

10
00:00:31,000 --> 00:00:34,000
The other difference is that a non-deterministic machine

11
00:00:34,000 --> 00:00:38,000
may have 2 output edges that correspond to the same letter,

12
00:00:38,000 --> 00:00:41,000
and this causes diverging states.

13
00:00:41,000 --> 00:00:44,000
Simulating a string on a machine,

14
00:00:44,000 --> 00:00:47,000
the machine can be in multiple states at the same time,

15
00:00:47,000 --> 00:00:51,000
and so that's really the key, what we're going to have to modify for this problem

16
00:00:51,000 --> 00:00:55,000
since we were told explicitly we do not have to worry about the epsilon transitions.

17
00:00:55,000 --> 00:00:58,000
The first thing we may want to go over is the notation

18
00:00:58,000 --> 00:01:01,000
in Python code for our machine.

19
00:01:01,000 --> 00:01:05,000
In the example, you were given a dictionary edges,

20
00:01:05,000 --> 00:01:09,000
so the keys in our dictionary indicates the state in our state machine,

21
00:01:09,000 --> 00:01:14,000
and the values are the other states to whom the key has an outgoing edge

22
00:01:14,000 --> 00:01:18,000
labeled with the second value in the tuple of the key.

23
00:01:18,000 --> 00:01:22,000
That may sound a bit confusing, so let's work through and draw a diagram

24
00:01:22,000 --> 00:01:25,000
for what this Python description represents.

25
00:01:25,000 --> 00:01:30,000
Let's say we always begin at state 1, which will hold true for the remainder of our examples.

26
00:01:30,000 --> 00:01:32,000
Here we begin at state 1.

27
00:01:32,000 --> 00:01:37,000
We then have 2 outgoing edges to states 2 and 3,

28
00:01:37,000 --> 00:01:39,000
and those are labeled with the letter a.

29
00:01:39,000 --> 00:01:43,000
From state 2, we have 1 outgoing edge to state 2

30
00:01:43,000 --> 00:01:45,000
labeled with the letter a.

31
00:01:45,000 --> 00:01:49,000
From state 3, we have 2 outgoing edges to 3 and 4

32
00:01:49,000 --> 00:01:52,000
labeled with the letter b, and from 4,

33
00:01:52,000 --> 00:01:56,000
we have 1 outgoing edge to state 5 labeled with the letter c.

34
00:01:56,000 --> 00:01:59,000
And lastly, we have our accepting states 2 and 5,

35
00:01:59,000 --> 00:02:04,000
so we'll use the notation of a double circle to indicate that it's an accepting state,

36
00:02:04,000 --> 00:02:08,000
and this is the finite state machine that this description represents.

37
00:02:08,000 --> 00:02:12,000
If you're a little rusty on your non-deterministic finite automata,

38
00:02:12,000 --> 00:02:16,000
let's go through an example string and see whether or not it's accepted.

39
00:02:16,000 --> 00:02:20,000
Let's say we have the string a, a, a.

40
00:02:20,000 --> 00:02:22,000
We start at state 1.

41
00:02:22,000 --> 00:02:26,000
From 1 we take the letter a to both 2 and 3.

42
00:02:26,000 --> 00:02:29,000
We're in two places at the same time.

43
00:02:29,000 --> 00:02:33,000
At 2, we take the letter a back to 2.

44
00:02:33,000 --> 00:02:38,000
At 3, there are no transitions for the letter a,

45
00:02:38,000 --> 00:02:44,000
so in this version of our simulation, this alternative dimension,

46
00:02:44,000 --> 00:02:47,000
however you want to think about it, the finite state machine

47
00:02:47,000 --> 00:02:49,000
has failed to accept the string.

48
00:02:49,000 --> 00:02:53,000
However, we still have the other version of the simulation.

49
00:02:53,000 --> 00:02:56,000
We take the last a back to 2,

50
00:02:56,000 --> 00:02:59,000
and from here we've succeeded,

51
00:02:59,000 --> 00:03:03,000
and by our definition of the non-determinism,

52
00:03:03,000 --> 00:03:09,000
if any path through this state machine results in an accepting state,

53
00:03:09,000 --> 00:03:13,000
then we say this machine accepts that string.

54
00:03:13,000 --> 00:03:15,000
Okay, let's do this once more.

55
00:03:15,000 --> 00:03:18,000
Here we have the string a, b, b, c.

56
00:03:18,000 --> 00:03:21,000
From a we go to 2 states, 2 and 3.

57
00:03:21,000 --> 00:03:23,000
Then we have the letter b.

58
00:03:23,000 --> 00:03:25,000
From state 2 there's nothing we can do.

59
00:03:25,000 --> 00:03:28,000
From state 3 we have 2 outgoing edges with b,

60
00:03:28,000 --> 00:03:31,000
so we're now at 3 and 4.

61
00:03:31,000 --> 00:03:34,000
Oh, and I forgot to include this last state transition, c,

62
00:03:34,000 --> 00:03:36,000
which will come up in a bit.

63
00:03:36,000 --> 00:03:39,000
From 3 we take another b to both 3 and 4,

64
00:03:39,000 --> 00:03:43,000
and from 4, there's nowhere to take this b to, so we've failed.

65
00:03:43,000 --> 00:03:45,000
And lastly we have a c.

66
00:03:45,000 --> 00:03:48,000
From state 3, there's nowhere to take this c,

67
00:03:48,000 --> 00:03:50,000
but from 4 we can take the c to 5,

68
00:03:50,000 --> 00:03:52,000
which is an accepting state.

69
00:03:52,000 --> 00:03:55,000
Now you hopefully feel pretty good with stepping through

70
00:03:55,000 --> 00:03:57,000
a non-deterministic finite state machine.

71
00:03:57,000 --> 00:04:01,000
Now we have to actually answer the question, and that is to simulate it.

72
00:04:01,000 --> 00:04:04,000
And what we're going to do is pretty much what we did by hand.

73
00:04:04,000 --> 00:04:06,000
We're going to do it recursively.

74
00:04:06,000 --> 00:04:08,000
We're going to start from the starting state,

75
00:04:08,000 --> 00:04:13,000
and we're going to take the first character in our string

76
00:04:13,000 --> 00:04:18,000
and recurse on this state that that edge leads to,

77
00:04:18,000 --> 00:04:22,000
so at 1 we're going to take the a and recurse onto 2

78
00:04:22,000 --> 00:04:26,000
with the rest of the string and onto 3 for the rest of the string.

79
00:04:26,000 --> 00:04:30,000
And if any of those recursions, those recursive calls,

80
00:04:30,000 --> 00:04:34,000
come back true, then we say beginning at state 1,

81
00:04:34,000 --> 00:04:38,000
we return true, and it's going to go all the way back up.

82
00:04:38,000 --> 00:04:40,000
Let's try writing that.

83
00:04:40,000 --> 00:04:44,000
Here we have our procedure, the non-deterministic finite state machine simulator--

84
00:04:44,000 --> 00:04:48,000
I know that's a mouthful--and we take in 4 parameters,

85
00:04:48,000 --> 00:04:51,000
the string on which we're simulating, the current state,

86
00:04:51,000 --> 00:04:55,000
the map of edges that represents the state machine,

87
00:04:55,000 --> 00:04:58,000
and lastly, a list of the accepting states.

88
00:04:58,000 --> 00:05:01,000
I mentioned before we're going to do this via recursion,

89
00:05:01,000 --> 00:05:04,000
and one of the first things you may want to think about when you're writing

90
00:05:04,000 --> 00:05:07,000
a recursive procedure is your base case.

91
00:05:07,000 --> 00:05:11,000
Our base case is going to happen when we have no more characters left in our string.

92
00:05:11,000 --> 00:05:14,000
So if I have no more characters, we're simply going to return whether or not

93
00:05:14,000 --> 00:05:17,000
we are currently in an accepting state,

94
00:05:17,000 --> 00:05:22,000
and thanks to the nice Python syntax, that translates almost exactly to the code.

95
00:05:22,000 --> 00:05:26,000
Otherwise we're going to look at the first character in our string.

96
00:05:26,000 --> 00:05:29,000
If the current state has an outgoing edge with a letter that's

97
00:05:29,000 --> 00:05:34,000
the first character in the string, we're going to do a recursive call for each edge.

98
00:05:34,000 --> 00:05:39,000
Here I've written the code that gets out the new state,

99
00:05:39,000 --> 00:05:41,000
and the last thing we need to decide is what to do with what

100
00:05:41,000 --> 00:05:43,000
the recursive call returns.

101
00:05:43,000 --> 00:05:47,000
And as I said earlier, we're going to return true

102
00:05:47,000 --> 00:05:50,000
if any of the recursive calls that we make return true.

103
00:05:50,000 --> 00:05:56,000
If we go through all of this mess, or if there wasn't an edge for the current letter

104
00:05:56,000 --> 00:05:59,000
at our present state, we're going to return false,

105
00:05:59,000 --> 99:59:59,999
and that's the code.
