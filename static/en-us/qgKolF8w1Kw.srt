1
00:00:00,000 --> 00:00:06,000
Another question on the forums asked about the the length of writing down a bunch of

2
00:00:06,000 --> 00:00:10,000
regular expression rules, or tokens, for a language.

3
00:00:10,000 --> 00:00:13,000
The basic question was something like, this seems to go on forever!

4
00:00:13,000 --> 00:00:17,000
I can imagine having to write down so many token definition rules

5
00:00:17,000 --> 00:00:20,000
that I would expire of boredom before we ever finished.

6
00:00:20,000 --> 00:00:23,000
Is that what happens in the real world? What's it like?

7
00:00:23,000 --> 00:00:27,000
My answer to this is to some degree, there's no silver bullet.

8
00:00:27,000 --> 00:00:31,000
There's no single easy way to encode structured information

9
00:00:31,000 --> 00:00:33,000
to bring order from chaos.

10
00:00:33,000 --> 00:00:40,000
But what I can tell you is that it is a totally surmountable task for real world languages.

11
00:00:40,000 --> 00:00:46,000
I've been associated with a lexer and a parser, a frontend for the C-programming language.

12
00:00:46,000 --> 00:00:50,000
To handle this C-programming language, which has a lot of gory details,

13
00:00:50,000 --> 00:00:54,000
our list of token definitions was 600 lines long.

14
00:00:54,000 --> 00:00:57,000
That might seem like a lot if you're writing it out all at once,

15
00:00:57,000 --> 00:01:01,000
but in the grand scheme of things, a normal program like the Firefox web browser

16
00:01:01,000 --> 00:01:04,000
is multiple millions of lines long.

17
00:01:04,000 --> 00:01:07,000
So this list of regular expressions, this list of token definitions,

18
00:01:07,000 --> 00:01:12,000
is actually a very miniscule part of the entire software engineering effort.

19
00:01:12,000 --> 00:01:18,000
I was also involved in the creation of a lexer and parser, an interpreter for Java--

20
00:01:18,000 --> 00:01:24,000
Java 1.1 at the time, and our list of tokens, our token definition file was 200 lines long.

21
00:01:24,000 --> 00:01:28,000
Java was more regular than C in that regard, didn't require the lexer act,

22
00:01:28,000 --> 00:01:30,000
which you can ask me about at some later point.

23
00:01:30,000 --> 00:01:32,000
200 lines is even more reasonable.

24
00:01:32,000 --> 00:01:37,000
Finally, I think in one of the videos at some point, I mentioned in a particular Tetris game

25
00:01:37,000 --> 00:01:41,000
that I had the pleasure of working on, and there was a piece definition language

26
00:01:41,000 --> 00:01:45,000
that let me use the planner pentominoes instead of the normal 4-length tetris pieces.

27
00:01:45,000 --> 00:01:50,000
There the piece definition reader was more like 90 lines long,

28
00:01:50,000 --> 00:01:54,000
which is seeming even smaller and more attractible.

29
00:01:54,000 --> 00:01:58,000
But the way you really want to think about this is more like, say reasoning by analogy.

30
00:01:58,000 --> 00:02:03,000
Is it a lot of work to build a road? Is it a lot of work to build a sewer system?

31
00:02:03,000 --> 00:02:06,000
Is it a lot of work to paint a beautiful picture?

32
00:02:06,000 --> 00:02:11,000
Yes, but you do the work once, and then you advertise the cost for everyone

33
00:02:11,000 --> 00:02:15,000
who gets the chance to enjoy that construction.

34
00:02:15,000 --> 00:02:20,000
Yes, it takes a long time to pave a road, but after that, many people can drive over it.

35
00:02:20,000 --> 00:02:24,000
Often, language definitions like C or Java or C# or JavaScript--

36
00:02:24,000 --> 00:02:27,000
they don't change very quickly, if they change at all.

37
00:02:27,000 --> 00:02:32,000
Once you have taken the time to write down all of your token definitions for JavaScript,

38
00:02:32,000 --> 00:02:34,000
even if it is a few hundred lines long,

39
00:02:34,000 --> 00:02:36,000
you look at it. You write some test cases. You feel good about it.

40
00:02:36,000 --> 00:02:40,000
You do a code walk through with someone else, and then you're done,

41
00:02:40,000 --> 00:02:44,000
and you can just build upon that, take advantage of it for the rest of your

42
00:02:44,000 --> 00:02:46,000
software development career.

43
00:02:46,000 --> 00:02:50,000
So it can be a bit arduous to write down a bunch of token definitions,

44
00:02:50,000 --> 00:02:52,000
especially since a lot of them seem the same.

45
00:02:52,000 --> 99:59:59,999
But you do it once, and then it's over.
