1
00:00:00,000 --> 00:00:03,000
We'll that's enough abstract ideas for now without coverage.

2
00:00:03,000 --> 00:00:06,000
So, let's take a concrete look of what a coverage can do for us in practice.

3
00:00:06,000 --> 00:00:08,000
How it can help us do better testing.

4
00:00:08,000 --> 00:00:10,000
What are we going to do here is look at some random open source Python codes

5
00:00:10,000 --> 00:00:13,000
that implements a splay tree and before we go into the details

6
00:00:13,000 --> 00:00:15,000
let me briefly explain what a splay tree is.

7
00:00:15,000 --> 00:00:18,000
And broadly speaking a splay tree is just a kind of binary search tree.

8
00:00:18,000 --> 00:00:23,000
And a binary search tree is a tree where every node has two leaves

9
00:00:23,000 --> 00:00:26,000
and it supports operations such as insert, delete, and lookup.

10
00:00:26,000 --> 00:00:28,000
The main important thing about a binary search tree,

11
00:00:28,000 --> 00:00:30,000
the keys have to support an order in relation.

12
00:00:30,000 --> 00:00:35,000
And so an order in relation is anything that assigns a total ordering to all the keys in the space.

13
00:00:35,000 --> 00:00:39,000
Just a simple example if we're using integers for keys then we can use less than for order in relation.

14
00:00:39,000 --> 00:00:44,000
Or for example, if we're using words as our keys, then we can use dictionary order.

15
00:00:44,000 --> 00:00:47,000
And so again, it doesn't matter what kind of a data type the key is in a binary search tree.

16
00:00:47,000 --> 00:00:50,000
All that really matters is the keys we're going to use to look up

17
00:00:50,000 --> 00:00:52,000
elements in the tree have this order and relation.

18
00:00:52,000 --> 00:00:54,000
The way the binary search tree is going to work is,

19
00:00:54,000 --> 00:00:57,000
we're going to build up a tree under the invariant that the left child of any node

20
00:00:57,000 --> 00:01:02,000
always has a key that's ordered before the key of the parent node

21
00:01:02,000 --> 00:01:06,000
and the right child is always ordered after the parent node using the ordering.

22
00:01:06,000 --> 00:01:08,000
And so, hopefully which we can see now,

23
00:01:08,000 --> 00:01:10,000
is that if we build up some sort of a large tree with this kind of shape,

24
00:01:10,000 --> 00:01:12,000
we have a procedure for fast lookup.

25
00:01:12,000 --> 00:01:15,000
And the way that lookup works is, when we're searching for a particular key

26
00:01:15,000 --> 00:01:20,000
in the binary search tree, we only have to walk one path from the root down to the leaves.

27
00:01:20,000 --> 00:01:24,000
We always know which subtree might contain the key that we're looking for,

28
00:01:24,000 --> 00:01:26,000
and of course, we have to actually go down into that subtree to see if it's there,

29
00:01:26,000 --> 00:01:29,000
but the point is we only have to walk one path to the tree.

30
00:01:29,000 --> 00:01:32,000
And the upside is that generally, operations on this kind of a search tree,

31
00:01:32,000 --> 00:01:36,000
we're going to require a number of tree operations logarithmic in the number of tree nodes.

32
00:01:36,000 --> 00:01:40,000
So for example, we if we have a tree with a million nodes and if that tree that we build ends

33
00:01:40,000 --> 00:01:44,000
up being relatively balanced, then usually, we're going to expect to do about log base two

34
00:01:44,000 --> 00:01:47,000
of a million tree operations as part of a lookup, or insert, or delete

35
00:01:47,000 --> 00:01:50,000
and so we're going to end up doing roughly 20 operations.

36
00:01:50,000 --> 00:01:54,000
So, you can see some speed number of operations is far lower than a number of nodes in a tree

37
00:01:54,000 --> 99:59:59,999
that this is generally considered to be an efficient kind of a data structure.
