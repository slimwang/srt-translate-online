1
00:00:00,200 --> 00:00:06,166
So far, all is good. But now I'm going to do the sneaky thing that I did in the last proof:

2
00:00:06,167 --> 00:00:11,166
I'm going to put inverse halt into this list of programs. So if inverse halt is run on itself,

3
00:00:11,167 --> 00:00:16,032
there can only be two cases, right? So, halt can either say yes or no.

4
00:00:16,033 --> 00:00:19,766
We know it has to be one of the two cases, because there's no other possibility.

5
00:00:19,767 --> 00:00:26,466
Now, just as above here, what would that mean? So if halt, on inverse halt and inverse halt, would say yes,

6
00:00:26,467 --> 00:00:33,532
that would mean that inverse halt--and I'm just going to write it like this, so inverse halt stops, given inverse halt as an input.

7
00:00:33,533 --> 00:00:38,199
And the other case, of course, would mean that inverse halt does not stop, given itself as an input.

8
00:00:38,200 --> 00:00:45,466
So this is what happens if we read the table in this way. Now, let's read it another way because what we noticed here is that,

9
00:00:45,467 --> 00:00:52,099
if the program stops when it's given itself as an input, inverse halt on this program should go into an infinite loop.

10
00:00:52,100 --> 00:00:57,399
In other words, if we transfer what we did here to down here, we would have to write the following.

11
00:00:57,400 --> 00:01:01,866
So now let's compare those two statements in this line here. And here we said inverse halt will go into an infinite loop

12
00:01:01,867 --> 00:01:08,866
when given inverse halt, which is just itself, as an input. So you have the same contradiction here as we had in the other proof.

13
00:01:08,867 --> 00:01:14,499
And of course, the same thing is true down here. So here we said inverse halt does not stop, given itself as an input.

14
00:01:14,500 --> 00:01:21,332
And here we said inverse halt does stop when given itself. So this table here is a nice way to introduce the kind of logic crash

15
00:01:21,333 --> 00:01:26,799
that we use in the proof by contradiction. Because there's two ways of constructing this table.

16
00:01:26,800 --> 00:01:33,166
So the first way is to construct it this way, basically. Meaning that we look at what halt says--either yes or no--

17
00:01:33,167 --> 00:01:39,399
so we arrive at the conclusion of what the program does, based on what halt has to say about that program.

18
00:01:39,400 --> 00:01:44,199
Now, the other way of constructing this table is more or less going this way.

19
00:01:44,200 --> 00:01:51,399
So, based on what halt will say that the program does, we can predict the behavior of inverse halt.

20
00:01:51,400 --> 00:01:57,199
And this construction works perfectly fine. So constructing it this way or this way, those are both compatible views.

21
00:01:57,200 --> 00:02:03,432
With one exception: Once we feed inverse halt into this table, these two logics crash,

22
00:02:03,433 --> 00:02:10,199
because the conclusions that we draw in this way are exactly the opposite of the conclusions that we draw in this way.

23
00:02:10,199 --> 00:02:14,866
And that is why the contradiction is happening. And actually, constructing the table this way or this way is perfectly fine.

24
00:02:14,867 --> 00:02:18,466
The only problem is making the assumption that this halt algorithm here actually exists,

25
00:02:18,467 --> 00:02:20,300
which you already know it doesn't.
