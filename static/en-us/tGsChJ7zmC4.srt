1
00:00:00,120 --> 00:00:03,766
We've had a series of transforms apply to the object. The object's model

2
00:00:03,766 --> 00:00:06,664
transform followed by the view and projection transforms generated by the

3
00:00:06,664 --> 00:00:11,319
camera. The perspective divide converts from clip coordinates to normalized

4
00:00:11,319 --> 00:00:15,467
device coordinates. There's one last transform and it's a simple one, moving

5
00:00:15,467 --> 00:00:19,891
from normalized device coordinates to window coordinates. In other words how do

6
00:00:19,891 --> 00:00:23,018
you move from a space of negative 1 to 1 in X, Y and Z to an image with a depth

7
00:00:23,018 --> 00:00:27,714
buffer. The answer is simple enough. Add 1, divide by 2, then multiply by the

8
00:00:27,714 --> 00:00:32,759
window's resolution. Doing this operation changes from negative 1 to 1 to a

9
00:00:32,759 --> 00:00:37,104
range of 0 to 1. I should mention at this point that the other popular API,

10
00:00:37,104 --> 00:00:40,602
DirectX, has normalized device coordinates for the Z value that range from 0 to

11
00:00:40,602 --> 00:00:45,189
1 instead of negative 1 to 1. It doesn't really matter what range is used, it's

12
00:00:45,189 --> 00:00:49,004
just important to know that this range can vary. The X and Y ranges of going

13
00:00:49,004 --> 00:00:52,824
from negative 1 to 1 is standard throughout any system I've ever seen. In 3JS,

14
00:00:52,824 --> 00:00:56,246
you select some part of the screen using the set viewport method on the

15
00:00:56,246 --> 00:01:01,130
renderer. You give the lower left hand corner, and set the width and height.

16
00:01:01,130 --> 00:01:03,490
The settings here say to put the lower left hand corner of the view port a

17
00:01:03,490 --> 00:01:07,940
quarter of the way to the right of the origin, and at the bottom of the screen.

18
00:01:07,940 --> 00:01:10,900
The viewport itself should be half the width and height of the window. It's

19
00:01:10,900 --> 00:01:14,705
possible to have multiple viewports. Each viewport defines a piece of the image

20
00:01:14,705 --> 00:01:18,578
and you render separately to each one. This is very handy in modeling where you

21
00:01:18,578 --> 00:01:20,846
can have a few different views of the scene, possibly rendered in different

22
00:01:20,846 --> 00:01:25,804
ways. The conversion I gave from NDC to window coordinates assumes that the

23
00:01:25,804 --> 00:01:29,989
lower left hand corner of the image is the origin at 0, 0. It's worth

24
00:01:29,989 --> 00:01:33,151
mentioning there can be a flip in the y-axis within some systems such as the

25
00:01:33,151 --> 00:01:37,864
Document Object Model. Some systems that display the image generated consider

26
00:01:37,864 --> 00:01:41,706
that the upper left hand corner is 0, 0. If you see a flip in the Y direction

27
00:01:41,706 --> 00:01:46,055
during manipulation of the resulting image, this is likely the mismatch. While

28
00:01:46,055 --> 00:01:48,969
we're talking about 0, 0, please note that the lower left hand corner of the

29
00:01:48,969 --> 00:01:53,429
lower left pixel is at 0.0, 0.0. In other words, in floating point. The center

30
00:01:53,429 --> 00:02:01,530
of the pixel is not 0.0, 0.0. It's 0.5, 0.5. Almost all of the time, this is

31
00:02:01,530 --> 00:02:05,435
how you want to consider the center of the pixel. DirectX 9 got it wrong,

32
00:02:05,435 --> 00:02:11,790
making the center 0.0, 0.0. They fixed this in DirectX 10. I've seen textbooks

33
00:02:11,790 --> 00:02:16,303
talk about 0.0, 0.0 as the center of the pixel. Don't believe them. Using 0.0,

34
00:02:16,303 --> 00:02:21,154
0.0 as the center of the pixel has the odd effect of making the lower left hand

35
00:02:21,154 --> 00:02:26,782
corner negative 0.5, negative 0.5. It makes simple conversion between floats

36
00:02:26,782 --> 00:02:30,416
and integers trickier much of the time. With the proper center, you just drop

37
00:02:30,416 --> 00:02:34,177
the fraction. I've occasionally seen circumstances where offsetting half a

38
00:02:34,177 --> 00:02:38,070
pixel can make things work out more efficiently. But much of the time, you

39
00:02:38,070 --> 00:02:39,020
don't want to do this.
