1
00:00:00,150 --> 00:00:04,870
Let's talk about database performance. Database performance in MongoDB is

2
00:00:04,870 --> 00:00:08,240
driven by pretty much the same thing that every database is

3
00:00:08,240 --> 00:00:10,780
driven by, which is are you going to use an

4
00:00:10,780 --> 00:00:14,020
index to resolve your query or not? So this maybe a

5
00:00:14,020 --> 00:00:15,500
review for a lot of you, but I want to take

6
00:00:15,500 --> 00:00:18,690
you through the basics of indexing, and what it is and

7
00:00:18,690 --> 00:00:21,630
why it's so effective. If you look at MongoDB or any

8
00:00:21,630 --> 00:00:25,350
other database, it will store its data in these large files

9
00:00:25,350 --> 00:00:28,710
on disk. There's no particular order for the

10
00:00:28,710 --> 00:00:31,310
documents on the disk. They can be anywhere in

11
00:00:31,310 --> 00:00:34,490
a database file. If you want to pull out

12
00:00:34,490 --> 00:00:38,470
a particular document, you do a query. Now, what

13
00:00:38,470 --> 00:00:39,540
the database is going to have to do

14
00:00:39,540 --> 00:00:43,750
by default is scan through the entire collection to

15
00:00:43,750 --> 00:00:46,540
find the data. This is called a table scan

16
00:00:46,540 --> 00:00:50,230
in relational databases and a collection scan in MongoDB.

17
00:00:50,230 --> 00:00:53,120
It is death to your performance. If the data

18
00:00:53,120 --> 00:00:56,490
set is large, it'll be extremely slow. So, instead what

19
00:00:56,490 --> 00:00:59,580
we do is we create an index, or maybe

20
00:00:59,580 --> 00:01:02,760
more than one index. So how does indexing work? Well,

21
00:01:02,760 --> 00:01:06,390
it's actually pretty straightforward. If something is ordered, like

22
00:01:06,390 --> 00:01:10,080
for instance, this list of hashtags, even if it's very

23
00:01:10,080 --> 00:01:12,790
long, it's very quick to find something in the

24
00:01:12,790 --> 00:01:16,050
list because we can use binary search to do it.

25
00:01:16,050 --> 00:01:18,570
So, finding something in a sorted list is really

26
00:01:18,570 --> 00:01:21,510
quick. Now to create an index, we want to specify

27
00:01:21,510 --> 00:01:24,080
a key. An index is simply an ordered list

28
00:01:24,080 --> 00:01:27,740
of keys. Now we don't actually keep them linearly

29
00:01:27,740 --> 00:01:30,500
ordered like this in MongoDB, we use something called

30
00:01:30,500 --> 00:01:33,710
a B Tree, but conceptually you can imagine it

31
00:01:33,710 --> 00:01:37,540
looking like this perfectly reasonable conceptual model. And if

32
00:01:37,540 --> 00:01:41,070
I'm looking for like say Lucero, I can quickly search,

33
00:01:41,070 --> 00:01:42,960
find the item and then have a pointer

34
00:01:42,960 --> 00:01:45,570
to the actual document or documents inside the

35
00:01:45,570 --> 00:01:49,380
collection that have this hashtag associated with them.

36
00:01:49,380 --> 00:01:52,810
So this picture actually represents an index that is

37
00:01:52,810 --> 00:01:56,130
composed of just hashtags. So we're using a

38
00:01:56,130 --> 00:01:59,800
single field as the basis for our index. But

39
00:01:59,800 --> 00:02:01,840
this is just a special case of the

40
00:02:01,840 --> 00:02:05,700
more general idea of indexes in MongoDB. In mongoDB,

41
00:02:05,700 --> 00:02:09,699
indexes are ordered lists of keys. You can have just

42
00:02:09,699 --> 00:02:13,210
one, as we saw in the previous example, or we

43
00:02:13,210 --> 00:02:15,210
could do something like this and construct an index out

44
00:02:15,210 --> 00:02:18,120
of three keys. Let's say for example the hashtag, the date

45
00:02:18,120 --> 00:02:20,600
on which a tweet was created, and the username of

46
00:02:20,600 --> 00:02:25,350
the person creating the tweet. The order is important here. Because,

47
00:02:25,350 --> 00:02:28,585
conceptually, the way the index is built, is that the

48
00:02:28,585 --> 00:02:31,110
hashtag will be at the top, so here are my hashtags:

49
00:02:31,110 --> 00:02:34,110
Colin Hay, Lucero and then Steve Earle near

50
00:02:34,110 --> 00:02:36,830
the end of my index. And then, within

51
00:02:36,830 --> 00:02:40,180
this, so let's say Colin Hay is conceptually

52
00:02:40,180 --> 00:02:43,820
here, for all of those items, we'll have dates

53
00:02:43,820 --> 00:02:46,400
as the second level of our index. And

54
00:02:46,400 --> 00:02:49,010
what we're going to do within the Colin Hay portion

55
00:02:49,010 --> 00:02:52,680
of the index is sort these by order

56
00:02:52,680 --> 00:02:56,560
of date. So the documents then, that are identified

57
00:02:56,560 --> 00:02:59,110
down to this level of date are first identified by

58
00:02:59,110 --> 00:03:02,400
the hashtag colinhay and then sorted based on their date of

59
00:03:02,400 --> 00:03:07,370
creation. And then finally, within each date, so for each

60
00:03:07,370 --> 00:03:09,140
day on which a tweet was created with the hashtag colinhay,

61
00:03:09,140 --> 00:03:12,190
we're going to have the usernames of all of those

62
00:03:12,190 --> 00:03:15,700
users and those then will be sorted as well. So if

63
00:03:15,700 --> 00:03:18,020
you provide me just the hashtag I can go into the

64
00:03:18,020 --> 00:03:21,790
index and find all the let's say Luceros in this case.

65
00:03:21,790 --> 00:03:24,490
And if you prefer to also provide me the date,

66
00:03:24,490 --> 00:03:26,930
then I can break it down and find all the Lucero

67
00:03:26,930 --> 00:03:30,610
tweets on that particular day. At the very bottom of this

68
00:03:30,610 --> 00:03:33,140
of course, is going to be pointers to the actual data.

69
00:03:34,200 --> 00:03:37,140
Now, in order for MongoDB to be utilized in index

70
00:03:37,140 --> 00:03:40,300
you have to give it a left most set of items.

71
00:03:40,300 --> 00:03:43,060
So, you can give it just the hashtag or you can

72
00:03:43,060 --> 00:03:47,120
give it just the hashtag and the date or the hashtag,

73
00:03:47,120 --> 00:03:50,610
the date, and the user name. For this particular index, if you

74
00:03:50,610 --> 00:03:54,130
provide me just the date, I can't do much really with the

75
00:03:54,130 --> 00:03:58,380
index because the date is down here at this level. So to

76
00:03:58,380 --> 00:04:01,110
use an index, I need to start at the top, and this is

77
00:04:01,110 --> 00:04:03,370
true whether or not I'm doing a query or I'm doing an

78
00:04:03,370 --> 00:04:06,960
update or I'm doing a sort, because sorts also will use an

79
00:04:06,960 --> 00:04:10,280
index to sort their values. So for instance, if I pull a

80
00:04:10,280 --> 00:04:12,340
bunch of data out of the collection and want to sort it by

81
00:04:12,340 --> 00:04:15,530
hashtag, with MongoDB, I can use this index to do

82
00:04:15,530 --> 00:04:19,180
the sorting. Now, one other point I want to make is that

83
00:04:19,180 --> 00:04:22,330
every time you want to insert something into the database

84
00:04:22,330 --> 00:04:25,800
this index would need to be updated, and that updating is

85
00:04:25,800 --> 00:04:28,340
going to take some time. So we use indexes to make

86
00:04:28,340 --> 00:04:31,920
Reads faster, but Writes become a little bit slower if you

87
00:04:31,920 --> 00:04:34,560
have an index because the index needs to be updated. So

88
00:04:34,560 --> 00:04:37,680
you need to take that into consideration when you're thinking about

89
00:04:37,680 --> 00:04:40,070
what indexes you might want for your particular

90
00:04:40,070 --> 00:04:43,509
application. Indexes are not costless. They take space

91
00:04:43,509 --> 00:04:47,248
on disks, they also take time to keep updated. So you don't want to have a index

92
00:04:47,248 --> 00:04:48,882
on every single possible way you're going to

93
00:04:48,882 --> 00:04:50,602
query the collection, you instead want to have

94
00:04:50,602 --> 00:04:52,021
an index on the ways you're most likely

95
00:04:52,021 --> 00:04:53,690
way you are going to query the collection.
