1
00:00:00,340 --> 00:00:06,650
The second myth concerns going across protection domains and espeiclaly if the

2
00:00:06,650 --> 00:00:10,590
protection domains are impmlemented as distinct

3
00:00:10,590 --> 00:00:13,360
hardware address spaces, then the myth

4
00:00:13,360 --> 00:00:17,100
is that crossing protection domains implemented

5
00:00:17,100 --> 00:00:19,640
using hardware address space switch is

6
00:00:19,640 --> 00:00:22,230
expensive. And we are now talking

7
00:00:22,230 --> 00:00:26,630
explicit cost for crossing protection domains implemented

8
00:00:26,630 --> 00:00:30,060
as distinct hardware address spaces. Not the implicit

9
00:00:30,060 --> 00:00:33,880
cost, we're only talking about the explicit cost

10
00:00:33,880 --> 00:00:37,060
of crossing protection domain. Now, let's understand what

11
00:00:37,060 --> 00:00:40,210
is involved in an address space switch. This

12
00:00:40,210 --> 00:00:42,770
is a refresher to show you what exactly

13
00:00:42,770 --> 00:00:46,910
is happening in terms of translating a virtual

14
00:00:46,910 --> 00:00:49,130
address to a physical address. You all know

15
00:00:49,130 --> 00:00:51,830
about the concept of a TLB and the virtual

16
00:00:51,830 --> 00:00:57,930
address consists of two parts; an index part and a tag. The index is used to

17
00:00:57,930 --> 00:01:03,050
look up the TLB and the tag that is contained in that particular entry of the

18
00:01:03,050 --> 00:01:07,140
TLB is matched against the tag coming from

19
00:01:07,140 --> 00:01:09,480
the virtual address. If they match, then we

20
00:01:09,480 --> 00:01:13,180
got a hit, then this particular virtual address

21
00:01:13,180 --> 00:01:16,860
is contained in the TLB entry and you've got

22
00:01:16,860 --> 00:01:19,900
the physical frame number that corresponds to the

23
00:01:19,900 --> 00:01:21,750
virtual page number that you started with, so

24
00:01:21,750 --> 00:01:26,450
that is your, very simple, TLB, matching hardware

25
00:01:26,450 --> 00:01:29,720
that does the address translation from VPN to

26
00:01:29,720 --> 00:01:33,200
PFN. Now what happens on an address space

27
00:01:33,200 --> 00:01:35,290
switch? That is a context switch going from

28
00:01:35,290 --> 00:01:39,120
one address space to another address space. On

29
00:01:39,120 --> 00:01:42,190
a context switch, the virtual address to physical address

30
00:01:42,190 --> 00:01:45,170
mapping will change for the new process that

31
00:01:45,170 --> 00:01:47,970
is going to be scheduled. So in other words,

32
00:01:47,970 --> 00:01:51,870
if this TLB contains the translations for a

33
00:01:51,870 --> 00:01:54,810
particular process that is currently executing on the

34
00:01:54,810 --> 00:02:00,580
CPU, if we do a context switch, do we have to flush the TLB because the

35
00:02:00,580 --> 00:02:03,270
virtual address to physical address mapping is going to

36
00:02:03,270 --> 00:02:07,540
be different for the new process or new thread

37
00:02:07,540 --> 00:02:12,560
that is going to run on the processor now? The answer to the question do

38
00:02:12,560 --> 00:02:17,370
we have to throw away the mappings that exist in the TLB, when we do a context

39
00:02:17,370 --> 00:02:22,660
switch, is, it depends. It depends on whether the

40
00:02:22,660 --> 00:02:27,760
TLB has a way of recognizing that the

41
00:02:27,760 --> 00:02:33,300
virtual to physical address translation that is contained in it, is flagged

42
00:02:33,300 --> 00:02:38,280
by the distinct process for which those translations have been put into

43
00:02:38,280 --> 00:02:43,270
the TLB. In other words, if the TLB has address

44
00:02:43,270 --> 00:02:48,080
space tags in addition to the tag for disambiguating one

45
00:02:48,080 --> 00:02:53,230
virtual address from another virtual address then you don't have

46
00:02:53,230 --> 00:02:58,362
to flush the TLB. So these are what are called address space tag TLBs

47
00:02:58,362 --> 00:03:06,960
which contain the process ID for which a particular TLB entry is present

48
00:03:06,960 --> 00:03:12,960
in the TLB. MIPS Architecture for instance uses address space tagged TLBs.

49
00:03:12,960 --> 00:03:18,160
But on the other hand, an architecture may not use an address space tagged TLB.

50
00:03:18,160 --> 00:03:24,260
Intel 486, and Intel Pentium are examples of architectures that

51
00:03:24,260 --> 00:03:27,440
do not have address space tags associated in

52
00:03:27,440 --> 00:03:31,250
the TLB. So, in an Intel architecture, at

53
00:03:31,250 --> 00:03:33,530
the point of the context switch, you have

54
00:03:33,530 --> 00:03:37,990
to throw away all the entries that are there

55
00:03:37,990 --> 00:03:40,620
in the TLB on behalf of the process.

56
00:03:40,620 --> 00:03:43,630
In the Intel architecture, actually the TLB is

57
00:03:43,630 --> 00:03:46,500
split into two parts, a user part and

58
00:03:46,500 --> 00:03:50,020
a kernel part. And the kernel part is common

59
00:03:50,020 --> 00:03:52,940
regardless of which process is running. And

60
00:03:52,940 --> 00:03:55,670
therefore, you don't have to flush that portion

61
00:03:55,670 --> 00:04:00,710
of the TLB, the kernel portion of the TLB, but the user portion of the TLB

62
00:04:00,710 --> 00:04:02,490
has to be flushed on a context

63
00:04:02,490 --> 00:04:05,360
switch because the virtual address, the physical address

64
00:04:05,360 --> 00:04:07,580
mapping, is going to be different for the new

65
00:04:07,580 --> 00:04:09,860
process that starts to run on the processor.
