1
00:00:00,210 --> 00:00:04,180
We have seen that DRAM accesses
are slow, because really we have to use

2
00:00:04,180 --> 00:00:09,170
the row decoder to select the row,
then get those bits onto the bit lines,

3
00:00:09,170 --> 00:00:12,280
then sense what's on the bit lines,
and so on, and

4
00:00:12,280 --> 00:00:16,490
only then we get the values in the row
buffer from which we can read them and

5
00:00:16,490 --> 00:00:18,670
send them back to the processor.

6
00:00:18,670 --> 00:00:22,390
But not all of the DRAM
accesses have to be that slow.

7
00:00:22,390 --> 00:00:25,350
So we will discuss a technique
called fast page mode,

8
00:00:25,350 --> 00:00:29,690
that makes some of the DRAM
accesses a lot faster than others.

9
00:00:29,690 --> 00:00:32,290
Remember our organization of the DRAM

10
00:00:33,370 --> 00:00:37,160
with some part of
the address to select a row.

11
00:00:37,160 --> 00:00:41,270
That row of bits gets output
to the sense amplifier.

12
00:00:41,270 --> 00:00:45,160
We then latch those into the row buffer,
and then from the row buffer,

13
00:00:45,160 --> 00:00:48,450
we use the column address
to select a bit to output.

14
00:00:49,490 --> 00:00:53,050
And then, from the row buffer,
the column decoder,

15
00:00:53,050 --> 00:00:56,960
using the column address,
selects the actual bit to output.

16
00:00:56,960 --> 00:01:02,380
Note that once we have done all of this,
the row buffer can retain

17
00:01:02,380 --> 00:01:07,830
the entire row, so if we want
to read a bit from the same row,

18
00:01:07,830 --> 00:01:12,495
we don't need to go through the whole
row address, sense amplifier,

19
00:01:12,495 --> 00:01:15,920
row buffer mechanism again.

20
00:01:15,920 --> 00:01:20,340
What we can do is simply keep what
we have in the row buffer and

21
00:01:20,340 --> 00:01:21,799
just change the column address.

22
00:01:22,860 --> 00:01:28,720
Then the bit simply gets read out of
row buffer without a new DRAM access.

23
00:01:28,720 --> 00:01:34,460
So this approach of finding
what we need in the row buffer

24
00:01:34,460 --> 00:01:36,366
is call is fast-page mode.

25
00:01:36,366 --> 00:01:40,970
It's not called fast-row mode just
because some people prefer to call

26
00:01:42,870 --> 00:01:44,700
a memory row a page.

27
00:01:44,700 --> 00:01:47,950
It usually has thousands of bits,
so people call it a page.

28
00:01:47,950 --> 00:01:51,630
It has nothing to do with the pages
that we use for virtual memory.

29
00:01:51,630 --> 00:01:55,298
It's just a name for something that
has a lot of bits in this case.

30
00:01:55,298 --> 00:01:59,230
So fast-page mode works this way.

31
00:01:59,230 --> 00:02:02,010
We do what is called opening up a page.

32
00:02:02,010 --> 00:02:08,669
That amounts to providing a row address,
selecting a row, sense amplification

33
00:02:08,669 --> 00:02:13,520
of what the cells output, and latching
what we get into the row buffer.

34
00:02:13,520 --> 00:02:15,850
Now we can do a series of reads and

35
00:02:15,850 --> 00:02:19,830
writes to the page,
which really happens to the row buffer.

36
00:02:19,830 --> 00:02:22,770
We can read or
we can modify bits in the row buffer.

37
00:02:22,770 --> 00:02:26,800
Finally, when we want to do
something on another row in memory,

38
00:02:26,800 --> 00:02:29,430
we do what is called closing the page.

39
00:02:29,430 --> 00:02:33,830
We now use the sense
amplifiers to write back

40
00:02:33,830 --> 00:02:36,990
to the row what we
have in our row buffer.

41
00:02:36,990 --> 00:02:41,630
It could be different data than what we
read because we have been modifying it

42
00:02:41,630 --> 00:02:43,440
also in between.

43
00:02:43,440 --> 00:02:46,630
And this way if we want to do a single
read we would have to open up page,

44
00:02:46,630 --> 00:02:50,300
do one read, then close up page
to write back things to our

45
00:02:50,300 --> 00:02:52,800
memory cells because of
the destructive read.

46
00:02:52,800 --> 00:02:56,640
And then finally we have to do what is
called closing the page, which amounts

47
00:02:56,640 --> 00:03:01,850
to writing the data from the row buffer
back into the row from which we read it.

48
00:03:01,850 --> 00:03:05,790
So if we want to do a single
memory read, we would open a page.

49
00:03:06,940 --> 00:03:10,120
The data is now in the row buffer,
and no longer in the row.

50
00:03:11,300 --> 00:03:14,310
Do the read from the row buffer and
then close the page,

51
00:03:14,310 --> 00:03:18,830
which causes the data to be sent
back and written back to the row.

52
00:03:18,830 --> 00:03:22,136
We can do a single write,
which amounts to opening a page,

53
00:03:22,136 --> 00:03:24,770
the data now ends up in the row buffer.

54
00:03:24,770 --> 00:03:28,990
We do a single write, so
we modify a bit in the row buffer, and

55
00:03:28,990 --> 00:03:34,820
then we close the page which causes
the row to get the new data, and some of

56
00:03:34,820 --> 00:03:38,180
the bits may not have changed, which is
why we had to read in the first place.

57
00:03:39,410 --> 00:03:43,760
But we can do a lot more than just
one operation in between opening and

58
00:03:43,760 --> 00:03:44,420
closing a page.

59
00:03:45,560 --> 00:03:50,900
So usually, it's advantageous to
open a page, do all the reads and

60
00:03:50,900 --> 00:03:54,990
writes that we can to that page before
we close the page and open another page.
