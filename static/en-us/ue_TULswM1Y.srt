1
00:00:00,430 --> 00:00:04,200
Here you can see, we're back at the data binding function, for

2
00:00:04,200 --> 00:00:06,290
when we added circles to our map.

3
00:00:06,290 --> 00:00:09,520
All this time when we were binding data, you might have been wondering to

4
00:00:09,520 --> 00:00:15,680
yourself, how does D3 know which data's on the screen, and which data's changed?

5
00:00:15,680 --> 00:00:19,840
Well, since we're going to be animating and updating our map, we want to be

6
00:00:19,840 --> 00:00:25,020
very explicit about what each piece of data bound actually represents.

7
00:00:25,020 --> 00:00:30,040
Here we'll be adding a special function, as the second argument to data bind.

8
00:00:30,040 --> 00:00:34,250
It has the familiar syntax of any other accessor function in d3,

9
00:00:34,250 --> 00:00:37,950
and based on what we return from the function,

10
00:00:37,950 --> 00:00:42,560
d3 binds that value, to the elements selected above.

11
00:00:42,560 --> 00:00:47,216
In this case, our nested grouping actually did a lot of the hard work for us.

12
00:00:47,216 --> 00:00:53,640
Remember, the key to our nested groups represents the year of the World Cup.

13
00:00:53,640 --> 00:00:59,010
In this case, in our key function, all we need to do is simply return d

14
00:01:00,880 --> 00:01:04,065
key of the passed in nested object.

15
00:01:04,065 --> 00:01:09,110
In this case, d key is going to represent a string corresponding to

16
00:01:09,110 --> 00:01:14,020
the year of the World Cup, that the given data point d, represents.

17
00:01:14,020 --> 00:01:20,590
If we do not specify a key function, D3 uses the datum's index in its array.

18
00:01:20,590 --> 00:01:24,320
And while this works for most static use cases, where you're not

19
00:01:24,320 --> 00:01:28,530
changing your data array, since we'll be filtering and manipulating our data,

20
00:01:28,530 --> 00:01:33,850
we don't want to have to rely on that being in the same order every single time.

21
00:01:33,850 --> 00:01:37,280
I also wanted to point out that the nested key

22
00:01:37,280 --> 00:01:41,880
is not associated in any way to the key function itself.

23
00:01:41,880 --> 00:01:44,670
To use a key function in a data bind, we

24
00:01:44,670 --> 00:01:50,290
don't actually have to use a nested object, or any object that has a key field.

25
00:01:50,290 --> 00:01:53,780
We can simply return any arbitrary value, or

26
00:01:53,780 --> 00:01:55,850
any value that depends on our data point.

27
00:01:55,850 --> 00:02:01,030
We could have just as easily, instead of binding our data by year,

28
00:02:01,030 --> 00:02:03,290
bounded by attendance value.

29
00:02:03,290 --> 00:02:07,880
In this case, just to make a point, we're grabbing the attendance value of

30
00:02:07,880 --> 00:02:13,390
a given year, and the value's object, it gets attached to every nested object.

31
00:02:13,390 --> 00:02:16,820
So remember, the key function is much more

32
00:02:16,820 --> 00:02:21,990
flexible than the key property attached to a d3 object.

33
00:02:21,990 --> 00:02:26,990
And now that we've properly associated a given data row with an object on our

34
00:02:26,990 --> 00:02:31,230
screen, in this case circles, by some unique key,

35
00:02:31,230 --> 00:02:35,830
we can begin removing and adding circles as we cycle through our years.
