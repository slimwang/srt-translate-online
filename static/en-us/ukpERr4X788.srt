1
00:00:00,500 --> 00:00:03,469
It's possible to get unlucky using direct mapped caches, in

2
00:00:03,469 --> 00:00:06,170
that different blocks that are important to your application might get

3
00:00:06,170 --> 00:00:09,230
mapped to the same index in the cache. For instance,

4
00:00:09,230 --> 00:00:12,190
if an application happens to access two cache lines that have

5
00:00:12,190 --> 00:00:15,820
the same index, maybe this one and this one here,

6
00:00:15,820 --> 00:00:19,230
then they will constantly be evicting each other from the cache.

7
00:00:19,230 --> 00:00:22,930
And it, it will be essentially useless. This, of course, is

8
00:00:22,930 --> 00:00:25,540
rather silly given that there are all these other entries in

9
00:00:25,540 --> 00:00:28,060
the cache that aren't getting used at all. The

10
00:00:28,060 --> 00:00:31,770
fundamental problem is that the address, any one of these

11
00:00:31,770 --> 00:00:34,320
here, is only associated with one location in the

12
00:00:34,320 --> 00:00:38,960
cache. We can mitigate these effects by associating an address

13
00:00:38,960 --> 00:00:41,420
with more than one block in the cache. One

14
00:00:41,420 --> 00:00:44,400
strategy is to treat all the red lines as blue

15
00:00:44,400 --> 00:00:47,280
ones, and all of the orange lines as green ones.

16
00:00:48,450 --> 00:00:50,860
If we do this then we'll have twice as many

17
00:00:50,860 --> 00:00:53,900
places in the cache to store a blue line of memory.

18
00:00:53,900 --> 00:00:56,470
Actually, it's more convenient to think about the blue lines in

19
00:00:56,470 --> 00:00:59,140
the cache being together. And in this way, we can say

20
00:00:59,140 --> 00:01:02,950
that we have simply decided to ignore the most significant bit of

21
00:01:02,950 --> 00:01:06,160
our previous index, but to allow a cache block to now

22
00:01:06,160 --> 00:01:10,140
be stored in two possible places. Hence, this would be called a

23
00:01:10,140 --> 00:01:13,070
two way associative cache. The downside is that we have to

24
00:01:13,070 --> 00:01:16,560
check two tags now to see if we have a cache hit.

25
00:01:16,560 --> 00:01:18,680
But we are less likely run into a problem, where

26
00:01:18,680 --> 00:01:21,513
we are constantly evicting the memory we need from the cache.

27
00:01:21,513 --> 00:01:24,033
If we decide this isn't good enough, we can halve the

28
00:01:24,033 --> 00:01:27,690
number of indices again to create a four way associative cache.

29
00:01:27,690 --> 00:01:30,440
Returning to our general notation, we now say that we have

30
00:01:30,440 --> 00:01:34,220
2 to the j associativity. This means that we only have

31
00:01:34,220 --> 00:01:37,520
two to the k minus j indices into our cache, and

32
00:01:37,520 --> 00:01:41,600
the index is really only k minus j bits long now.

33
00:01:41,600 --> 00:01:43,860
This greater associativity also gives the cache

34
00:01:43,860 --> 00:01:45,890
some choice about replacement. Whereas with the

35
00:01:45,890 --> 00:01:49,230
direct mount cache, there was only one block in the cache where the data could

36
00:01:49,230 --> 00:01:54,170
be stored. We now have a set of possible locations. Just two in our example

37
00:01:54,170 --> 00:01:56,320
but maybe more. Typically, we choose to

38
00:01:56,320 --> 00:01:59,160
evict the entry that was least recently used.
