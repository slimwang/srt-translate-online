1
00:00:00,000 --> 00:00:03,000
Now here we have below a code from Wikipedia that does the same thing.

2
00:00:03,000 --> 00:00:05,000
And I'm not going to go through the logic here.

3
00:00:05,000 --> 00:00:07,000
But what you can see is this is quite a bit more idiomatic Python.

4
00:00:07,000 --> 00:00:09,000
It's actually quite a bit nicer than the code that I wrote.

5
00:00:09,000 --> 00:00:12,000
So if you like that better then use this as a model instead of the code that I wrote.

6
00:00:12,000 --> 00:00:14,000
The code that I wrote is pretty kind of dumb and obvious.

7
00:00:14,000 --> 00:00:17,000
We have equivalently a Luhn valid check sum using the Wikipedia algorithm,

8
00:00:17,000 --> 00:00:19,000
which just does the obvious thing.

9
00:00:19,000 --> 00:00:23,000
And then what I have here is a random tester, which generates a random credit card number

10
00:00:23,000 --> 00:00:27,000
with a certain prefix and 15 digits and then ensures is that it's valid.

11
00:00:27,000 --> 00:00:30,000
The validity checking function for credit card numbers simply makes sure

12
00:00:30,000 --> 00:00:34,000
that it has the right length, that it has the right prefix, and that the checksum comes out to be 0.

13
00:00:34,000 --> 00:00:38,000
That is to say, the is-Luhn-valid function returns true. So that's all there is to it.

14
00:00:38,000 --> 00:00:41,000
But what I want to do finally is take a look at one other issue.

15
00:00:41,000 --> 00:00:46,000
I'm going to comment out my code here and comment in some different code.

16
00:00:46,000 --> 00:00:51,000
What we're doing here is generating completely random 15-digit numbers.

17
00:00:51,000 --> 00:00:56,000
What I'm doing is generating a random integer between 0 and the smallest 16-digit number.

18
00:00:56,000 --> 00:01:00,000
The largest number that could be generated here is the largest 15-digit number.

19
00:01:00,000 --> 00:01:04,000
And then we're going to zero-fill, convert that to a string, and do a zero-fill operation,

20
00:01:04,000 --> 00:01:06,000
which adds leading zeros.

21
00:01:06,000 --> 00:01:08,000
Now we have a completely random number that is 15 digits long.

22
00:01:08,000 --> 00:01:11,000
And if that checks out to be a valid credit card number,

23
00:01:11,000 --> 00:01:14,000
we're going to increment our validity checker and then finally after doing this 100 thousand times

24
00:01:14,000 --> 00:01:17,000
we're going to print the number of valid credit card numbers that we got.

25
00:01:17,000 --> 00:01:19,000
So let's run this and see what happens. Okay.

26
00:01:19,000 --> 00:01:21,000
We got no valid credit card numbers out of 100 thousand.

27
00:01:21,000 --> 00:01:24,000
So the problem is the prefix was too long.

28
00:01:24,000 --> 00:01:29,000
With a 6-digit prefix, the chance is one in a million that we'll generate just this prefix

29
00:01:29,000 --> 00:01:33,000
and then it goes down to one in 10 million that will meet the prefix and the checksum requirement.

30
00:01:33,000 --> 00:01:37,000
So if we start off with a much smaller prefix like just 37 and this is basically anything

31
00:01:37,000 --> 00:01:40,000
in the American Express system I think, now let's see what happens.

32
00:01:40,000 --> 00:01:44,000
We're going to generate 100 thousand credit card numbers and 104 of them came out to be valid.

33
00:01:44,000 --> 00:01:49,000
So even with just a two-digit prefix, it's pretty unlikely that we generate valid credit card numbers.

34
00:01:49,000 --> 00:01:53,000
And so what that means is if we're generating lots of invalid credit card numbers

35
00:01:53,000 --> 00:01:59,000
of course we're stressing only a very small bit of a transaction processing logic

36
00:01:59,000 --> 00:02:02,000
that checks for valid credit card numbers and we're not stressing the rest of it.

37
00:02:02,000 --> 00:02:07,000
So what I hoped I accomplished here is first of all motivated the fact that this generation of valid data

38
00:02:07,000 --> 00:02:11,000
is a real one and second of all, to give you a little bit of a feel for what code looks like

39
00:02:11,000 --> 00:02:13,000
that we usually have to write to generate valid inputs.

40
00:02:13,000 --> 00:02:16,000
And so, if we go back to our web browser example, you can see that we will be doing a

41
00:02:16,000 --> 00:02:19,000
similar exercise but it'd just be quite a bit more sophisticated to generate

42
00:02:19,000 --> 00:02:23,000
for example a valid HTML or a valid HTML with scripts and other things.

43
00:02:23,000 --> 00:02:28,000
That it would take to actually do meaningful fuzzing of a web browser as shown by the blue line here.

44
00:02:28,000 --> 00:02:31,000
And so now to do this, instead of spending half an hour or however long you spend

45
00:02:31,000 --> 00:02:35,000
on the PR quiz now maybe you're going to be spending many weeks.

46
00:02:35,000 --> 00:02:37,000
But on the other hand, what we're going to get out of this if we do it right

47
00:02:37,000 --> 00:02:42,000
is a lot of high-value bugs including security bugs in our web browser and strongly possible

48
00:02:42,000 --> 00:02:45,000
but of course not guaranteed that the value we get out of those bugs

49
00:02:45,000 --> 00:02:48,000
that we find in a web browser but the effort would've been worth it.
