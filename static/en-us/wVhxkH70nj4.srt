1
00:00:00,000 --> 00:00:02,000
We've still got the code the I wrote for the Luhn checksum.

2
00:00:02,000 --> 00:00:08,000
And this is kind of a redundant bad code but I wrote it quickly and I think it works.

3
00:00:08,000 --> 00:00:11,000
So we have the Luhn checksum function.

4
00:00:11,000 --> 00:00:13,000
And the first thing it does is looks at the length of it's argument.

5
00:00:13,000 --> 00:00:17,000
That is to say, it looks at the length of the string over which it's going to compute a checksum.

6
00:00:17,000 --> 00:00:19,000
It's also going to initialize the checksum variable to be 0.

7
00:00:19,000 --> 00:00:22,000
Now, if we're computing a checksum over an even number of digits,

8
00:00:22,000 --> 00:00:25,000
the remainder mod 2 is going to come out to 0.

9
00:00:25,000 --> 00:00:28,000
So in this case, we're going to loop over the digits and the checksum.

10
00:00:28,000 --> 00:00:31,000
That is the range(l) goes from 0 to length -1.

11
00:00:31,000 --> 00:00:35,000
And here what I'm going to do is add 1 to that number

12
00:00:35,000 --> 00:00:38,000
so that we can get a 1-base numbering system like I showed you

13
00:00:38,000 --> 00:00:40,000
in the explanation of Luhns algorithm.

14
00:00:40,000 --> 00:00:44,000
So here now, if we're at digit 0 in Python we're at digit number 1

15
00:00:44,000 --> 00:00:49,000
in the 1-base human number system and so if that comes out to be 0 when moded with 2

16
00:00:49,000 --> 00:00:53,000
now with an even number digit and so in that case we're going to add

17
00:00:53,000 --> 00:00:57,000
the value of that digit into the sum; otherwise, we're going to call this Luhn digit function

18
00:00:57,000 --> 00:01:00,000
on the same value and the Luhn digit function is just sort of the obvious thing.

19
00:01:00,000 --> 00:01:04,000
It multiplies the number by 2. If it's greater than 9, it returns 9 less than the number.

20
00:01:04,000 --> 00:01:06,000
Otherwise, it just returns the number.

21
00:01:06,000 --> 00:01:09,000
Now, the other case is that we're checksumming an odd number of digits.

22
00:01:09,000 --> 00:01:13,000
In that case, we have exactly the same logic with the even and odd cases flipped around.

23
00:01:13,000 --> 00:01:17,000
So here we're taking the Python zero-based digit adding 1 to it to get a human

24
00:01:17,000 --> 00:01:19,000
1-based numbering system moding with 2.

25
00:01:19,000 --> 00:01:22,000
If it comes out to be even, we're doing the Luhn digit computation.

26
00:01:22,000 --> 00:01:24,000
If it's odd, then we're just adding in the value of the number.

27
00:01:24,000 --> 00:01:27,000
And finally, we get a checksum that we've accumulated here.

28
00:01:27,000 --> 00:01:31,000
And we take that mod 10 and that gives us our actual checksum value that we're going to use.

29
00:01:31,000 --> 00:01:34,000
So now, here's the algorithm for generating a valid random credit card number.

30
00:01:34,000 --> 00:01:39,000
So the inputs are remember a prefix and a total length in digits.

31
00:01:39,000 --> 00:01:42,000
So the number of random digits we're going to generate is the total length

32
00:01:42,000 --> 00:01:44,000
minus the length of the prefix minus 1 for the checksum digit.

33
00:01:44,000 --> 00:01:47,000
Now we're just going to assert that that's greater than 0 just to be careful.

34
00:01:47,000 --> 00:01:50,000
And now we're going to set N as our credit card number that's in progress.

35
00:01:50,000 --> 00:01:52,000
So we're going to initialize that to be just the prefix.

36
00:01:52,000 --> 00:01:54,000
Now for the number of random digits we have,

37
00:01:54,000 --> 00:01:57,000
we're just going to make up a random digit and append it to the string.

38
00:01:57,000 --> 00:02:01,000
Finally, we're going to add a zero checksum to it and compute the Luhn checksum.

39
00:02:01,000 --> 00:02:03,000
If that Luhn checksum comes out to be zero, we're done.

40
00:02:03,000 --> 00:02:06,000
If that Luhn checksum comes out to be non-zero, we have to do the little inversion

41
00:02:06,000 --> 00:02:09,000
that I talked about where we take the checksum where we subtract the checksum from 10

42
00:02:09,000 --> 00:02:13,000
and now what this little bit of logic does is it strips off the last character.

43
00:02:13,000 --> 00:02:17,000
That's the zero we added from the credit card number and adds on the checksum number.

44
00:02:17,000 --> 00:02:19,000
So that's how easy it is to generate a valid credit card number.

45
00:02:19,000 --> 00:02:23,000
And now there is one valid function just to check if the Luhn checksum is 0.
