1
00:00:00,240 --> 00:00:03,890
So far we've described the address translation process like this.

2
00:00:03,890 --> 00:00:07,170
The offset from the virtual address, simply gets copied to

3
00:00:07,170 --> 00:00:09,970
the physical address. And in order to translate the virtual

4
00:00:09,970 --> 00:00:13,090
page number, we do a look up in the page table,

5
00:00:13,090 --> 00:00:16,420
which is in memory, to find the physical page frame.

6
00:00:16,420 --> 00:00:19,310
Now you may be asking yourself, won't going to memory, for

7
00:00:19,310 --> 00:00:22,450
the page table every time we access a memory address

8
00:00:22,450 --> 00:00:25,380
be slow? In fact, we'll have to go multiple times for

9
00:00:25,380 --> 00:00:28,450
our hierarchical page table. Well indeed it would

10
00:00:28,450 --> 00:00:31,610
be. Thankfully the page tables themselves may end up

11
00:00:31,610 --> 00:00:34,200
in our cache, which can help considerably. But

12
00:00:34,200 --> 00:00:37,180
architects have also created a special purpose cache for

13
00:00:37,180 --> 00:00:40,230
storing page table entries, called the table lookaside

14
00:00:40,230 --> 00:00:43,880
buffer. Or TLB for short. Instead of going through

15
00:00:43,880 --> 00:00:47,680
these slower traditional memory mechanisms, we're taking a special

16
00:00:47,680 --> 00:00:50,610
shortcut. Whereas the caches we talked about earlier are

17
00:00:50,610 --> 00:00:54,830
usually indexed by physical address, the TLB is indexed

18
00:00:54,830 --> 00:00:57,310
by virtual address. After all, its job is to

19
00:00:57,310 --> 00:01:00,910
translate virtual page numbers to physical ones. This is

20
00:01:00,910 --> 00:01:03,770
extra tricky, because one virtual page number may be mapped

21
00:01:03,770 --> 00:01:06,210
to a physical address in one process, but it

22
00:01:06,210 --> 00:01:08,980
might be invalid in another or mapped to different

23
00:01:08,980 --> 00:01:12,160
location. There are two ways to handle this problem.

24
00:01:12,160 --> 00:01:16,050
Some systems simply flush the TLB, on every context switch.

25
00:01:16,050 --> 00:01:19,540
That is, every time the address space switches. This is

26
00:01:19,540 --> 00:01:23,800
a main reason that context switches are considered so costly. Alternatively,

27
00:01:23,800 --> 00:01:26,468
the TLB can use an address space identifier field in the

28
00:01:26,468 --> 00:01:29,194
table, to make sure that the translation in the table is

29
00:01:29,194 --> 00:01:32,080
meant for use in the current context. I should point out,

30
00:01:32,080 --> 00:01:35,300
too, that the kernel sometimes get's special treatment in the TLB.

31
00:01:35,300 --> 00:01:38,390
Because the kernel addresses our constant across processes, there is no

32
00:01:38,390 --> 00:01:41,670
need to flush them from the TLB on a context switch.

33
00:01:41,670 --> 00:01:44,680
Sometimes, too, part of the TLB is reserved for kernel addresses.
