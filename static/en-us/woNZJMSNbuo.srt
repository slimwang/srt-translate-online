1
00:00:00,000 --> 00:00:03,687
In the previous exercise, we had to
sent the username and password with

2
00:00:03,687 --> 00:00:07,627
every request that was protected by
the off.loginrequired_decorator.

3
00:00:07,627 --> 00:00:09,051
This is inconvenient and

4
00:00:09,051 --> 00:00:13,640
can be seen as a security risk even
if the transport is secure HTTP.

5
00:00:13,640 --> 00:00:16,890
Since the client application must
have those credentials stored without

6
00:00:16,890 --> 00:00:20,280
encryption to be able to send
them with these requests.

7
00:00:20,280 --> 00:00:24,560
When rendering HTML pages with Flask, we
had the ability to use the login session

8
00:00:24,560 --> 00:00:28,310
object to store information about the
state of the client between requests.

9
00:00:28,310 --> 00:00:30,770
Flask did this by creating
an encrypted cookie for

10
00:00:30,770 --> 00:00:34,120
us that the browser could
append to each HTTP request.

11
00:00:34,120 --> 00:00:37,580
But since our RESTful API may not
always work with the browser or

12
00:00:37,580 --> 00:00:40,860
a client that can securely store and
transmit cookies,

13
00:00:40,860 --> 00:00:43,820
we need another method for storing and
communicating credentials.

14
00:00:45,710 --> 00:00:49,220
A popular solution to this
problem is to create tokens.

15
00:00:49,220 --> 00:00:51,380
A token is a string that
the server generates for

16
00:00:51,380 --> 00:00:55,700
the client that can be passed
along inside an HTTP request.

17
00:00:55,700 --> 00:00:59,560
The idea is that the client application
exchanges authentication credentials for

18
00:00:59,560 --> 00:01:01,450
an authentication token and

19
00:01:01,450 --> 00:01:04,430
in subsequent requests,
just sends the token.

20
00:01:04,430 --> 00:01:05,970
When the server receives the token,

21
00:01:05,970 --> 00:01:08,940
it can then look up the credentials
of the user and determine whether or

22
00:01:08,940 --> 00:01:12,520
not it is authorized to
the information it is requesting.

23
00:01:12,520 --> 00:01:16,650
Tokens are usually given out with an
expiration time after which they become

24
00:01:16,650 --> 00:01:19,113
invalid and
a new token needs to be obtained.

25
00:01:19,113 --> 00:01:23,153
The potential damage that can be caused
if a token is leaked is much smaller due

26
00:01:23,153 --> 00:01:24,534
to their short life span.

27
00:01:24,534 --> 00:01:28,476
A server can easily determine if a token
is to old and decide to reject it,

28
00:01:28,476 --> 00:01:30,235
if it doesn't view it as valid.

29
00:01:30,235 --> 00:01:32,650
So how would we go
about creating tokens?

30
00:01:32,650 --> 00:01:35,883
A straight forward implementation
is to generate a random sequence of

31
00:01:35,883 --> 00:01:38,677
characters of certain length
that is stored with the user and

32
00:01:38,677 --> 00:01:41,080
the password in the database.

33
00:01:41,080 --> 00:01:43,120
Possibly with an expiration date,
as well.

34
00:01:43,120 --> 00:01:47,240
The token then becomes sort of a plain
text password in that it can easily

35
00:01:47,240 --> 00:01:51,650
be verified with the string comparison
plus a check of its expiration date.

36
00:01:51,650 --> 00:01:55,565
A more elaborate implementation that
requires no server side storage

37
00:01:55,565 --> 00:01:59,460
is to use a cryptographically
signed message as a token.

38
00:01:59,460 --> 00:02:02,976
This has the advantage that
the information related to the token

39
00:02:02,976 --> 00:02:07,274
namely the user for which the token was
generated is encoded in the token itself

40
00:02:07,274 --> 00:02:11,398
and protected against tampering with
a strong cryptographic signature.

41
00:02:11,398 --> 00:02:14,753
Flask uses a similar approach
to write secure cookies.

42
00:02:14,753 --> 00:02:18,210
This implementation is based on
a package called itsdangerous.

43
00:02:19,220 --> 00:02:22,120
In the next video,
we will use the itsdangerous library

44
00:02:22,120 --> 00:02:26,220
as we take on adding token generation
and verification to our user model.
