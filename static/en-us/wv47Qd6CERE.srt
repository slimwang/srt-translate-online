1
00:00:00,160 --> 00:00:03,250
So for this menu project, I want to
create an application where I can make

2
00:00:03,250 --> 00:00:07,470
various restaurant menus with various
items, often within one application.

3
00:00:07,470 --> 00:00:10,600
All restaurant menus in the general
sense contain the same thing.

4
00:00:10,600 --> 00:00:14,860
Some have a few appetizers,
some entrees, a few desserts, and

5
00:00:14,860 --> 00:00:16,149
of course some beverages.

6
00:00:16,149 --> 00:00:19,570
To keep things simple, let's call
all of these things menu items.

7
00:00:19,570 --> 00:00:23,170
And all of my menu items belong
to a specific restaurant menu.

8
00:00:23,170 --> 00:00:25,260
It also would be helpful
to have a price and

9
00:00:25,260 --> 00:00:27,830
brief description for
each of our menu items.

10
00:00:27,830 --> 00:00:31,760
An important early design decision
to make is how to model my database.

11
00:00:31,760 --> 00:00:34,310
There is more than one correct
way to structure a database, but

12
00:00:34,310 --> 00:00:36,150
there is no need to make
things too complicated.

13
00:00:36,150 --> 00:00:39,560
Let's walk through the process of
making a database layout together.

14
00:00:39,560 --> 00:00:43,320
We have a restaurant table to represent
all of the restaurants in our database,

15
00:00:43,320 --> 00:00:46,250
along with a corresponding name and
ID number.

16
00:00:46,250 --> 00:00:48,280
Then we have a table of menu items.

17
00:00:48,280 --> 00:00:53,820
Each menu item will have a name,
an ID, a description, a price, and

18
00:00:53,820 --> 00:00:59,150
a course to categorize whether it is an
appetizer, entree, dessert or beverage.

19
00:00:59,150 --> 00:01:02,610
We will also provide a restaurant
ID to assign a foreign key

20
00:01:02,610 --> 00:01:05,319
relationship with our restaurant table.

21
00:01:05,319 --> 00:01:05,910
Okay.
So

22
00:01:05,910 --> 00:01:08,120
we've planned out how we
will design our database.

23
00:01:08,120 --> 00:01:09,850
Now let's get to coding it up.

24
00:01:09,850 --> 00:01:13,780
If you've used SQL before you might be
used to writing something like this.

25
00:01:13,780 --> 00:01:17,040
If you're not an SQL expert it might
be a little hard to understand though.

26
00:01:17,040 --> 00:01:19,280
Now there is nothing
wrong with this code, but

27
00:01:19,280 --> 00:01:21,010
let's take a look at it for a second.

28
00:01:21,010 --> 00:01:25,260
Using raw SQL we have this inquiries
to the database as strings.

29
00:01:25,260 --> 00:01:29,670
This works, but our Python compiler has
no way of helping me if I make a typo or

30
00:01:29,670 --> 00:01:31,670
reference a table that doesn't exist.

31
00:01:31,670 --> 00:01:35,080
Every other data structure we use
in Python is some type of object.

32
00:01:35,080 --> 00:01:39,255
So why not treat our database queries,
tables, and rows as objects as well.

33
00:01:39,255 --> 00:01:42,905
Well this concern isn't a unique one,
and developers have created tools for

34
00:01:42,905 --> 00:01:43,770
this very problem.

35
00:01:43,770 --> 00:01:48,495
Object-Relational Mappers, or ORM's,
can be thought of like a translator.

36
00:01:48,495 --> 00:01:51,235
Converting our code from
one form to another.

37
00:01:51,235 --> 00:01:54,562
If we send off code written in Python or
any other preferred programming

38
00:01:54,562 --> 00:01:59,802
language, it is transformed by the ORM
into SQL and sent off to our database.

39
00:01:59,802 --> 00:02:03,182
The ORM also gets results
from an SQL statement and

40
00:02:03,182 --> 00:02:05,812
allows us to use it as an object
from within our Python code.
