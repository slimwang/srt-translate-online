1
00:00:00,120 --> 00:00:03,450
So how do we implement
reusable barriers correctly?

2
00:00:03,450 --> 00:00:04,530
This is how.

3
00:00:04,530 --> 00:00:07,140
The idea here is that the value for

4
00:00:07,140 --> 00:00:12,300
releasing the barrier will not be the
same for all instances of the barrier.

5
00:00:12,300 --> 00:00:16,090
Even instances when
release becomes zero,

6
00:00:16,090 --> 00:00:19,550
all instances are going to
release when release becomes one.

7
00:00:19,550 --> 00:00:23,740
So the idea is that we never really
need to reinitialize the release.

8
00:00:23,740 --> 00:00:25,640
We just flip the release.

9
00:00:25,640 --> 00:00:27,900
Each thread now has a localSense,

10
00:00:27,900 --> 00:00:32,500
which is kind of what's the release
that we should get in order to get out?

11
00:00:32,500 --> 00:00:35,160
So if we have 2 threads, 0 and 1,

12
00:00:35,160 --> 00:00:39,530
let's say that they started
with localSense being 0.

13
00:00:39,530 --> 00:00:41,990
Now they're going to get here and

14
00:00:41,990 --> 00:00:45,530
they're both going to figure
out that the localSense is 1.

15
00:00:45,530 --> 00:00:47,300
localSense is local to each thread, so

16
00:00:47,300 --> 00:00:49,900
each of them just sets a local
variable independently.

17
00:00:49,900 --> 00:00:52,460
So, this is not going to
interfere with each other.

18
00:00:52,460 --> 00:00:58,340
Now, one of the thread will enter
the counter lock, increment the count,

19
00:00:58,340 --> 00:01:02,870
and here if the count is equal to the
total, they will reset the count, and

20
00:01:02,870 --> 00:01:04,650
set the release to localSense.

21
00:01:04,650 --> 00:01:08,840
So it sets the release to
what we are waiting for,

22
00:01:08,840 --> 00:01:13,840
in this case,
let's say thread one releases it to one.

23
00:01:13,840 --> 00:01:15,620
That means that thread 0,

24
00:01:15,620 --> 00:01:20,590
when it incremented account, didn't
see the total at 2, it saw it at 1,

25
00:01:20,590 --> 00:01:25,320
and proceeded to exit here and
enters this wait here.

26
00:01:25,320 --> 00:01:26,840
It's waiting now for

27
00:01:26,840 --> 00:01:31,880
the release to become what it
thinks localSense is which is 1.

28
00:01:31,880 --> 00:01:35,270
So it's going to spin until
somebody puts 1 into the release.

29
00:01:35,270 --> 00:01:37,220
Eventually, thread 1 does that.

30
00:01:37,220 --> 00:01:40,650
So now let's say that
thread 0 is stuck here,

31
00:01:40,650 --> 00:01:43,740
that was the problem with the previous
implementation of the barrier.

32
00:01:43,740 --> 00:01:46,110
Let's say that we just
don't read it fast enough.

33
00:01:46,110 --> 00:01:50,360
So we want to see a 1, but
we don't check it fast enough.

34
00:01:50,360 --> 00:01:54,750
Thread 1, now, proceeds to exit,
finishes the work and

35
00:01:54,750 --> 00:01:57,950
comes back to the second
instance of the barrier.

36
00:01:57,950 --> 00:02:01,569
It now flips its own localSense to 0.

37
00:02:01,569 --> 00:02:06,171
Increments that count to 1,
because we reset the count when we were

38
00:02:06,171 --> 00:02:10,934
releasing the first instance,
checks the count, sees that it is 1,

39
00:02:10,934 --> 00:02:15,800
doesn't do this, unlocks the lock,
and enters the spin here.

40
00:02:15,800 --> 00:02:20,128
But thread 1 is now checking
whether the release has become 0,

41
00:02:20,128 --> 00:02:22,626
because it flipped the localSense.

42
00:02:22,626 --> 00:02:26,254
Now it's waiting for this value for
the release, so they're waiting for

43
00:02:26,254 --> 00:02:28,100
different value.

44
00:02:28,100 --> 00:02:31,000
Note that the release is still the same

45
00:02:31,000 --> 00:02:33,240
as thread 1 left it in
the first instance.

46
00:02:33,240 --> 00:02:35,880
So eventually thread 0 will check and

47
00:02:35,880 --> 00:02:39,925
see that the release has become 1,
at which point it will leave.

48
00:02:39,925 --> 00:02:44,700
Eventually it's going to come here,
change its local sense to 0,

49
00:02:44,700 --> 00:02:47,990
increment the count,
see that it's 2, reset the count,

50
00:02:47,990 --> 00:02:52,970
set the release to 0 this time,
and now thread 1 will be released.

51
00:02:52,970 --> 00:02:56,750
So by flipping the value of the release
instead of reinitializing it in each

52
00:02:56,750 --> 00:02:59,340
iteration of the loop,
we avoid the problem that we had.

53
00:02:59,340 --> 00:03:01,880
So this barrier is reusable.

54
00:03:01,880 --> 00:03:04,840
We can synchronize on
the same barrier over and

55
00:03:04,840 --> 00:03:07,570
over without risking
that lock situations.
