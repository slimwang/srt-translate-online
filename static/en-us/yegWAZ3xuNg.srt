1
00:00:00,380 --> 00:00:02,350
Now, let's see what happens in a typical

2
00:00:02,350 --> 00:00:05,430
parallel program. In a typical parallel program that you

3
00:00:05,430 --> 00:00:08,910
might write, you probably get a lock, and you

4
00:00:08,910 --> 00:00:13,390
have, mentally, an association between that lock and the

5
00:00:13,390 --> 00:00:16,140
data structures that are governed by that lock.

6
00:00:16,140 --> 00:00:18,520
Or in other words, in writing your parallel program,

7
00:00:18,520 --> 00:00:23,490
you decided that access to variables a and b

8
00:00:23,490 --> 00:00:25,660
are governed by this lock. So if I wanted

9
00:00:25,660 --> 00:00:29,580
to read or write variables a and b, I'll

10
00:00:29,580 --> 00:00:32,090
get a lock and then I will mess with the

11
00:00:32,090 --> 00:00:34,700
variables that are governed by this lock. Once I'm

12
00:00:34,700 --> 00:00:38,050
done with whatever I want to do with these shared variables,

13
00:00:38,050 --> 00:00:41,340
I'll unlock indicating that I'm done. And this is

14
00:00:41,340 --> 00:00:43,950
my critical section. So within the critical section, and we're

15
00:00:43,950 --> 00:00:46,620
allowed to do whatever I want on these data

16
00:00:46,620 --> 00:00:50,760
structures that are governed by this particular lock, because that

17
00:00:50,760 --> 00:00:54,570
is an association I as the programmer has made

18
00:00:54,570 --> 00:00:57,370
in writing the parallel program. So if another processor

19
00:00:57,370 --> 00:01:01,550
let's say P2 gets the same lock. It's going

20
00:01:01,550 --> 00:01:04,420
to get the lock only after I release it. So

21
00:01:04,420 --> 00:01:07,000
only after I release the lock, this guy can

22
00:01:07,000 --> 00:01:10,270
get this lock because the semantics of the lock, it

23
00:01:10,270 --> 00:01:13,670
is a mutually exclusive lock. And therefore, only one

24
00:01:13,670 --> 00:01:16,840
person can have the lock at a time. And consequently,

25
00:01:16,840 --> 00:01:19,460
if you look at the structure of this critical section

26
00:01:19,460 --> 00:01:22,960
for P2, it gets a lock. And it is messing

27
00:01:22,960 --> 00:01:26,110
with the same set of data structures that I was

28
00:01:26,110 --> 00:01:30,610
messing with, over here. But, by design, we know that either

29
00:01:30,610 --> 00:01:34,100
P1 or P2 can be messing with the data structure

30
00:01:34,100 --> 00:01:36,650
at any point of time. And that's a guarantee that

31
00:01:36,650 --> 00:01:38,720
I know comes from the fact that I designed the

32
00:01:38,720 --> 00:01:42,860
pilot program. And the lock is associated with these data structures.

33
00:01:42,860 --> 00:01:49,250
So, in other words, p2 is not going to access any of the data that, that

34
00:01:49,250 --> 00:01:55,500
is inside this critical section until p1 releases the lock. We know this because

35
00:01:55,500 --> 00:01:58,590
we designed this program, but the sc

36
00:01:58,590 --> 00:02:02,260
memory model does not know about the association

37
00:02:02,260 --> 00:02:04,650
between these data structures and this lock.

38
00:02:04,650 --> 00:02:08,460
And, in particular, doesn't even know that memory

39
00:02:08,460 --> 00:02:11,480
accesses emanating from the processor due to

40
00:02:11,480 --> 00:02:15,540
this lock primitive is a different animal compared

41
00:02:15,540 --> 00:02:17,320
to the memory accesses coming from the

42
00:02:17,320 --> 00:02:21,400
processor as a result of accessing normal data

43
00:02:21,400 --> 00:02:24,750
structures. So the cash coherence mechanism that

44
00:02:24,750 --> 00:02:27,850
is provided by the system for implementing the

45
00:02:27,850 --> 00:02:30,780
memory consistency model is going to be doing

46
00:02:30,780 --> 00:02:33,980
more work than it needs to do because

47
00:02:33,980 --> 00:02:36,140
it's going to be taking actions on every

48
00:02:36,140 --> 00:02:39,480
one of these accesses, even though the coherence

49
00:02:39,480 --> 00:02:43,110
actions are not warranted for these guys until

50
00:02:43,110 --> 00:02:46,070
I release the lock. So what that means

51
00:02:46,070 --> 00:02:49,500
is that there's going to be more overhead for

52
00:02:49,500 --> 00:02:52,920
maintaining the coherence [UNKNOWN] with the SC memory

53
00:02:52,920 --> 00:02:55,860
model, which means it's going to lead to

54
00:02:55,860 --> 00:02:59,173
a poorer scalability of the shared memory system.

55
00:02:59,173 --> 00:03:02,930
So in this particular example since P2 is not

56
00:03:02,930 --> 00:03:06,880
going to access any of these data structures until P1

57
00:03:06,880 --> 00:03:10,750
has released the lock there's no need for coherence action

58
00:03:10,750 --> 00:03:15,040
for a and b until the lock is actually released.
