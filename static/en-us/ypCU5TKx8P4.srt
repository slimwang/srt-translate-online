1
00:00:00,000 --> 00:00:02,000
Bonus, bonus.

2
00:00:02,000 --> 00:00:05,000
What if we want to return all the sublists

3
00:00:05,000 --> 00:00:07,000
in one big list instead of printing them out?

4
00:00:07,000 --> 00:00:09,000
Well, let's try something like this.

5
00:00:09,000 --> 00:00:12,000
Instead of printing out what we've selected so far,

6
00:00:12,000 --> 00:00:16,000
I will return it, and then down here when I make my 2 recursive calls,

7
00:00:16,000 --> 00:00:20,000
I'll make a list of the first one and add it to the list of the second one

8
00:00:20,000 --> 00:00:24,000
and see how that works, and to make it a little easier to evaluate the answer,

9
00:00:24,000 --> 00:00:28,000
we'll go back down to just 2 people, so we know there should be 4 options.

10
00:00:28,000 --> 00:00:30,000
When we stare at it a bit, this looks pretty good.

11
00:00:30,000 --> 00:00:32,000
Here's the answer with both of them.

12
00:00:32,000 --> 00:00:34,000
Here's one. Here's the other, and here's no one.

13
00:00:34,000 --> 00:00:36,000
But let's check and make sure that it's actually coming out equally.

14
00:00:36,000 --> 00:00:38,000
If it's coming out equally, I should be able to get these 4 elements

15
00:00:38,000 --> 00:00:41,000
out of the list independently, the 4 answers.

16
00:00:41,000 --> 00:00:43,000
Uh-oh. That didn't work.

17
00:00:43,000 --> 00:00:46,000
We can see that we haven't been building this up into

18
00:00:46,000 --> 00:00:48,000
sort of an evenly balanced list.

19
00:00:48,000 --> 00:00:50,000
There are too many opening square brackets here,

20
00:00:50,000 --> 00:00:52,000
not enough in other places.

21
00:00:52,000 --> 00:00:54,000
I could try returning this as a singleton list,

22
00:00:54,000 --> 00:00:57,000
but it doesn't make us any happier.

23
00:00:57,000 --> 00:01:00,000
But here, if I return the base case as a singleton list

24
00:01:00,000 --> 00:01:04,000
and then concatenate these 2 lists together,

25
00:01:04,000 --> 00:01:06,000
I get the 4 separate parts of the answers I was expecting.

26
00:01:06,000 --> 00:01:09,000
Just to review that, I'm going to go back to the wrong world.

27
00:01:09,000 --> 00:01:12,000
Here's the wrong world where in the leaf case

28
00:01:12,000 --> 00:01:15,000
I just returned the list of people selected so far.

29
00:01:15,000 --> 00:01:19,000
And then in the recursive case, I make a list of that and concatenate it with the list of the other.

30
00:01:19,000 --> 00:01:21,000
That actually doesn't work out.

31
00:01:21,000 --> 00:01:24,000
What I really want instead is to return a singleton list

32
00:01:24,000 --> 00:01:26,000
at every leaf and then just gather them up.

33
00:01:26,000 --> 00:01:31,000
They may seem very similar, but if the depth of the tree

34
00:01:31,000 --> 00:01:34,000
is more than 1, if this is a long tree that might have 8 things at the bottom,

35
00:01:34,000 --> 00:01:39,000
the wrong way ends up adding too many sort of nested levels of listing.

36
00:01:39,000 --> 00:01:42,000
This way adds exactly the right amount.

37
00:01:42,000 --> 00:01:44,000
Here let's just print out our answer.

38
00:01:44,000 --> 00:01:46,000
Now we can see that it's a list of 4 elements,

39
00:01:46,000 --> 00:01:49,000
both of them, just one, just the other, none of them,

40
00:01:49,000 --> 00:01:52,000
and if I add in Susan B. Anthony, a list of 8 elements.

41
00:01:52,000 --> 00:01:54,000
Nicely done.

42
00:01:54,000 --> 00:01:57,000
You followed along, got some practice with a brute-force procedure

43
00:01:57,000 --> 00:01:59,000
to enumerate all the sublists of a list

44
00:01:59,000 --> 99:59:59,999
and a little more experience with debugging.
