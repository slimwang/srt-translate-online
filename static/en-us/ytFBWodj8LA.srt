1
00:00:00,320 --> 00:00:03,968
We have a problem with transforming normals when using non-uniform scaling

2
00:00:03,968 --> 00:00:08,520
matrices. If we tried to transform the normal with the same scaling matrix used

3
00:00:08,520 --> 00:00:12,860
to transform the vertex coordinates, we ran into the strange situation of

4
00:00:12,860 --> 00:00:17,300
normals getting bent away from their surfaces. How to solve this? I'll jump to

5
00:00:17,300 --> 00:00:22,396
the punch line. What you want to use to transform normals is the transpose of

6
00:00:22,396 --> 00:00:27,317
the inverse of the model matrix. You could also use the inverse of the transpose

7
00:00:27,317 --> 00:00:31,232
of the model matrix. They're the same thing. Either way that's a mouthful and

8
00:00:31,232 --> 00:00:34,626
let me explain. Let's look at how this solution applies to each different kind

9
00:00:34,626 --> 00:00:38,392
of transform that we're used to. First of all, forget about translation

10
00:00:38,392 --> 00:00:42,680
matrices. We're going to be transforming normals and translation matrices do not

11
00:00:42,680 --> 00:00:47,750
affect vectors in any way. For rotation matrices, the transpose is the inverse.

12
00:00:47,750 --> 00:00:51,590
The transpose of the inverse, in other words, would be the inverse of the

13
00:00:51,590 --> 00:00:56,220
inverse. This is starting to sound a little like Alice in Wonderland. To be a

14
00:00:56,220 --> 00:01:00,180
little more clear, if you take the transpose of the inverse of a rotation

15
00:01:00,180 --> 00:01:05,928
matrix, you get the same rotation matrix back. This means that for matrix made

16
00:01:05,928 --> 00:01:10,600
up of any series of translations and rotations you can use this same matrix to

17
00:01:10,600 --> 00:01:15,085
transform points and normals. This is because the transpose is the inverse as

18
00:01:15,085 --> 00:01:19,442
far as normals are concerned. Scaling makes it no longer true that the transpose

19
00:01:19,442 --> 00:01:23,880
is the inverse so, we have to take special steps. If the scaling matrix is

20
00:01:23,880 --> 00:01:28,392
uniform. In other words the shape of the object doesn't change. We can get away

21
00:01:28,392 --> 00:01:31,976
with just normalizing the normals after transforming by the original model

22
00:01:31,976 --> 00:01:36,095
matrix. For non-uniform scaling where the shape of the object does change we

23
00:01:36,095 --> 00:01:40,515
must explicitly compute this special transpose of the inverse matrix in order to

24
00:01:40,515 --> 00:01:45,176
transform normals correctly. Or you can do the inverse of the transpose. I'm not

25
00:01:45,176 --> 00:01:49,338
going to explain here why the transpose of the inverse works. You likely don't

26
00:01:49,338 --> 00:01:53,114
want me to talk about contravariant and covariant vectors. See the additional

27
00:01:53,114 --> 00:01:57,655
course materials for more information. If you keep away from non-uniform scaling

28
00:01:57,655 --> 00:02:01,620
matrices, you'll never run into this mismatch and can merely use the modeling

29
00:02:01,620 --> 00:02:05,554
matrix for both position and vector transforms. If you never use scales of any

30
00:02:05,554 --> 00:02:09,463
sort you won't even have to re-normalize your vectors. The good news is that if

31
00:02:09,463 --> 00:02:13,349
you use scales of any sort in three.js it will correctly handle normal

32
00:02:13,349 --> 00:02:17,405
transformation for you. It's only when you're using scales on your own that you

33
00:02:17,405 --> 00:02:21,045
can get pretty weird shading results if you don't pay attention. And you do want

34
00:02:21,045 --> 00:02:25,628
to pay attention. As while this is always the correct answer, it's costly to

35
00:02:25,628 --> 00:02:30,110
compute all the time. I've seen many a young programmer led astray by normal

36
00:02:30,110 --> 00:02:35,719
transformation. Seriously, back in the 1980s before any book ever mentioned it.

37
00:02:35,720 --> 00:02:39,990
This problem was fairly common. Back then, we consulted for a hardware company,

38
00:02:39,990 --> 00:02:44,086
who will rename nameless, writing programs using their expensive graphics

39
00:02:44,086 --> 00:02:49,352
accelerator. And I mean expensive, something like $35,000, the price of a nice

40
00:02:49,352 --> 00:02:52,920
BMW back then. I found that the graphics accelerator had this problem with

41
00:02:52,920 --> 00:02:57,422
polygon display. Meaning we had to avoid using non-uniform scales as a modeling

42
00:02:57,422 --> 00:03:01,892
operation. The company was more than a bit dismayed when they found out about

43
00:03:01,892 --> 00:03:04,483
this problem, since it's costly to fix properly.
