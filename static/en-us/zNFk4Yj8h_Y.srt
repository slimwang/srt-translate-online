1
00:00:00,290 --> 00:00:04,019
Now suppose you implement
par.for in this way.

2
00:00:04,019 --> 00:00:07,350
Let's replace par.for
with a procedure call.

3
00:00:07,350 --> 00:00:10,834
This procedure call takes the function,
or the loop body,

4
00:00:10,834 --> 00:00:12,653
as well as an iteration range.

5
00:00:12,653 --> 00:00:14,533
In this case 1 to n.

6
00:00:14,533 --> 00:00:18,040
The procedure call itself
is implemented as follows.

7
00:00:18,040 --> 00:00:20,960
We figure out how many
iterations there are,

8
00:00:20,960 --> 00:00:27,140
call that little n if there's only one
iteration, and we'll call foo on a.

9
00:00:27,140 --> 00:00:29,710
Otherwise, we'll do divide and conquer.

10
00:00:29,710 --> 00:00:35,075
Essentially breaking the iteration
range a to b into a to m-1, and m to b.

11
00:00:35,075 --> 00:00:38,830
Where m is approximately the midpoint.

12
00:00:38,830 --> 00:00:43,120
This scheme will give you the usual
sort of binary tree recursion.

13
00:00:43,120 --> 00:00:47,790
So if you ask, what's the span of
this DAG, it should be logarithmic.

14
00:00:47,790 --> 00:00:51,102
Now what I've just given you is a much
more realistic way to implement

15
00:00:51,102 --> 00:00:52,510
a parallel for loop.

16
00:00:52,510 --> 00:00:57,055
So what I want you to do from now on
is to assume this implementation.

17
00:00:57,055 --> 00:01:02,017
That means if I tell you that the loop
body of a par.for has constant cost,

18
00:01:02,017 --> 00:01:05,553
and I ask you what the span is,
the span will be log n.

19
00:01:05,553 --> 00:01:09,588
And, again, this is in contrast to
assuming that the span is, say,

20
00:01:09,588 --> 00:01:11,350
constant cost.

21
00:01:11,350 --> 00:01:13,020
Which is what it would be in theory.
