1
00:00:00,670 --> 00:00:05,070
Is partial order good enough for constructing deterministic

2
00:00:05,070 --> 00:00:08,100
distributed algorithms? It turns out, it may be

3
00:00:08,100 --> 00:00:12,440
sufficient for many situations. The airline reservation example

4
00:00:12,440 --> 00:00:14,640
I started with would work fine with a

5
00:00:14,640 --> 00:00:18,620
partial order of events dictated by Lamport's clock.

6
00:00:18,620 --> 00:00:21,150
But there are situations where there maybe a

7
00:00:21,150 --> 00:00:23,910
need for a total order of events in

8
00:00:23,910 --> 00:00:26,100
the distributed system. Let's look at an example.

9
00:00:27,260 --> 00:00:29,930
Here is an example to illustrate the need for

10
00:00:29,930 --> 00:00:33,230
a total order. I'm going to use my own, personal

11
00:00:33,230 --> 00:00:36,500
life example to illustrate the need for total order.

12
00:00:36,500 --> 00:00:39,780
I have, one car and my family consists of

13
00:00:39,780 --> 00:00:42,820
my wife, my son and my daughter, and we

14
00:00:42,820 --> 00:00:45,970
share this single car. And what we want to do

15
00:00:45,970 --> 00:00:49,100
is make sure that we can make local decision

16
00:00:49,100 --> 00:00:52,270
on who gets dibs on using the car at any

17
00:00:52,270 --> 00:00:54,810
point of time. And we're going to use Lamport's clock for this.

18
00:00:54,810 --> 00:00:57,760
So what we do is, whenever we want to get the

19
00:00:57,760 --> 00:01:01,620
car for our personal use, we're going to text everyone with a

20
00:01:01,620 --> 00:01:04,620
time stamp. I'm going to associate a time stamp, if I'm, if I'm

21
00:01:04,620 --> 00:01:08,170
requesting the car, I'm going to text every one, and associate a

22
00:01:08,170 --> 00:01:12,820
time stamp with that request. And it is a logical time-stamp

23
00:01:12,820 --> 00:01:15,230
and similarly my wife would do the same thing, son and

24
00:01:15,230 --> 00:01:17,430
daughter all of us do the same thing. And how do we

25
00:01:17,430 --> 00:01:20,345
pick the winner, well, locally we can look at the

26
00:01:20,345 --> 00:01:24,070
time-stamp of request that have come in from others and my

27
00:01:24,070 --> 00:01:28,448
own request. And whoever has the earliest time stamp wins. Pretty

28
00:01:28,448 --> 00:01:31,130
simple, right? So pretty simple, everybody is going to make a

29
00:01:31,130 --> 00:01:34,160
local decision, looking at the time stamps of request that

30
00:01:34,160 --> 00:01:36,570
have come in from others and say well, you know right

31
00:01:36,570 --> 00:01:40,535
now, it's my son's turn to use the car, or my

32
00:01:40,535 --> 00:01:42,820
daughter's turn to use the car and so on. But what

33
00:01:42,820 --> 00:01:46,610
if the time stamp, because these are locally generated by

34
00:01:46,610 --> 00:01:49,160
each one of us, happens to be the same. So, for

35
00:01:49,160 --> 00:01:52,420
instance, let's say my son makes a request. Takes, sends a

36
00:01:52,420 --> 00:01:55,790
text message. My son makes a request, sends a text message

37
00:01:55,790 --> 00:01:58,200
with a time stamp ten to all of us. So this

38
00:01:58,200 --> 00:02:01,130
is the blue arrow that's going everywhere, so that's indicating to

39
00:02:01,130 --> 00:02:04,560
all three of us that he wants the car, and timestamp

40
00:02:04,560 --> 00:02:08,080
ten is when he generated the request. So happens, my wife

41
00:02:08,080 --> 00:02:11,720
also makes a request for using the car, exactly

42
00:02:11,720 --> 00:02:14,160
with the same timestamp ten. And that's the purple

43
00:02:14,160 --> 00:02:21,070
arrow that you see. So, now we have a problem. And the problem is, all of us are

44
00:02:21,070 --> 00:02:24,040
looking at these text messages and trying to make

45
00:02:24,040 --> 00:02:26,530
a decision, who's got the dibs on using the

46
00:02:26,530 --> 00:02:30,480
car? How will my son and my wife know,

47
00:02:30,480 --> 00:02:33,570
given that both the time stamp is the same,

48
00:02:33,570 --> 00:02:36,010
which one is the winner for using this car?

49
00:02:36,010 --> 00:02:39,060
Now, what we do is, we're going to break the

50
00:02:39,060 --> 00:02:43,200
tie, and I'm going to stipulate that age wins. And

51
00:02:43,200 --> 00:02:46,110
therefore, in this case, if the time stamp happens to

52
00:02:46,110 --> 00:02:50,640
be exactly the same, then my wife, by seniority, is

53
00:02:50,640 --> 00:02:52,620
the winner. She gets the car. So, that's how we

54
00:02:52,620 --> 00:02:55,450
break the tie. You can see, through this example, that

55
00:02:55,450 --> 00:02:59,130
there is a need for total order in decision making

56
00:02:59,130 --> 00:03:01,860
when you have a distributed system. And you want

57
00:03:01,860 --> 00:03:06,020
to make local decisions without bothering anyone, based on

58
00:03:06,020 --> 00:03:08,300
information that you have, but you have to make

59
00:03:08,300 --> 00:03:12,440
that local decision unambiguously, because you cannot have both

60
00:03:12,440 --> 00:03:15,450
my son and wife thinking that they have the

61
00:03:15,450 --> 00:03:17,900
car at the same time. That'll be a problem.

62
00:03:17,900 --> 00:03:19,800
So, whenever there is a tie, we have to

63
00:03:19,800 --> 00:03:22,930
break that, and that's the need for the total order.
