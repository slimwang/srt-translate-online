1
00:00:00,000 --> 00:00:03,000
We're going to use list comprehensions to help us write our parser.

2
00:00:03,000 --> 00:00:05,000
We were introduced to them earlier,

3
00:00:05,000 --> 00:00:09,000
and many computer scientists love list comprehensions

4
00:00:09,000 --> 00:00:13,000
because they allow you to state what must be true about a list

5
00:00:13,000 --> 00:00:15,000
and let the computer figure out how to get there.

6
00:00:15,000 --> 00:00:18,000
Just to remind you a bit of list comprehensions.

7
00:00:18,000 --> 00:00:22,000
We use the square bracket to say, "I'm making a list."

8
00:00:22,000 --> 00:00:25,000
but instead of listing all of the elements directly,

9
00:00:25,000 --> 00:00:27,000
I have some sort of formula.

10
00:00:27,000 --> 00:00:31,000
What I really want is to take all of the elements in 1, 2, 3, 4, 5--

11
00:00:31,000 --> 00:00:33,000
let's call each of those x.

12
00:00:33,000 --> 00:00:39,000
I want my new list to be all of those squared, so x items x.

13
00:00:39,000 --> 00:00:45,000
So 1, 2, 3, 4, 5 should give us 1, 4, 9, 16, 25, and down here in the output it does.

14
00:00:45,000 --> 00:00:49,000
In list comprehensions we can also put little clauses or guards

15
00:00:49,000 --> 00:00:52,000
to only take some of the input list.

16
00:00:52,000 --> 00:00:57,000
Let's say that I only want to square those numbers that are odd.

17
00:00:57,000 --> 00:01:02,000
I write everything just the same as before, but at the end I put in this little guard

18
00:01:02,000 --> 00:01:07,000
that says "only yield this element if x modulo 2 is 1."

19
00:01:07,000 --> 00:01:11,000
That is, if x is odd, if the remainder when dividing x by 2 is 1.

20
00:01:11,000 --> 00:01:18,000
The second list only contains 1, 9, and 25 for the numbers 1, 3, and 5.

21
00:01:18,000 --> 00:01:22,000
We had our little refresher on list comprehensions.

22
00:01:22,000 --> 00:01:25,000
Now we want to parse a string according to a grammar.

23
00:01:25,000 --> 00:01:28,000
Let's say our grammar would look like this if we wrote it down on a piece of paper.

24
00:01:28,000 --> 00:01:31,000
We need to encode it in Python. Here is one way to do it.

25
00:01:31,000 --> 00:01:35,000
I'm going to take all of the left hand sides of all of the rules

26
00:01:35,000 --> 00:01:37,000
and write them out as the first part of a tuple.

27
00:01:37,000 --> 00:01:43,000
Then all of the right-hand sides, like open P close, becomes elements of a list--

28
00:01:43,000 --> 00:01:45,000
open P close.

29
00:01:45,000 --> 00:01:51,000
Here my grammar had three rules, and here my grammar is a list of three elements.

30
00:01:51,000 --> 00:01:54,000
The second element corresponds to my second grammar rule--

31
00:01:54,000 --> 00:01:59,000
P on the left-hand side, P in the 0th position, open P close on the right-hand side,

32
00:01:59,000 --> 00:02:02,000
open P close in a list on the first position.

33
00:02:02,000 --> 00:02:05,000
I'm going to need to do the same thing with parser states.

34
00:02:05,000 --> 00:02:08,000
Here is how I might draw on in color on a piece of paper,

35
00:02:08,000 --> 00:02:12,000
and here's how I'm going to encode it in Python. This is just one way to do it.

36
00:02:12,000 --> 00:02:16,000
We could pick a different way, but this is going to simplify our implementation.

37
00:02:16,000 --> 00:02:19,000
There are really four parts of our parsing state--

38
00:02:19,000 --> 00:02:26,000
the left-hand side nonterminal, some list of terminals and nonterminals before the dot,

39
00:02:26,000 --> 00:02:28,000
some list after, and j.

40
00:02:28,000 --> 00:02:32,000
The right arrow, the dot, and the word "from"--we always have to write them,

41
00:02:32,000 --> 00:02:35,000
so I don't need to store them. I'm not going to write down "from" every time.

42
00:02:35,000 --> 00:02:37,000
We'll just remember it.

43
00:02:37,000 --> 00:02:40,000
I'm just going to make my state a 4-tuple,

44
00:02:40,000 --> 00:02:46,000
but instead of it being 1, 2, 3, 4, 1 will be the nonterminal on the left.

45
00:02:46,000 --> 00:02:50,000
This will be a list of a and b, and there might be more things here,

46
00:02:50,000 --> 00:02:52,000
or there might be nothing at which point it's the empty list.

47
00:02:52,000 --> 00:02:55,000
Three will be a list of things after the dot.

48
00:02:55,000 --> 00:02:57,000
There might be more things there, or again, there might be nothing,

49
00:02:57,000 --> 00:03:00,000
at which point probably we want to use reduction.

50
00:03:00,000 --> 99:59:59,999
Then j will just be some integer.
