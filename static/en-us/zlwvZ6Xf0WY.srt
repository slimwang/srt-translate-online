1
00:00:00,000 --> 00:00:04,010
And there's actually only a single decidable property here.

2
00:00:04,010 --> 00:00:06,020
All of the other properties are undecidable.

3
00:00:06,020 --> 00:00:09,180
Now let's go quickly through them, one by one, to discuss why that is.

4
00:00:09,180 --> 00:00:12,380
So always returns 1; you know that is undecidable by

5
00:00:12,380 --> 00:00:14,260
Rice's Theorem.

6
00:00:14,260 --> 00:00:15,870
It's a similar case here; we already have that.

7
00:00:15,870 --> 00:00:17,990
Adding 2 numbers, Rice's Theorem.

8
00:00:17,990 --> 00:00:20,130
Doesn't do anything, Rice's Theorem.

9
00:00:20,130 --> 00:00:22,150
No matter how you define doesn't do anything;

10
00:00:22,150 --> 00:00:24,750
it will always come back to Rice's Theorem.

11
00:00:24,750 --> 00:00:27,060
Converts an MP3 file, Rice's Theorem.

12
00:00:27,060 --> 00:00:29,720
Reads a file; that is an interesting one,

13
00:00:29,720 --> 00:00:33,050
because you could argue that this does not fall under Rice's Theorem,

14
00:00:33,050 --> 00:00:35,440
but even if you have that argument,

15
00:00:35,440 --> 00:00:38,050
it's still not decidable, because what I could do, for example

16
00:00:38,050 --> 00:00:41,230
so I can modify any program so it will only read a file

17
00:00:41,230 --> 00:00:43,080
once it's done

18
00:00:43,080 --> 00:00:45,620
and that again will allow me to solve the halting problem.

19
00:00:45,620 --> 00:00:47,760
Is the program a virus; Rice's Theorem.

20
00:00:47,760 --> 00:00:49,030
Writes to a file.

21
00:00:49,030 --> 00:00:51,320
similar logic as reads to a file.

22
00:00:51,320 --> 00:00:53,830
Modifies itself; that is an interesting one,

23
00:00:53,830 --> 00:00:55,800
because of course here you could say

24
00:00:55,800 --> 00:00:58,190
Well, of course I could just go through the code

25
00:00:58,190 --> 00:01:00,550
and whenever the program accesses itself,

26
00:01:00,550 --> 00:01:02,190
I know it has that property,

27
00:01:02,190 --> 00:01:04,200
but the thing is this:

28
00:01:04,200 --> 00:01:07,980
the program could have certain lines that suggest this program modifies itself,

29
00:01:07,980 --> 00:01:10,690
but deciding whether those lines will actually be reached

30
00:01:10,690 --> 00:01:12,540
once the program executes,

31
00:01:12,540 --> 00:01:15,070
that again would allow you to solve the halting problem,

32
00:01:15,070 --> 00:01:17,540
so also this isn't decidable.

33
00:01:17,540 --> 00:01:20,170
The same one here; of course you can look at a certain program

34
00:01:20,170 --> 00:01:22,920
and say, Doesn't the program return integers?

35
00:01:22,920 --> 00:01:25,620
but you had a program that can decide

36
00:01:25,620 --> 00:01:28,060
if a program only returns integers,

37
00:01:28,060 --> 00:01:30,550
that again would allow you to solve the halting problem,

38
00:01:30,550 --> 00:01:32,560
And the same thing for downloading data.

39
00:01:32,560 --> 00:01:35,280
If I had a program that designs generally

40
00:01:35,280 --> 00:01:37,400
for any other program if it downloads data,

41
00:01:37,400 --> 00:01:39,510
I could use the same technique as for reading a file.

42
00:01:39,510 --> 00:01:41,160
I could basically modify any program

43
00:01:41,160 --> 00:01:44,130
so that it could run completely on its own data

44
00:01:44,130 --> 00:01:46,320
that it already has included

45
00:01:46,320 --> 00:01:49,240
and downloads data basically to signify that it's done.

46
00:01:49,240 --> 00:01:51,390
If I could decide this in the general case,

47
00:01:51,390 --> 00:01:53,280
then I would have also solved the halting problem.

48
00:01:53,280 --> 00:01:55,350
Now the question of course is,

49
00:01:55,350 --> 00:01:58,340
If this here has any practical relevance;

50
00:01:58,340 --> 00:02:00,750
for example, reading a file,

51
00:02:00,750 --> 00:02:02,480
because for most programs, of course,

52
00:02:02,480 --> 00:02:04,050
you will be able to decide

53
00:02:04,050 --> 00:02:06,350
if they ever read a file or not.

54
00:02:06,350 --> 00:02:09,690
Then again, on the other hand, if you look at general software testing,

55
00:02:09,690 --> 00:02:13,390
this is an interesting question from a perspective of code coverage, for example.

56
00:02:13,390 --> 00:02:16,320
If you could decide if a program reads a file,

57
00:02:16,320 --> 00:02:18,610
and of course you want the program to read a file,

58
00:02:18,610 --> 99:59:59,999
then that would tell you something about the correctness of that program.
